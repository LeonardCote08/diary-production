(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const IS_DEV = false;
const equalFn = (a, b) => a === b;
const $TRACK = Symbol("solid-track");
const signalOptions = {
  equals: equalFn
};
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
let Transition = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root2 = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: current ? current.context : null,
    owner: current
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root2)));
  Owner = root2;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value2) => {
    if (typeof value2 === "function") {
      value2 = value2(s.value);
    }
    return writeSignal(s, value2);
  };
  return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options) {
  const c = createComputation(fn, value, false, STALE);
  updateComputation(c);
}
function createEffect(fn, value, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value, false, STALE);
  c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn, value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  updateComputation(c);
  return readSignal.bind(c);
}
function untrack(fn) {
  if (Listener === null) return fn();
  const listener = Listener;
  Listener = null;
  try {
    if (ExternalSourceConfig) ;
    return fn();
  } finally {
    Listener = listener;
  }
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null) ;
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function children(fn) {
  const children2 = createMemo(fn);
  const memo2 = createMemo(() => resolveChildren(children2()));
  memo2.toArray = () => {
    const c = memo2();
    return Array.isArray(c) ? c : c != null ? [c] : [];
  };
  return memo2;
}
function readSignal() {
  if (this.sources && this.state) {
    if (this.state === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(node, value, isComp) {
  let current = node.value;
  if (!node.comparator || !node.comparator(current, value)) {
    node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o)) ;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            if (o.observers) markDownstream(o);
          }
          if (!TransitionRunning) o.state = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (IS_DEV) ;
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time = ExecCount;
  runComputation(node, node.value, time);
}
function runComputation(node, value, time) {
  let nextValue;
  const owner = Owner, listener = Listener;
  Listener = Owner = node;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    if (node.pure) {
      {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError(err);
  } finally {
    Listener = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue);
    } else node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Owner === null) ;
  else if (Owner !== UNOWNED) {
    {
      if (!Owner.owned) Owner.owned = [c];
      else Owner.owned.push(c);
    }
  }
  return c;
}
function runTop(node) {
  if (node.state === 0) return;
  if (node.state === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (node.state) ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if (node.state === STALE) {
      updateComputation(node);
    } else if (node.state === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates) return fn();
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  const e = Effects;
  Effects = null;
  if (e.length) runUpdates(() => runEffects(e), false);
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user) runTop(e);
    else queue[userLength++] = e;
  }
  for (i = 0; i < userLength; i++) runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      const state = source.state;
      if (state === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
      } else if (state === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (!o.state) {
      o.state = PENDING;
      if (o.pure) Updates.push(o);
      else Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node.tOwned) {
    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
    delete node.tOwned;
  }
  if (node.owned) {
    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
    node.cleanups = null;
  }
  node.state = 0;
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function handleError(err, owner = Owner) {
  const error = castError(err);
  throw error;
}
function resolveChildren(children2) {
  if (typeof children2 === "function" && !children2.length) return resolveChildren(children2());
  if (Array.isArray(children2)) {
    const results = [];
    for (let i = 0; i < children2.length; i++) {
      const result = resolveChildren(children2[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children2;
}
const FALLBACK = Symbol("fallback");
function dispose(d) {
  for (let i = 0; i < d.length; i++) d[i]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], newLen = newItems.length, i, j;
    newItems[$TRACK];
    return untrack(() => {
      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i = newIndices.get(item);
          newIndicesNext[j] = i === void 0 ? -1 : i;
          newIndices.set(item, j);
        }
        for (i = start; i <= end; i++) {
          item = items[i];
          j = newIndices.get(item);
          if (j !== void 0 && j !== -1) {
            temp[j] = mapped[i];
            tempdisposers[j] = disposers[i];
            indexes && (tempIndexes[j] = indexes[i]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else disposers[i]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j);
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
function createComponent(Comp, props) {
  return untrack(() => Comp(props || {}));
}
const narrowedError = (name2) => `Stale read from <${name2}>.`;
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
}
function Show(props) {
  const keyed = props.keyed;
  const conditionValue = createMemo(() => props.when, void 0, void 0);
  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {
    equals: (a, b) => !a === !b
  });
  return createMemo(() => {
    const c = condition();
    if (c) {
      const child = props.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(() => child(keyed ? c : () => {
        if (!untrack(condition)) throw narrowedError("Show");
        return conditionValue();
      })) : child;
    }
    return props.fallback;
  }, void 0, void 0);
}
function Switch(props) {
  const chs = children(() => props.children);
  const switchFunc = createMemo(() => {
    const ch = chs();
    const mps = Array.isArray(ch) ? ch : [ch];
    let func = () => void 0;
    for (let i = 0; i < mps.length; i++) {
      const index = i;
      const mp = mps[i];
      const prevFunc = func;
      const conditionValue = createMemo(() => prevFunc() ? void 0 : mp.when, void 0, void 0);
      const condition = mp.keyed ? conditionValue : createMemo(conditionValue, void 0, {
        equals: (a, b) => !a === !b
      });
      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : void 0);
    }
    return func;
  });
  return createMemo(() => {
    const sel = switchFunc()();
    if (!sel) return props.fallback;
    const [index, conditionValue, mp] = sel;
    const child = mp.children;
    const fn = typeof child === "function" && child.length > 0;
    return fn ? untrack(() => child(mp.keyed ? conditionValue() : () => {
      var _a;
      if (((_a = untrack(switchFunc)()) == null ? void 0 : _a[0]) !== index) throw narrowedError("Match");
      return conditionValue();
    })) : child;
  }, void 0, void 0);
}
function Match(props) {
  return props;
}
const memo = (fn) => createMemo(() => fn());
function reconcileArrays(parentNode, a, b) {
  let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart])) a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd) map.set(b[i], i++);
      }
      const index = map.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i = aStart, sequence = 1, t;
          while (++i < aEnd && i < bEnd) {
            if ((t = map.get(a[i])) == null || t !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b[bStart++], node);
          } else parentNode.replaceChild(b[bStart++], a[aStart++]);
        } else aStart++;
      } else a[aStart++].remove();
    }
  }
}
const $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
  let disposer;
  createRoot((dispose2) => {
    disposer = dispose2;
    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
  }, options.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template(html, isImportNode, isSVG, isMathML) {
  let node;
  const create = () => {
    const t = document.createElement("template");
    t.innerHTML = html;
    return t.content.firstChild;
  };
  const fn = () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i = 0, l = eventNames.length; i < l; i++) {
    const name2 = eventNames[i];
    if (!e.has(name2)) {
      e.add(name2);
      document2.addEventListener(name2, eventHandler);
    }
  }
}
function setAttribute(node, name2, value) {
  if (value == null) node.removeAttribute(name2);
  else node.setAttribute(name2, value);
}
function className(node, value) {
  if (value == null) node.removeAttribute("class");
  else node.className = value;
}
function addEventListener(node, name2, handler, delegate) {
  {
    if (Array.isArray(handler)) {
      node[`$$${name2}`] = handler[0];
      node[`$$${name2}Data`] = handler[1];
    } else node[`$$${name2}`] = handler;
  }
}
function style(node, value, prev) {
  if (!value) return prev ? setAttribute(node, "style") : value;
  const nodeStyle = node.style;
  if (typeof value === "string") return nodeStyle.cssText = value;
  typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
  prev || (prev = {});
  value || (value = {});
  let v, s;
  for (s in prev) {
    value[s] == null && nodeStyle.removeProperty(s);
    delete prev[s];
  }
  for (s in value) {
    v = value[s];
    if (v !== prev[s]) {
      nodeStyle.setProperty(s, v);
      prev[s] = v;
    }
  }
  return prev;
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function eventHandler(e) {
  let node = e.target;
  const key = `$$${e.type}`;
  const oriTarget = e.target;
  const oriCurrentTarget = e.currentTarget;
  const retarget = (value) => Object.defineProperty(e, "target", {
    configurable: true,
    value
  });
  const handleNode = () => {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data = node[`${key}Data`];
      data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
      if (e.cancelBubble) return;
    }
    node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
    return true;
  };
  const walkUpTree = () => {
    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;
  };
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (e.composedPath) {
    const path = e.composedPath();
    retarget(path[0]);
    for (let i = 0; i < path.length - 2; i++) {
      node = path[i];
      if (!handleNode()) break;
      if (node._$host) {
        node = node._$host;
        walkUpTree();
        break;
      }
      if (node.parentNode === oriCurrentTarget) {
        break;
      }
    }
  } else walkUpTree();
  retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  while (typeof current === "function") current = current();
  if (value === current) return current;
  const t = typeof value, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t === "string" || t === "number") {
    if (t === "number") {
      value = value.toString();
      if (value === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value && (node.data = value);
      } else node = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else current = parent.textContent = value;
    }
  } else if (value == null || t === "boolean") {
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v = value();
      while (typeof v === "function") v = v();
      current = insertExpression(parent, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value.nodeType) {
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent, current, marker, value);
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else parent.replaceChild(value, parent.firstChild);
    current = value;
  } else ;
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap2) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i], prev = current && current[normalized.length], t;
    if (item == null || item === true || item === false) ;
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t === "function") {
      if (unwrap2) {
        while (typeof item === "function") item = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
      else normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0) return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const getBrowserOptimalDrawer = () => {
  const ua = navigator.userAgent;
  const isSafari2 = /^((?!chrome|android).)*safari/i.test(ua);
  const isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
  const isAndroid = /android/i.test(ua);
  const isMobile2 = /Android|iPhone|iPad|iPod/i.test(ua) || "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  if (isMobile2 || isSafari2 || isIOS || isAndroid) {
    console.log(
      "Mobile/Safari/iOS/Android detected - FORCING canvas drawer (Research: WebGL regression in 5.0.0+)"
    );
    return "canvas";
  }
  if (isSafari2 && !isMobile2) {
    console.log("Desktop Safari detected - using canvas drawer (WebKit compatibility)");
    return "canvas";
  }
  const isChrome = /chrome|crios/i.test(ua) && !/edge|edg/i.test(ua);
  const isFirefox = /firefox|fxios/i.test(ua);
  if (isChrome || isFirefox) {
    console.log(
      "Desktop Chrome/Firefox detected - using canvas drawer (Research: Better tile performance)"
    );
    return "canvas";
  }
  console.log("Unknown browser detected - defaulting to canvas drawer");
  return "canvas";
};
const isMobile = () => {
  var _a;
  const userAgent = navigator.userAgent.toLowerCase();
  const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
  if (localStorage.getItem("forceDesktopMode") === "true") {
    console.log("[Mobile Detection] Desktop mode forced via localStorage");
    return false;
  }
  if (localStorage.getItem("forceMobileMode") === "true") {
    console.log("[Mobile Detection] Mobile mode forced via localStorage");
    return true;
  }
  const isDevToolsEmulation = window.navigator.userAgent.includes("Chrome") && window.navigator.userAgent.includes("Mobile") && window.innerWidth > 1024;
  if (isDevToolsEmulation) {
    console.log(
      "[Mobile Detection] Chrome DevTools mobile emulation detected - treating as DESKTOP"
    );
    return false;
  }
  if (mobileRegex.test(userAgent)) {
    return true;
  }
  if (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) {
    return true;
  }
  const hasTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;
  const isSmallScreen = window.innerWidth <= 768;
  const isMediumScreen = window.innerWidth <= 1024;
  if (hasTouch && isSmallScreen) {
    return true;
  }
  if (hasTouch && isMediumScreen && navigator.maxTouchPoints > 1) {
    if (window.innerHeight > 1200) {
      console.log(
        "[Mobile Detection] Large screen detected, treating as desktop despite touch"
      );
      return false;
    }
    return true;
  }
  const isMobileDevice = /mobi|tablet/i.test(userAgent) || ((_a = navigator.userAgentData) == null ? void 0 : _a.mobile);
  return isMobileDevice || false;
};
if (typeof window !== "undefined") {
  window.forceDesktopMode = () => {
    localStorage.setItem("forceDesktopMode", "true");
    localStorage.removeItem("overlayType");
    console.log("Desktop mode forced - reload page to apply");
    console.log("Use window.clearDeviceMode() to reset");
  };
  window.forceMobileMode = () => {
    localStorage.removeItem("forceDesktopMode");
    localStorage.setItem("forceMobileMode", "true");
    console.log("Mobile mode forced - reload page to apply");
    console.log("Use window.clearDeviceMode() to reset");
  };
  window.clearDeviceMode = () => {
    localStorage.removeItem("forceDesktopMode");
    localStorage.removeItem("forceMobileMode");
    localStorage.removeItem("overlayType");
    console.log("Device detection reset to automatic - reload page to apply");
  };
  window.checkDeviceDetection = () => {
    console.log("Current detection:", {
      isMobile: isMobile(),
      userAgent: navigator.userAgent,
      screenSize: `${window.innerWidth}x${window.innerHeight}`,
      touchPoints: navigator.maxTouchPoints,
      platform: navigator.platform,
      forcedMode: localStorage.getItem("forceDesktopMode") || localStorage.getItem("forceMobileMode") || "auto"
    });
  };
  console.log("Device detection commands available:");
  console.log("- window.forceDesktopMode()");
  console.log("- window.forceMobileMode()");
  console.log("- window.clearDeviceMode()");
  console.log("- window.checkDeviceDetection()");
}
const isIPhone = () => {
  const userAgent = navigator.userAgent;
  return /iPhone/.test(userAgent) && !/iPad/.test(userAgent);
};
var commonjsGlobal$2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var openseadragon = { exports: {} };
(function(module) {
  //! openseadragon 4.1.1
  //! Built on 2024-04-01
  //! Git commit: v4.1.1-0-f90d9814
  //! http://openseadragon.github.io
  //! License: http://openseadragon.github.io/license/
  function OpenSeadragon2(options) {
    return new OpenSeadragon2.Viewer(options);
  }
  (function($2) {
    $2.version = {
      versionStr: "4.1.1",
      major: parseInt("4", 10),
      minor: parseInt("1", 10),
      revision: parseInt("1", 10)
    };
    var class2type = {
      "[object Boolean]": "boolean",
      "[object Number]": "number",
      "[object String]": "string",
      "[object Function]": "function",
      "[object AsyncFunction]": "function",
      "[object Promise]": "promise",
      "[object Array]": "array",
      "[object Date]": "date",
      "[object RegExp]": "regexp",
      "[object Object]": "object"
    }, toString = Object.prototype.toString, hasOwn = Object.prototype.hasOwnProperty;
    $2.isFunction = function(obj) {
      return $2.type(obj) === "function";
    };
    $2.isArray = Array.isArray || function(obj) {
      return $2.type(obj) === "array";
    };
    $2.isWindow = function(obj) {
      return obj && typeof obj === "object" && "setInterval" in obj;
    };
    $2.type = function(obj) {
      return obj === null || obj === void 0 ? String(obj) : class2type[toString.call(obj)] || "object";
    };
    $2.isPlainObject = function(obj) {
      if (!obj || OpenSeadragon2.type(obj) !== "object" || obj.nodeType || $2.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      var lastKey;
      for (var key in obj) {
        lastKey = key;
      }
      return lastKey === void 0 || hasOwn.call(obj, lastKey);
    };
    $2.isEmptyObject = function(obj) {
      for (var name2 in obj) {
        return false;
      }
      return true;
    };
    $2.freezeObject = function(obj) {
      if (Object.freeze) {
        $2.freezeObject = Object.freeze;
      } else {
        $2.freezeObject = function(obj2) {
          return obj2;
        };
      }
      return $2.freezeObject(obj);
    };
    $2.supportsCanvas = function() {
      var canvasElement = document.createElement("canvas");
      return !!($2.isFunction(canvasElement.getContext) && canvasElement.getContext("2d"));
    }();
    $2.isCanvasTainted = function(canvas) {
      var isTainted = false;
      try {
        canvas.getContext("2d").getImageData(0, 0, 1, 1);
      } catch (e) {
        isTainted = true;
      }
      return isTainted;
    };
    $2.supportsAddEventListener = function() {
      return !!(document.documentElement.addEventListener && document.addEventListener);
    }();
    $2.supportsRemoveEventListener = function() {
      return !!(document.documentElement.removeEventListener && document.removeEventListener);
    }();
    $2.supportsEventListenerOptions = function() {
      var supported = 0;
      if ($2.supportsAddEventListener) {
        try {
          var options = {
            get capture() {
              supported++;
              return false;
            },
            get once() {
              supported++;
              return false;
            },
            get passive() {
              supported++;
              return false;
            }
          };
          window.addEventListener("test", null, options);
          window.removeEventListener("test", null, options);
        } catch (e) {
          supported = 0;
        }
      }
      return supported >= 3;
    }();
    $2.getCurrentPixelDensityRatio = function() {
      if ($2.supportsCanvas) {
        var context = document.createElement("canvas").getContext("2d");
        var devicePixelRatio = window.devicePixelRatio || 1;
        var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        return Math.max(devicePixelRatio, 1) / backingStoreRatio;
      } else {
        return 1;
      }
    };
    $2.pixelDensityRatio = $2.getCurrentPixelDensityRatio();
  })(OpenSeadragon2);
  (function($2) {
    $2.extend = function() {
      var options, name2, src, copy, copyIsArray, clone, target = arguments[0] || {}, length = arguments.length, deep = false, i = 1;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (typeof target !== "object" && !OpenSeadragon2.isFunction(target)) {
        target = {};
      }
      if (length === i) {
        target = this;
        --i;
      }
      for (; i < length; i++) {
        options = arguments[i];
        if (options !== null || options !== void 0) {
          for (name2 in options) {
            var descriptor = Object.getOwnPropertyDescriptor(options, name2);
            if (descriptor !== void 0) {
              if (descriptor.get || descriptor.set) {
                Object.defineProperty(target, name2, descriptor);
                continue;
              }
              copy = descriptor.value;
            } else {
              $2.console.warn('Could not copy inherited property "' + name2 + '".');
              continue;
            }
            if (target === copy) {
              continue;
            }
            if (deep && copy && (OpenSeadragon2.isPlainObject(copy) || (copyIsArray = OpenSeadragon2.isArray(copy)))) {
              src = target[name2];
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && OpenSeadragon2.isArray(src) ? src : [];
              } else {
                clone = src && OpenSeadragon2.isPlainObject(src) ? src : {};
              }
              target[name2] = OpenSeadragon2.extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target[name2] = copy;
            }
          }
        }
      }
      return target;
    };
    var isIOSDevice = function() {
      if (typeof navigator !== "object") {
        return false;
      }
      var userAgent = navigator.userAgent;
      if (typeof userAgent !== "string") {
        return false;
      }
      return userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1 || userAgent.indexOf("iPod") !== -1;
    };
    $2.extend(
      $2,
      /** @lends OpenSeadragon */
      {
        /**
         * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
         * @static
         * @type {Object}
         */
        DEFAULT_SETTINGS: {
          //DATA SOURCE DETAILS
          xmlPath: null,
          tileSources: null,
          tileHost: null,
          initialPage: 0,
          crossOriginPolicy: false,
          ajaxWithCredentials: false,
          loadTilesWithAjax: false,
          ajaxHeaders: {},
          splitHashDataForPost: false,
          //PAN AND ZOOM SETTINGS AND CONSTRAINTS
          panHorizontal: true,
          panVertical: true,
          constrainDuringPan: false,
          wrapHorizontal: false,
          wrapVertical: false,
          visibilityRatio: 0.5,
          //-> how much of the viewer can be negative space
          minPixelRatio: 0.5,
          //->closer to 0 draws tiles meant for a higher zoom at this zoom
          defaultZoomLevel: 0,
          minZoomLevel: null,
          maxZoomLevel: null,
          homeFillsViewer: false,
          //UI RESPONSIVENESS AND FEEL
          clickTimeThreshold: 300,
          clickDistThreshold: 5,
          dblClickTimeThreshold: 300,
          dblClickDistThreshold: 20,
          springStiffness: 6.5,
          animationTime: 1.2,
          gestureSettingsMouse: {
            dragToPan: true,
            scrollToZoom: true,
            clickToZoom: true,
            dblClickToZoom: false,
            dblClickDragToZoom: false,
            pinchToZoom: false,
            zoomToRefPoint: true,
            flickEnabled: false,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: false
          },
          gestureSettingsTouch: {
            dragToPan: true,
            scrollToZoom: false,
            clickToZoom: false,
            dblClickToZoom: true,
            dblClickDragToZoom: true,
            pinchToZoom: true,
            zoomToRefPoint: true,
            flickEnabled: true,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: false
          },
          gestureSettingsPen: {
            dragToPan: true,
            scrollToZoom: false,
            clickToZoom: true,
            dblClickToZoom: false,
            dblClickDragToZoom: false,
            pinchToZoom: false,
            zoomToRefPoint: true,
            flickEnabled: false,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: false
          },
          gestureSettingsUnknown: {
            dragToPan: true,
            scrollToZoom: false,
            clickToZoom: false,
            dblClickToZoom: true,
            dblClickDragToZoom: false,
            pinchToZoom: true,
            zoomToRefPoint: true,
            flickEnabled: true,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: false
          },
          zoomPerClick: 2,
          zoomPerScroll: 1.2,
          zoomPerDblClickDrag: 1.2,
          zoomPerSecond: 1,
          blendTime: 0,
          alwaysBlend: false,
          autoHideControls: true,
          immediateRender: false,
          minZoomImageRatio: 0.9,
          //-> closer to 0 allows zoom out to infinity
          maxZoomPixelRatio: 1.1,
          //-> higher allows 'over zoom' into pixels
          smoothTileEdgesMinZoom: 1.1,
          //-> higher than maxZoomPixelRatio disables it
          iOSDevice: isIOSDevice(),
          pixelsPerWheelLine: 40,
          pixelsPerArrowPress: 40,
          autoResize: true,
          preserveImageSizeOnResize: false,
          // requires autoResize=true
          minScrollDeltaTime: 50,
          rotationIncrement: 90,
          //DEFAULT CONTROL SETTINGS
          showSequenceControl: true,
          //SEQUENCE
          sequenceControlAnchor: null,
          //SEQUENCE
          preserveViewport: false,
          //SEQUENCE
          preserveOverlays: false,
          //SEQUENCE
          navPrevNextWrap: false,
          //SEQUENCE
          showNavigationControl: true,
          //ZOOM/HOME/FULL/ROTATION
          navigationControlAnchor: null,
          //ZOOM/HOME/FULL/ROTATION
          showZoomControl: true,
          //ZOOM
          showHomeControl: true,
          //HOME
          showFullPageControl: true,
          //FULL
          showRotationControl: false,
          //ROTATION
          showFlipControl: false,
          //FLIP
          controlsFadeDelay: 2e3,
          //ZOOM/HOME/FULL/SEQUENCE
          controlsFadeLength: 1500,
          //ZOOM/HOME/FULL/SEQUENCE
          mouseNavEnabled: true,
          //GENERAL MOUSE INTERACTIVITY
          //VIEWPORT NAVIGATOR SETTINGS
          showNavigator: false,
          navigatorElement: null,
          navigatorId: null,
          navigatorPosition: null,
          navigatorSizeRatio: 0.2,
          navigatorMaintainSizeRatio: false,
          navigatorTop: null,
          navigatorLeft: null,
          navigatorHeight: null,
          navigatorWidth: null,
          navigatorAutoResize: true,
          navigatorAutoFade: true,
          navigatorRotate: true,
          navigatorBackground: "#000",
          navigatorOpacity: 0.8,
          navigatorBorderColor: "#555",
          navigatorDisplayRegionColor: "#900",
          // INITIAL ROTATION
          degrees: 0,
          // INITIAL FLIP STATE
          flipped: false,
          // APPEARANCE
          opacity: 1,
          preload: false,
          compositeOperation: null,
          imageSmoothingEnabled: true,
          placeholderFillStyle: null,
          subPixelRoundingForTransparency: null,
          //REFERENCE STRIP SETTINGS
          showReferenceStrip: false,
          referenceStripScroll: "horizontal",
          referenceStripElement: null,
          referenceStripHeight: null,
          referenceStripWidth: null,
          referenceStripPosition: "BOTTOM_LEFT",
          referenceStripSizeRatio: 0.2,
          //COLLECTION VISUALIZATION SETTINGS
          collectionRows: 3,
          //or columns depending on layout
          collectionColumns: 0,
          //columns in horizontal layout, rows in vertical layout
          collectionLayout: "horizontal",
          //vertical
          collectionMode: false,
          collectionTileSize: 800,
          collectionTileMargin: 80,
          //PERFORMANCE SETTINGS
          imageLoaderLimit: 0,
          maxImageCacheCount: 200,
          timeout: 3e4,
          useCanvas: true,
          // Use canvas element for drawing if available
          tileRetryMax: 0,
          tileRetryDelay: 2500,
          //INTERFACE RESOURCE SETTINGS
          prefixUrl: "/images/",
          navImages: {
            zoomIn: {
              REST: "zoomin_rest.png",
              GROUP: "zoomin_grouphover.png",
              HOVER: "zoomin_hover.png",
              DOWN: "zoomin_pressed.png"
            },
            zoomOut: {
              REST: "zoomout_rest.png",
              GROUP: "zoomout_grouphover.png",
              HOVER: "zoomout_hover.png",
              DOWN: "zoomout_pressed.png"
            },
            home: {
              REST: "home_rest.png",
              GROUP: "home_grouphover.png",
              HOVER: "home_hover.png",
              DOWN: "home_pressed.png"
            },
            fullpage: {
              REST: "fullpage_rest.png",
              GROUP: "fullpage_grouphover.png",
              HOVER: "fullpage_hover.png",
              DOWN: "fullpage_pressed.png"
            },
            rotateleft: {
              REST: "rotateleft_rest.png",
              GROUP: "rotateleft_grouphover.png",
              HOVER: "rotateleft_hover.png",
              DOWN: "rotateleft_pressed.png"
            },
            rotateright: {
              REST: "rotateright_rest.png",
              GROUP: "rotateright_grouphover.png",
              HOVER: "rotateright_hover.png",
              DOWN: "rotateright_pressed.png"
            },
            flip: {
              // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
              REST: "flip_rest.png",
              GROUP: "flip_grouphover.png",
              HOVER: "flip_hover.png",
              DOWN: "flip_pressed.png"
            },
            previous: {
              REST: "previous_rest.png",
              GROUP: "previous_grouphover.png",
              HOVER: "previous_hover.png",
              DOWN: "previous_pressed.png"
            },
            next: {
              REST: "next_rest.png",
              GROUP: "next_grouphover.png",
              HOVER: "next_hover.png",
              DOWN: "next_pressed.png"
            }
          },
          //DEVELOPER SETTINGS
          debugMode: false,
          debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"],
          silenceMultiImageWarnings: false
        },
        /**
         * TODO: get rid of this.  I can't see how it's required at all.  Looks
         *       like an early legacy code artifact.
         * @static
         * @ignore
         */
        SIGNAL: "----seadragon----",
        /**
         * Returns a function which invokes the method as if it were a method belonging to the object.
         * @function
         * @param {Object} object
         * @param {Function} method
         * @returns {Function}
         */
        delegate: function(object, method) {
          return function() {
            var args = arguments;
            if (args === void 0) {
              args = [];
            }
            return method.apply(object, args);
          };
        },
        /**
         * An enumeration of Browser vendors.
         * @static
         * @type {Object}
         * @property {Number} UNKNOWN
         * @property {Number} IE
         * @property {Number} FIREFOX
         * @property {Number} SAFARI
         * @property {Number} CHROME
         * @property {Number} OPERA
         * @property {Number} EDGE
         * @property {Number} CHROMEEDGE
         */
        BROWSERS: {
          UNKNOWN: 0,
          IE: 1,
          FIREFOX: 2,
          SAFARI: 3,
          CHROME: 4,
          OPERA: 5,
          EDGE: 6,
          CHROMEEDGE: 7
        },
        /**
         * An enumeration of when subpixel rounding should occur.
         * @static
         * @type {Object}
         * @property {Number} NEVER Never apply subpixel rounding for transparency.
         * @property {Number} ONLY_AT_REST Do not apply subpixel rounding for transparency during animation (panning, zoom, rotation) and apply it once animation is over.
         * @property {Number} ALWAYS Apply subpixel rounding for transparency during animation and when animation is over.
         */
        SUBPIXEL_ROUNDING_OCCURRENCES: {
          NEVER: 0,
          ONLY_AT_REST: 1,
          ALWAYS: 2
        },
        /**
         * Keep track of which {@link Viewer}s have been created.
         * - Key: {@link Element} to which a Viewer is attached.
         * - Value: {@link Viewer} of the element defined by the key.
         * @private
         * @static
         * @type {Object}
         */
        _viewers: /* @__PURE__ */ new Map(),
        /**
          * Returns the {@link Viewer} attached to a given DOM element. If there is
          * no viewer attached to the provided element, undefined is returned.
          * @function
          * @param {String|Element} element Accepts an id or element.
          * @returns {Viewer} The viewer attached to the given element, or undefined.
          */
        getViewer: function(element) {
          return $2._viewers.get(this.getElement(element));
        },
        /**
         * Returns a DOM Element for the given id or element.
         * @function
         * @param {String|Element} element Accepts an id or element.
         * @returns {Element} The element with the given id, null, or the element itself.
         */
        getElement: function(element) {
          if (typeof element === "string") {
            element = document.getElementById(element);
          }
          return element;
        },
        /**
         * Determines the position of the upper-left corner of the element.
         * @function
         * @param {Element|String} element - the element we want the position for.
         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
         */
        getElementPosition: function(element) {
          var result = new $2.Point(), isFixed, offsetParent;
          element = $2.getElement(element);
          isFixed = $2.getElementStyle(element).position === "fixed";
          offsetParent = getOffsetParent(element, isFixed);
          while (offsetParent) {
            result.x += element.offsetLeft;
            result.y += element.offsetTop;
            if (isFixed) {
              result = result.plus($2.getPageScroll());
            }
            element = offsetParent;
            isFixed = $2.getElementStyle(element).position === "fixed";
            offsetParent = getOffsetParent(element, isFixed);
          }
          return result;
        },
        /**
         * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
         * @function
         * @param {Element|String} element - the element we want the position for.
         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
         */
        getElementOffset: function(element) {
          element = $2.getElement(element);
          var doc2 = element && element.ownerDocument, docElement, win, boundingRect = { top: 0, left: 0 };
          if (!doc2) {
            return new $2.Point();
          }
          docElement = doc2.documentElement;
          if (typeof element.getBoundingClientRect !== "undefined") {
            boundingRect = element.getBoundingClientRect();
          }
          win = doc2 === doc2.window ? doc2 : doc2.nodeType === 9 ? doc2.defaultView || doc2.parentWindow : false;
          return new $2.Point(
            boundingRect.left + (win.pageXOffset || docElement.scrollLeft) - (docElement.clientLeft || 0),
            boundingRect.top + (win.pageYOffset || docElement.scrollTop) - (docElement.clientTop || 0)
          );
        },
        /**
         * Determines the height and width of the given element.
         * @function
         * @param {Element|String} element
         * @returns {OpenSeadragon.Point}
         */
        getElementSize: function(element) {
          element = $2.getElement(element);
          return new $2.Point(
            element.clientWidth,
            element.clientHeight
          );
        },
        /**
         * Returns the CSSStyle object for the given element.
         * @function
         * @param {Element|String} element
         * @returns {CSSStyle}
         */
        getElementStyle: document.documentElement.currentStyle ? function(element) {
          element = $2.getElement(element);
          return element.currentStyle;
        } : function(element) {
          element = $2.getElement(element);
          return window.getComputedStyle(element, "");
        },
        /**
         * Returns the property with the correct vendor prefix appended.
         * @param {String} property the property name
         * @returns {String} the property with the correct prefix or null if not
         * supported.
         */
        getCssPropertyWithVendorPrefix: function(property2) {
          var memo2 = {};
          $2.getCssPropertyWithVendorPrefix = function(property3) {
            if (memo2[property3] !== void 0) {
              return memo2[property3];
            }
            var style2 = document.createElement("div").style;
            var result = null;
            if (style2[property3] !== void 0) {
              result = property3;
            } else {
              var prefixes = [
                "Webkit",
                "Moz",
                "MS",
                "O",
                "webkit",
                "moz",
                "ms",
                "o"
              ];
              var suffix = $2.capitalizeFirstLetter(property3);
              for (var i = 0; i < prefixes.length; i++) {
                var prop = prefixes[i] + suffix;
                if (style2[prop] !== void 0) {
                  result = prop;
                  break;
                }
              }
            }
            memo2[property3] = result;
            return result;
          };
          return $2.getCssPropertyWithVendorPrefix(property2);
        },
        /**
         * Capitalizes the first letter of a string
         * @param {String} string
         * @returns {String} The string with the first letter capitalized
         */
        capitalizeFirstLetter: function(string) {
          return string.charAt(0).toUpperCase() + string.slice(1);
        },
        /**
         * Compute the modulo of a number but makes sure to always return
         * a positive value (also known as Euclidean modulo).
         * @param {Number} number the number to compute the modulo of
         * @param {Number} modulo the modulo
         * @returns {Number} the result of the modulo of number
         */
        positiveModulo: function(number, modulo) {
          var result = number % modulo;
          if (result < 0) {
            result += modulo;
          }
          return result;
        },
        /**
         * Determines if a point is within the bounding rectangle of the given element (hit-test).
         * @function
         * @param {Element|String} element
         * @param {OpenSeadragon.Point} point
         * @returns {Boolean}
         */
        pointInElement: function(element, point) {
          element = $2.getElement(element);
          var offset = $2.getElementOffset(element), size = $2.getElementSize(element);
          return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;
        },
        /**
         * Gets the position of the mouse on the screen for a given event.
         * @function
         * @param {Event} [event]
         * @returns {OpenSeadragon.Point}
         */
        getMousePosition: function(event) {
          if (typeof event.pageX === "number") {
            $2.getMousePosition = function(event2) {
              var result = new $2.Point();
              result.x = event2.pageX;
              result.y = event2.pageY;
              return result;
            };
          } else if (typeof event.clientX === "number") {
            $2.getMousePosition = function(event2) {
              var result = new $2.Point();
              result.x = event2.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
              result.y = event2.clientY + document.body.scrollTop + document.documentElement.scrollTop;
              return result;
            };
          } else {
            throw new Error(
              "Unknown event mouse position, no known technique."
            );
          }
          return $2.getMousePosition(event);
        },
        /**
         * Determines the page's current scroll position.
         * @function
         * @returns {OpenSeadragon.Point}
         */
        getPageScroll: function() {
          var docElement = document.documentElement || {}, body = document.body || {};
          if (typeof window.pageXOffset === "number") {
            $2.getPageScroll = function() {
              return new $2.Point(
                window.pageXOffset,
                window.pageYOffset
              );
            };
          } else if (body.scrollLeft || body.scrollTop) {
            $2.getPageScroll = function() {
              return new $2.Point(
                document.body.scrollLeft,
                document.body.scrollTop
              );
            };
          } else if (docElement.scrollLeft || docElement.scrollTop) {
            $2.getPageScroll = function() {
              return new $2.Point(
                document.documentElement.scrollLeft,
                document.documentElement.scrollTop
              );
            };
          } else {
            return new $2.Point(0, 0);
          }
          return $2.getPageScroll();
        },
        /**
         * Set the page scroll position.
         * @function
         * @returns {OpenSeadragon.Point}
         */
        setPageScroll: function(scroll) {
          if (typeof window.scrollTo !== "undefined") {
            $2.setPageScroll = function(scroll2) {
              window.scrollTo(scroll2.x, scroll2.y);
            };
          } else {
            var originalScroll = $2.getPageScroll();
            if (originalScroll.x === scroll.x && originalScroll.y === scroll.y) {
              return;
            }
            document.body.scrollLeft = scroll.x;
            document.body.scrollTop = scroll.y;
            var currentScroll = $2.getPageScroll();
            if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
              $2.setPageScroll = function(scroll2) {
                document.body.scrollLeft = scroll2.x;
                document.body.scrollTop = scroll2.y;
              };
              return;
            }
            document.documentElement.scrollLeft = scroll.x;
            document.documentElement.scrollTop = scroll.y;
            currentScroll = $2.getPageScroll();
            if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
              $2.setPageScroll = function(scroll2) {
                document.documentElement.scrollLeft = scroll2.x;
                document.documentElement.scrollTop = scroll2.y;
              };
              return;
            }
            $2.setPageScroll = function(scroll2) {
            };
          }
          $2.setPageScroll(scroll);
        },
        /**
         * Determines the size of the browsers window.
         * @function
         * @returns {OpenSeadragon.Point}
         */
        getWindowSize: function() {
          var docElement = document.documentElement || {}, body = document.body || {};
          if (typeof window.innerWidth === "number") {
            $2.getWindowSize = function() {
              return new $2.Point(
                window.innerWidth,
                window.innerHeight
              );
            };
          } else if (docElement.clientWidth || docElement.clientHeight) {
            $2.getWindowSize = function() {
              return new $2.Point(
                document.documentElement.clientWidth,
                document.documentElement.clientHeight
              );
            };
          } else if (body.clientWidth || body.clientHeight) {
            $2.getWindowSize = function() {
              return new $2.Point(
                document.body.clientWidth,
                document.body.clientHeight
              );
            };
          } else {
            throw new Error("Unknown window size, no known technique.");
          }
          return $2.getWindowSize();
        },
        /**
         * Wraps the given element in a nest of divs so that the element can
         * be easily centered using CSS tables
         * @function
         * @param {Element|String} element
         * @returns {Element} outermost wrapper element
         */
        makeCenteredNode: function(element) {
          element = $2.getElement(element);
          var wrappers = [
            $2.makeNeutralElement("div"),
            $2.makeNeutralElement("div"),
            $2.makeNeutralElement("div")
          ];
          $2.extend(wrappers[0].style, {
            display: "table",
            height: "100%",
            width: "100%"
          });
          $2.extend(wrappers[1].style, {
            display: "table-row"
          });
          $2.extend(wrappers[2].style, {
            display: "table-cell",
            verticalAlign: "middle",
            textAlign: "center"
          });
          wrappers[0].appendChild(wrappers[1]);
          wrappers[1].appendChild(wrappers[2]);
          wrappers[2].appendChild(element);
          return wrappers[0];
        },
        /**
         * Creates an easily positionable element of the given type that therefor
         * serves as an excellent container element.
         * @function
         * @param {String} tagName
         * @returns {Element}
         */
        makeNeutralElement: function(tagName) {
          var element = document.createElement(tagName), style2 = element.style;
          style2.background = "transparent none";
          style2.border = "none";
          style2.margin = "0px";
          style2.padding = "0px";
          style2.position = "static";
          return element;
        },
        /**
         * Returns the current milliseconds, using Date.now() if available
         * @function
         */
        now: function() {
          if (Date.now) {
            $2.now = Date.now;
          } else {
            $2.now = function() {
              return (/* @__PURE__ */ new Date()).getTime();
            };
          }
          return $2.now();
        },
        /**
         * Ensures an image is loaded correctly to support alpha transparency.
         * @function
         * @param {String} src
         * @returns {Element}
         */
        makeTransparentImage: function(src) {
          var img = $2.makeNeutralElement("img");
          img.src = src;
          return img;
        },
        /**
         * Sets the opacity of the specified element.
         * @function
         * @param {Element|String} element
         * @param {Number} opacity
         * @param {Boolean} [usesAlpha]
         */
        setElementOpacity: function(element, opacity, usesAlpha) {
          var ieOpacity, ieFilter;
          element = $2.getElement(element);
          if (usesAlpha && !$2.Browser.alpha) {
            opacity = Math.round(opacity);
          }
          if ($2.Browser.opacity) {
            element.style.opacity = opacity < 1 ? opacity : "";
          } else {
            if (opacity < 1) {
              ieOpacity = Math.round(100 * opacity);
              ieFilter = "alpha(opacity=" + ieOpacity + ")";
              element.style.filter = ieFilter;
            } else {
              element.style.filter = "";
            }
          }
        },
        /**
         * Sets the specified element's touch-action style attribute to 'none'.
         * @function
         * @param {Element|String} element
         */
        setElementTouchActionNone: function(element) {
          element = $2.getElement(element);
          if (typeof element.style.touchAction !== "undefined") {
            element.style.touchAction = "none";
          } else if (typeof element.style.msTouchAction !== "undefined") {
            element.style.msTouchAction = "none";
          }
        },
        /**
         * Sets the specified element's pointer-events style attribute to the passed value.
         * @function
         * @param {Element|String} element
         * @param {String} value
         */
        setElementPointerEvents: function(element, value) {
          element = $2.getElement(element);
          if (typeof element.style !== "undefined" && typeof element.style.pointerEvents !== "undefined") {
            element.style.pointerEvents = value;
          }
        },
        /**
         * Sets the specified element's pointer-events style attribute to 'none'.
         * @function
         * @param {Element|String} element
         */
        setElementPointerEventsNone: function(element) {
          $2.setElementPointerEvents(element, "none");
        },
        /**
         * Add the specified CSS class to the element if not present.
         * @function
         * @param {Element|String} element
         * @param {String} className
         */
        addClass: function(element, className2) {
          element = $2.getElement(element);
          if (!element.className) {
            element.className = className2;
          } else if ((" " + element.className + " ").indexOf(" " + className2 + " ") === -1) {
            element.className += " " + className2;
          }
        },
        /**
         * Find the first index at which an element is found in an array or -1
         * if not present.
         *
         * Code taken and adapted from
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
         *
         * @function
         * @param {Array} array The array from which to find the element
         * @param {Object} searchElement The element to find
         * @param {Number} [fromIndex=0] Index to start research.
         * @returns {Number} The index of the element in the array.
         */
        indexOf: function(array, searchElement, fromIndex) {
          if (Array.prototype.indexOf) {
            this.indexOf = function(array2, searchElement2, fromIndex2) {
              return array2.indexOf(searchElement2, fromIndex2);
            };
          } else {
            this.indexOf = function(array2, searchElement2, fromIndex2) {
              var i, pivot = fromIndex2 ? fromIndex2 : 0, length;
              if (!array2) {
                throw new TypeError();
              }
              length = array2.length;
              if (length === 0 || pivot >= length) {
                return -1;
              }
              if (pivot < 0) {
                pivot = length - Math.abs(pivot);
              }
              for (i = pivot; i < length; i++) {
                if (array2[i] === searchElement2) {
                  return i;
                }
              }
              return -1;
            };
          }
          return this.indexOf(array, searchElement, fromIndex);
        },
        /**
         * Remove the specified CSS class from the element.
         * @function
         * @param {Element|String} element
         * @param {String} className
         */
        removeClass: function(element, className2) {
          var oldClasses, newClasses = [], i;
          element = $2.getElement(element);
          oldClasses = element.className.split(/\s+/);
          for (i = 0; i < oldClasses.length; i++) {
            if (oldClasses[i] && oldClasses[i] !== className2) {
              newClasses.push(oldClasses[i]);
            }
          }
          element.className = newClasses.join(" ");
        },
        /**
         * Convert passed addEventListener() options to boolean or options object,
         * depending on browser support.
         * @function
         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
         * @param {Boolean} [options.capture]
         * @param {Boolean} [options.passive]
         * @param {Boolean} [options.once]
         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
         */
        normalizeEventListenerOptions: function(options) {
          var opts;
          if (typeof options !== "undefined") {
            if (typeof options === "boolean") {
              opts = $2.supportsEventListenerOptions ? { capture: options } : options;
            } else {
              opts = $2.supportsEventListenerOptions ? options : typeof options.capture !== "undefined" ? options.capture : false;
            }
          } else {
            opts = $2.supportsEventListenerOptions ? { capture: false } : false;
          }
          return opts;
        },
        /**
         * Adds an event listener for the given element, eventName and handler.
         * @function
         * @param {Element|String} element
         * @param {String} eventName
         * @param {Function} handler
         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
         * @param {Boolean} [options.capture]
         * @param {Boolean} [options.passive]
         * @param {Boolean} [options.once]
         */
        addEvent: function() {
          if ($2.supportsAddEventListener) {
            return function(element, eventName, handler, options) {
              options = $2.normalizeEventListenerOptions(options);
              element = $2.getElement(element);
              element.addEventListener(eventName, handler, options);
            };
          } else if (document.documentElement.attachEvent && document.attachEvent) {
            return function(element, eventName, handler) {
              element = $2.getElement(element);
              element.attachEvent("on" + eventName, handler);
            };
          } else {
            throw new Error("No known event model.");
          }
        }(),
        /**
         * Remove a given event listener for the given element, event type and
         * handler.
         * @function
         * @param {Element|String} element
         * @param {String} eventName
         * @param {Function} handler
         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
         * @param {Boolean} [options.capture]
         */
        removeEvent: function() {
          if ($2.supportsRemoveEventListener) {
            return function(element, eventName, handler, options) {
              options = $2.normalizeEventListenerOptions(options);
              element = $2.getElement(element);
              element.removeEventListener(eventName, handler, options);
            };
          } else if (document.documentElement.detachEvent && document.detachEvent) {
            return function(element, eventName, handler) {
              element = $2.getElement(element);
              element.detachEvent("on" + eventName, handler);
            };
          } else {
            throw new Error("No known event model.");
          }
        }(),
        /**
         * Cancels the default browser behavior had the event propagated all
         * the way up the DOM to the window object.
         * @function
         * @param {Event} [event]
         */
        cancelEvent: function(event) {
          event.preventDefault();
        },
        /**
         * Returns true if {@link OpenSeadragon.cancelEvent|cancelEvent} has been called on
         * the event, otherwise returns false.
         * @function
         * @param {Event} [event]
         */
        eventIsCanceled: function(event) {
          return event.defaultPrevented;
        },
        /**
         * Stops the propagation of the event through the DOM in the capturing and bubbling phases.
         * @function
         * @param {Event} [event]
         */
        stopEvent: function(event) {
          event.stopPropagation();
        },
        /**
         * Similar to OpenSeadragon.delegate, but it does not immediately call
         * the method on the object, returning a function which can be called
         * repeatedly to delegate the method. It also allows additional arguments
         * to be passed during construction which will be added during each
         * invocation, and each invocation can add additional arguments as well.
         *
         * @function
         * @param {Object} object
         * @param {Function} method
         * @param [args] any additional arguments are passed as arguments to the
         *  created callback
         * @returns {Function}
         */
        createCallback: function(object, method) {
          var initialArgs = [], i;
          for (i = 2; i < arguments.length; i++) {
            initialArgs.push(arguments[i]);
          }
          return function() {
            var args = initialArgs.concat([]), i2;
            for (i2 = 0; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
            }
            return method.apply(object, args);
          };
        },
        /**
         * Retrieves the value of a url parameter from the window.location string.
         * @function
         * @param {String} key
         * @returns {String} The value of the url parameter or null if no param matches.
         */
        getUrlParameter: function(key) {
          var value = URLPARAMS[key];
          return value ? value : null;
        },
        /**
         * Retrieves the protocol used by the url. The url can either be absolute
         * or relative.
         * @function
         * @private
         * @param {String} url The url to retrieve the protocol from.
         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
         */
        getUrlProtocol: function(url) {
          var match = url.match(/^([a-z]+:)\/\//i);
          if (match === null) {
            return window.location.protocol;
          }
          return match[1].toLowerCase();
        },
        /**
         * Create an XHR object
         * @private
         * @param {type} [local] If set to true, the XHR will be file: protocol
         * compatible if possible (but may raise a warning in the browser).
         * @returns {XMLHttpRequest}
         */
        createAjaxRequest: function(local) {
          var supportActiveX;
          try {
            supportActiveX = !!new ActiveXObject("Microsoft.XMLHTTP");
          } catch (e) {
            supportActiveX = false;
          }
          if (supportActiveX) {
            if (window.XMLHttpRequest) {
              $2.createAjaxRequest = function(local2) {
                if (local2) {
                  return new ActiveXObject("Microsoft.XMLHTTP");
                }
                return new XMLHttpRequest();
              };
            } else {
              $2.createAjaxRequest = function() {
                return new ActiveXObject("Microsoft.XMLHTTP");
              };
            }
          } else if (window.XMLHttpRequest) {
            $2.createAjaxRequest = function() {
              return new XMLHttpRequest();
            };
          } else {
            throw new Error("Browser doesn't support XMLHttpRequest.");
          }
          return $2.createAjaxRequest(local);
        },
        /**
         * Makes an AJAX request.
         * @param {Object} options
         * @param {String} options.url - the url to request
         * @param {Function} options.success - a function to call on a successful response
         * @param {Function} options.error - a function to call on when an error occurs
         * @param {Object} options.headers - headers to add to the AJAX request
         * @param {String} options.responseType - the response type of the AJAX request
         * @param {String} options.postData - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
         *      see TileSource::getPostData), GET method used if null
         * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
         * @throws {Error}
         * @returns {XMLHttpRequest}
         */
        makeAjaxRequest: function(url, onSuccess, onError) {
          var withCredentials;
          var headers;
          var responseType;
          var postData;
          if ($2.isPlainObject(url)) {
            onSuccess = url.success;
            onError = url.error;
            withCredentials = url.withCredentials;
            headers = url.headers;
            responseType = url.responseType || null;
            postData = url.postData || null;
            url = url.url;
          }
          var protocol = $2.getUrlProtocol(url);
          var request = $2.createAjaxRequest(protocol === "file:");
          if (!$2.isFunction(onSuccess)) {
            throw new Error("makeAjaxRequest requires a success callback");
          }
          request.onreadystatechange = function() {
            if (request.readyState === 4) {
              request.onreadystatechange = function() {
              };
              if (request.status >= 200 && request.status < 300 || request.status === 0 && protocol !== "http:" && protocol !== "https:") {
                onSuccess(request);
              } else {
                if ($2.isFunction(onError)) {
                  onError(request);
                } else {
                  $2.console.error("AJAX request returned %d: %s", request.status, url);
                }
              }
            }
          };
          var method = postData ? "POST" : "GET";
          try {
            request.open(method, url, true);
            if (responseType) {
              request.responseType = responseType;
            }
            if (headers) {
              for (var headerName in headers) {
                if (Object.prototype.hasOwnProperty.call(headers, headerName) && headers[headerName]) {
                  request.setRequestHeader(headerName, headers[headerName]);
                }
              }
            }
            if (withCredentials) {
              request.withCredentials = true;
            }
            request.send(postData);
          } catch (e) {
            $2.console.error("%s while making AJAX request: %s", e.name, e.message);
            request.onreadystatechange = function() {
            };
            if ($2.isFunction(onError)) {
              onError(request, e);
            }
          }
          return request;
        },
        /**
         * Taken from jQuery 1.6.1
         * @function
         * @param {Object} options
         * @param {String} options.url
         * @param {Function} options.callback
         * @param {String} [options.param='callback'] The name of the url parameter
         *      to request the jsonp provider with.
         * @param {String} [options.callbackName=] The name of the callback to
         *      request the jsonp provider with.
         */
        jsonp: function(options) {
          var script, url = options.url, head = document.head || document.getElementsByTagName("head")[0] || document.documentElement, jsonpCallback = options.callbackName || "openseadragon" + $2.now(), previous = window[jsonpCallback], replace = "$1" + jsonpCallback + "$2", callbackParam = options.param || "callback", callback = options.callback;
          url = url.replace(/(=)\?(&|$)|\?\?/i, replace);
          url += (/\?/.test(url) ? "&" : "?") + callbackParam + "=" + jsonpCallback;
          window[jsonpCallback] = function(response) {
            if (!previous) {
              try {
                delete window[jsonpCallback];
              } catch (e) {
              }
            } else {
              window[jsonpCallback] = previous;
            }
            if (callback && $2.isFunction(callback)) {
              callback(response);
            }
          };
          script = document.createElement("script");
          if (void 0 !== options.async || false !== options.async) {
            script.async = "async";
          }
          if (options.scriptCharset) {
            script.charset = options.scriptCharset;
          }
          script.src = url;
          script.onload = script.onreadystatechange = function(_, isAbort) {
            if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
              script.onload = script.onreadystatechange = null;
              if (head && script.parentNode) {
                head.removeChild(script);
              }
              script = void 0;
            }
          };
          head.insertBefore(script, head.firstChild);
        },
        /**
         * Fully deprecated. Will throw an error.
         * @function
         * @deprecated use {@link OpenSeadragon.Viewer#open}
         */
        createFromDZI: function() {
          throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
        },
        /**
         * Parses an XML string into a DOM Document.
         * @function
         * @param {String} string
         * @returns {Document}
         */
        parseXml: function(string) {
          if (window.DOMParser) {
            $2.parseXml = function(string2) {
              var xmlDoc = null, parser;
              parser = new DOMParser();
              xmlDoc = parser.parseFromString(string2, "text/xml");
              return xmlDoc;
            };
          } else if (window.ActiveXObject) {
            $2.parseXml = function(string2) {
              var xmlDoc = null;
              xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
              xmlDoc.async = false;
              xmlDoc.loadXML(string2);
              return xmlDoc;
            };
          } else {
            throw new Error("Browser doesn't support XML DOM.");
          }
          return $2.parseXml(string);
        },
        /**
         * Parses a JSON string into a Javascript object.
         * @function
         * @param {String} string
         * @returns {Object}
         */
        parseJSON: function(string) {
          $2.parseJSON = window.JSON.parse;
          return $2.parseJSON(string);
        },
        /**
         * Reports whether the image format is supported for tiling in this
         * version.
         * @function
         * @param {String} [extension]
         * @returns {Boolean}
         */
        imageFormatSupported: function(extension) {
          extension = extension ? extension : "";
          return !!FILEFORMATS[extension.toLowerCase()];
        },
        /**
         * Updates supported image formats with user-specified values.
         * Preexisting formats that are not being updated are left unchanged.
         * By default, the defined formats are
         * <pre><code>{
         *      bmp:  false,
         *      jpeg: true,
         *      jpg:  true,
         *      png:  true,
         *      tif:  false,
         *      wdp:  false
         * }
         * </code></pre>
         * @function
         * @example
         * // sets webp as supported and png as unsupported
         * setImageFormatsSupported({webp: true, png: false});
         * @param {Object} formats An object containing format extensions as
         * keys and booleans as values.
         */
        setImageFormatsSupported: function(formats) {
          $2.extend(FILEFORMATS, formats);
        }
      }
    );
    var nullfunction = function(msg) {
    };
    $2.console = window.console || {
      log: nullfunction,
      debug: nullfunction,
      info: nullfunction,
      warn: nullfunction,
      error: nullfunction,
      assert: nullfunction
    };
    $2.Browser = {
      vendor: $2.BROWSERS.UNKNOWN,
      version: 0,
      alpha: true
    };
    var FILEFORMATS = {
      bmp: false,
      jpeg: true,
      jpg: true,
      png: true,
      tif: false,
      wdp: false
    }, URLPARAMS = {};
    (function() {
      var ver = navigator.appVersion, ua = navigator.userAgent, regex;
      switch (navigator.appName) {
        case "Microsoft Internet Explorer":
          if (!!window.attachEvent && !!window.ActiveXObject) {
            $2.Browser.vendor = $2.BROWSERS.IE;
            $2.Browser.version = parseFloat(
              ua.substring(
                ua.indexOf("MSIE") + 5,
                ua.indexOf(";", ua.indexOf("MSIE"))
              )
            );
          }
          break;
        case "Netscape":
          if (window.addEventListener) {
            if (ua.indexOf("Edge") >= 0) {
              $2.Browser.vendor = $2.BROWSERS.EDGE;
              $2.Browser.version = parseFloat(
                ua.substring(ua.indexOf("Edge") + 5)
              );
            } else if (ua.indexOf("Edg") >= 0) {
              $2.Browser.vendor = $2.BROWSERS.CHROMEEDGE;
              $2.Browser.version = parseFloat(
                ua.substring(ua.indexOf("Edg") + 4)
              );
            } else if (ua.indexOf("Firefox") >= 0) {
              $2.Browser.vendor = $2.BROWSERS.FIREFOX;
              $2.Browser.version = parseFloat(
                ua.substring(ua.indexOf("Firefox") + 8)
              );
            } else if (ua.indexOf("Safari") >= 0) {
              $2.Browser.vendor = ua.indexOf("Chrome") >= 0 ? $2.BROWSERS.CHROME : $2.BROWSERS.SAFARI;
              $2.Browser.version = parseFloat(
                ua.substring(
                  ua.substring(0, ua.indexOf("Safari")).lastIndexOf("/") + 1,
                  ua.indexOf("Safari")
                )
              );
            } else {
              regex = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
              if (regex.exec(ua) !== null) {
                $2.Browser.vendor = $2.BROWSERS.IE;
                $2.Browser.version = parseFloat(RegExp.$1);
              }
            }
          }
          break;
        case "Opera":
          $2.Browser.vendor = $2.BROWSERS.OPERA;
          $2.Browser.version = parseFloat(ver);
          break;
      }
      var query2 = window.location.search.substring(1), parts = query2.split("&"), part, sep, i;
      for (i = 0; i < parts.length; i++) {
        part = parts[i];
        sep = part.indexOf("=");
        if (sep > 0) {
          var key = part.substring(0, sep), value = part.substring(sep + 1);
          try {
            URLPARAMS[key] = decodeURIComponent(value);
          } catch (e) {
            $2.console.error("Ignoring malformed URL parameter: %s=%s", key, value);
          }
        }
      }
      $2.Browser.alpha = !($2.Browser.vendor === $2.BROWSERS.CHROME && $2.Browser.version < 2);
      $2.Browser.opacity = true;
      if ($2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version < 11) {
        $2.console.error("Internet Explorer versions < 11 are not supported by OpenSeadragon");
      }
    })();
    (function(w) {
      var requestAnimationFrame2 = w.requestAnimationFrame || w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame;
      var cancelAnimationFrame2 = w.cancelAnimationFrame || w.mozCancelAnimationFrame || w.webkitCancelAnimationFrame || w.msCancelAnimationFrame;
      if (requestAnimationFrame2 && cancelAnimationFrame2) {
        $2.requestAnimationFrame = function() {
          return requestAnimationFrame2.apply(w, arguments);
        };
        $2.cancelAnimationFrame = function() {
          return cancelAnimationFrame2.apply(w, arguments);
        };
      } else {
        var aAnimQueue = [], processing = [], iRequestId = 0, iIntervalId;
        $2.requestAnimationFrame = function(callback) {
          aAnimQueue.push([++iRequestId, callback]);
          if (!iIntervalId) {
            iIntervalId = setInterval(function() {
              if (aAnimQueue.length) {
                var time = $2.now();
                var temp = processing;
                processing = aAnimQueue;
                aAnimQueue = temp;
                while (processing.length) {
                  processing.shift()[1](time);
                }
              } else {
                clearInterval(iIntervalId);
                iIntervalId = void 0;
              }
            }, 1e3 / 50);
          }
          return iRequestId;
        };
        $2.cancelAnimationFrame = function(requestId) {
          var i, j;
          for (i = 0, j = aAnimQueue.length; i < j; i += 1) {
            if (aAnimQueue[i][0] === requestId) {
              aAnimQueue.splice(i, 1);
              return;
            }
          }
          for (i = 0, j = processing.length; i < j; i += 1) {
            if (processing[i][0] === requestId) {
              processing.splice(i, 1);
              return;
            }
          }
        };
      }
    })(window);
    function getOffsetParent(element, isFixed) {
      if (isFixed && element !== document.body) {
        return document.body;
      } else {
        return element.offsetParent;
      }
    }
  })(OpenSeadragon2);
  (function(root2, factory) {
    if (module.exports) {
      module.exports = factory();
    } else {
      root2.OpenSeadragon = factory();
    }
  })(commonjsGlobal$2, function() {
    return OpenSeadragon2;
  });
  (function($2) {
    var fullScreenApi = {
      supportsFullScreen: false,
      isFullScreen: function() {
        return false;
      },
      getFullScreenElement: function() {
        return null;
      },
      requestFullScreen: function() {
      },
      exitFullScreen: function() {
      },
      cancelFullScreen: function() {
      },
      fullScreenEventName: "",
      fullScreenErrorEventName: ""
    };
    if (document.exitFullscreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.fullscreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.requestFullscreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.exitFullscreen();
      };
      fullScreenApi.fullScreenEventName = "fullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
    } else if (document.msExitFullscreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.msFullscreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.msRequestFullscreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.msExitFullscreen();
      };
      fullScreenApi.fullScreenEventName = "MSFullscreenChange";
      fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
    } else if (document.webkitExitFullscreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.webkitFullscreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.webkitRequestFullscreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.webkitExitFullscreen();
      };
      fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
    } else if (document.webkitCancelFullScreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.webkitCurrentFullScreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.webkitRequestFullScreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.webkitCancelFullScreen();
      };
      fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
    } else if (document.mozCancelFullScreen) {
      fullScreenApi.supportsFullScreen = true;
      fullScreenApi.getFullScreenElement = function() {
        return document.mozFullScreenElement;
      };
      fullScreenApi.requestFullScreen = function(element) {
        return element.mozRequestFullScreen();
      };
      fullScreenApi.exitFullScreen = function() {
        document.mozCancelFullScreen();
      };
      fullScreenApi.fullScreenEventName = "mozfullscreenchange";
      fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
    }
    fullScreenApi.isFullScreen = function() {
      return fullScreenApi.getFullScreenElement() !== null;
    };
    fullScreenApi.cancelFullScreen = function() {
      $2.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
      fullScreenApi.exitFullScreen();
    };
    $2.extend($2, fullScreenApi);
  })(OpenSeadragon2);
  (function($2) {
    $2.EventSource = function() {
      this.events = {};
    };
    $2.EventSource.prototype = {
      /**
       * Add an event handler to be triggered only once (or a given number of times)
       * for a given event. It is not removable with removeHandler().
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {OpenSeadragon.EventHandler} handler - Function to call when event
       * is triggered.
       * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
       * to the handler.
       * @param {Number} [times=1] - The number of times to handle the event
       * before removing it.
       * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
       */
      addOnceHandler: function(eventName, handler, userData, times, priority) {
        var self2 = this;
        times = times || 1;
        var count = 0;
        var onceHandler = function(event) {
          count++;
          if (count === times) {
            self2.removeHandler(eventName, onceHandler);
          }
          return handler(event);
        };
        this.addHandler(eventName, onceHandler, userData, priority);
      },
      /**
       * Add an event handler for a given event.
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
       * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
       * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
       */
      addHandler: function(eventName, handler, userData, priority) {
        var events = this.events[eventName];
        if (!events) {
          this.events[eventName] = events = [];
        }
        if (handler && $2.isFunction(handler)) {
          var index = events.length, event = { handler, userData: userData || null, priority: priority || 0 };
          events[index] = event;
          while (index > 0 && events[index - 1].priority < events[index].priority) {
            events[index] = events[index - 1];
            events[index - 1] = event;
            index--;
          }
        }
      },
      /**
       * Remove a specific event handler for a given event.
       * @function
       * @param {String} eventName - Name of event for which the handler is to be removed.
       * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
       */
      removeHandler: function(eventName, handler) {
        var events = this.events[eventName], handlers = [], i;
        if (!events) {
          return;
        }
        if ($2.isArray(events)) {
          for (i = 0; i < events.length; i++) {
            if (events[i].handler !== handler) {
              handlers.push(events[i]);
            }
          }
          this.events[eventName] = handlers;
        }
      },
      /**
       * Get the amount of handlers registered for a given event.
       * @param {String} eventName - Name of event to inspect.
       * @returns {number} amount of events
       */
      numberOfHandlers: function(eventName) {
        var events = this.events[eventName];
        if (!events) {
          return 0;
        }
        return events.length;
      },
      /**
       * Remove all event handlers for a given event type. If no type is given all
       * event handlers for every event type are removed.
       * @function
       * @param {String} eventName - Name of event for which all handlers are to be removed.
       */
      removeAllHandlers: function(eventName) {
        if (eventName) {
          this.events[eventName] = [];
        } else {
          for (var eventType in this.events) {
            this.events[eventType] = [];
          }
        }
      },
      /**
       * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
       * @function
       * @param {String} eventName - Name of event to get handlers for.
       */
      getHandler: function(eventName) {
        var events = this.events[eventName];
        if (!events || !events.length) {
          return null;
        }
        events = events.length === 1 ? [events[0]] : Array.apply(null, events);
        return function(source, args) {
          var i, length = events.length;
          for (i = 0; i < length; i++) {
            if (events[i]) {
              args.eventSource = source;
              args.userData = events[i].userData;
              events[i].handler(args);
            }
          }
        };
      },
      /**
       * Trigger an event, optionally passing additional information.
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {Object} eventArgs - Event-specific data.
       */
      raiseEvent: function(eventName, eventArgs) {
        var handler = this.getHandler(eventName);
        if (handler) {
          return handler(this, eventArgs || {});
        }
        return void 0;
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    var THIS = {};
    $2.MouseTracker = function(options) {
      var args = arguments;
      if (!$2.isPlainObject(options)) {
        options = {
          element: args[0],
          clickTimeThreshold: args[1],
          clickDistThreshold: args[2]
        };
      }
      this.hash = Math.random();
      this.element = $2.getElement(options.element);
      this.clickTimeThreshold = options.clickTimeThreshold || $2.DEFAULT_SETTINGS.clickTimeThreshold;
      this.clickDistThreshold = options.clickDistThreshold || $2.DEFAULT_SETTINGS.clickDistThreshold;
      this.dblClickTimeThreshold = options.dblClickTimeThreshold || $2.DEFAULT_SETTINGS.dblClickTimeThreshold;
      this.dblClickDistThreshold = options.dblClickDistThreshold || $2.DEFAULT_SETTINGS.dblClickDistThreshold;
      this.userData = options.userData || null;
      this.stopDelay = options.stopDelay || 50;
      this.preProcessEventHandler = options.preProcessEventHandler || null;
      this.contextMenuHandler = options.contextMenuHandler || null;
      this.enterHandler = options.enterHandler || null;
      this.leaveHandler = options.leaveHandler || null;
      this.exitHandler = options.exitHandler || null;
      this.overHandler = options.overHandler || null;
      this.outHandler = options.outHandler || null;
      this.pressHandler = options.pressHandler || null;
      this.nonPrimaryPressHandler = options.nonPrimaryPressHandler || null;
      this.releaseHandler = options.releaseHandler || null;
      this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
      this.moveHandler = options.moveHandler || null;
      this.scrollHandler = options.scrollHandler || null;
      this.clickHandler = options.clickHandler || null;
      this.dblClickHandler = options.dblClickHandler || null;
      this.dragHandler = options.dragHandler || null;
      this.dragEndHandler = options.dragEndHandler || null;
      this.pinchHandler = options.pinchHandler || null;
      this.stopHandler = options.stopHandler || null;
      this.keyDownHandler = options.keyDownHandler || null;
      this.keyUpHandler = options.keyUpHandler || null;
      this.keyHandler = options.keyHandler || null;
      this.focusHandler = options.focusHandler || null;
      this.blurHandler = options.blurHandler || null;
      var _this = this;
      THIS[this.hash] = {
        click: function(event) {
          onClick(_this, event);
        },
        dblclick: function(event) {
          onDblClick(_this, event);
        },
        keydown: function(event) {
          onKeyDown(_this, event);
        },
        keyup: function(event) {
          onKeyUp(_this, event);
        },
        keypress: function(event) {
          onKeyPress(_this, event);
        },
        focus: function(event) {
          onFocus(_this, event);
        },
        blur: function(event) {
          onBlur(_this, event);
        },
        contextmenu: function(event) {
          onContextMenu(_this, event);
        },
        wheel: function(event) {
          onWheel(_this, event);
        },
        mousewheel: function(event) {
          onMouseWheel(_this, event);
        },
        DOMMouseScroll: function(event) {
          onMouseWheel(_this, event);
        },
        MozMousePixelScroll: function(event) {
          onMouseWheel(_this, event);
        },
        losecapture: function(event) {
          onLoseCapture(_this, event);
        },
        mouseenter: function(event) {
          onPointerEnter(_this, event);
        },
        mouseleave: function(event) {
          onPointerLeave(_this, event);
        },
        mouseover: function(event) {
          onPointerOver(_this, event);
        },
        mouseout: function(event) {
          onPointerOut(_this, event);
        },
        mousedown: function(event) {
          onPointerDown(_this, event);
        },
        mouseup: function(event) {
          onPointerUp(_this, event);
        },
        mousemove: function(event) {
          onPointerMove(_this, event);
        },
        touchstart: function(event) {
          onTouchStart(_this, event);
        },
        touchend: function(event) {
          onTouchEnd(_this, event);
        },
        touchmove: function(event) {
          onTouchMove(_this, event);
        },
        touchcancel: function(event) {
          onTouchCancel(_this, event);
        },
        gesturestart: function(event) {
          onGestureStart(_this, event);
        },
        // Safari/Safari iOS
        gesturechange: function(event) {
          onGestureChange(_this, event);
        },
        // Safari/Safari iOS
        gotpointercapture: function(event) {
          onGotPointerCapture(_this, event);
        },
        lostpointercapture: function(event) {
          onLostPointerCapture(_this, event);
        },
        pointerenter: function(event) {
          onPointerEnter(_this, event);
        },
        pointerleave: function(event) {
          onPointerLeave(_this, event);
        },
        pointerover: function(event) {
          onPointerOver(_this, event);
        },
        pointerout: function(event) {
          onPointerOut(_this, event);
        },
        pointerdown: function(event) {
          onPointerDown(_this, event);
        },
        pointerup: function(event) {
          onPointerUp(_this, event);
        },
        pointermove: function(event) {
          onPointerMove(_this, event);
        },
        pointercancel: function(event) {
          onPointerCancel(_this, event);
        },
        pointerupcaptured: function(event) {
          onPointerUpCaptured(_this, event);
        },
        pointermovecaptured: function(event) {
          onPointerMoveCaptured(_this, event);
        },
        tracking: false,
        // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
        // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
        // Active pointers are any pointer being tracked for this element which are in the hit-test area
        //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
        activePointersLists: [],
        // Tracking for double-click gesture
        lastClickPos: null,
        dblClickTimeOut: null,
        // Tracking for pinch gesture
        pinchGPoints: [],
        lastPinchDist: 0,
        currentPinchDist: 0,
        lastPinchCenter: null,
        currentPinchCenter: null,
        // Tracking for drag
        sentDragEvent: false
      };
      this.hasGestureHandlers = !!(this.pressHandler || this.nonPrimaryPressHandler || this.releaseHandler || this.nonPrimaryReleaseHandler || this.clickHandler || this.dblClickHandler || this.dragHandler || this.dragEndHandler || this.pinchHandler);
      this.hasScrollHandler = !!this.scrollHandler;
      if ($2.MouseTracker.havePointerEvents) {
        $2.setElementPointerEvents(this.element, "auto");
      }
      if (this.exitHandler) {
        $2.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead.");
      }
      if (!options.startDisabled) {
        this.setTracking(true);
      }
    };
    $2.MouseTracker.prototype = {
      /**
       * Clean up any events or objects created by the tracker.
       * @function
       */
      destroy: function() {
        stopTracking(this);
        this.element = null;
        THIS[this.hash] = null;
        delete THIS[this.hash];
      },
      /**
       * Are we currently tracking events on this element.
       * @deprecated Just use this.tracking
       * @function
       * @returns {Boolean} Are we currently tracking events on this element.
       */
      isTracking: function() {
        return THIS[this.hash].tracking;
      },
      /**
       * Enable or disable whether or not we are tracking events on this element.
       * @function
       * @param {Boolean} track True to start tracking, false to stop tracking.
       * @returns {OpenSeadragon.MouseTracker} Chainable.
       */
      setTracking: function(track) {
        if (track) {
          startTracking(this);
        } else {
          stopTracking(this);
        }
        return this;
      },
      /**
       * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
       * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
       * @function
       * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
       * @returns {OpenSeadragon.MouseTracker.GesturePointList}
       */
      getActivePointersListByType: function(type) {
        var delegate = THIS[this.hash], i, len = delegate.activePointersLists.length, list;
        for (i = 0; i < len; i++) {
          if (delegate.activePointersLists[i].type === type) {
            return delegate.activePointersLists[i];
          }
        }
        list = new $2.MouseTracker.GesturePointList(type);
        delegate.activePointersLists.push(list);
        return list;
      },
      /**
       * Returns the total number of pointers currently active on the tracked element.
       * @function
       * @returns {Number}
       */
      getActivePointerCount: function() {
        var delegate = THIS[this.hash], i, len = delegate.activePointersLists.length, count = 0;
        for (i = 0; i < len; i++) {
          count += delegate.activePointersLists[i].getLength();
        }
        return count;
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
       */
      preProcessEventHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the contextmenu event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      contextMenuHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      enterHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @since v2.5.0
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      leaveHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @deprecated v2.5.0 Use leaveHandler instead
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      exitHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @since v2.5.0
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      overHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @since v2.5.0
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      outHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      pressHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.button
       *      Button which caused the event.
       *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      nonPrimaryPressHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.insideElementReleased
       *      True if the cursor inside the tracked element when the button was released.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      releaseHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.button
       *      Button which caused the event.
       *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      nonPrimaryReleaseHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      moveHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.scroll
       *      The scroll delta for the event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the wheel event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      scrollHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Boolean} event.quick
       *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Element} event.originalTarget
       *      The DOM element clicked on.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      clickHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      dblClickHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {OpenSeadragon.Point} event.delta
       *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
       * @param {Number} event.speed
       *     Current computed speed, in pixels per second.
       * @param {Number} event.direction
       *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      dragHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.speed
       *     Speed at the end of a drag gesture, in pixels per second.
       * @param {Number} event.direction
       *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      dragEndHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
       *      Gesture points associated with the gesture. Velocity data can be found here.
       * @param {OpenSeadragon.Point} event.lastCenter
       *      The previous center point of the two pinch contact points relative to the tracked element.
       * @param {OpenSeadragon.Point} event.center
       *      The center point of the two pinch contact points relative to the tracked element.
       * @param {Number} event.lastDistance
       *      The previous distance between the two pinch contact points in CSS pixels.
       * @param {Number} event.distance
       *      The distance between the two pinch contact points in CSS pixels.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      pinchHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      stopHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Number} event.keyCode
       *      The key code that was pressed.
       * @param {Boolean} event.ctrl
       *      True if the ctrl key was pressed during this event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.alt
       *      True if the alt key was pressed during this event.
       * @param {Boolean} event.meta
       *      True if the meta key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the keydown event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      keyDownHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Number} event.keyCode
       *      The key code that was pressed.
       * @param {Boolean} event.ctrl
       *      True if the ctrl key was pressed during this event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.alt
       *      True if the alt key was pressed during this event.
       * @param {Boolean} event.meta
       *      True if the meta key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the keyup event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      keyUpHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Number} event.keyCode
       *      The key code that was pressed.
       * @param {Boolean} event.ctrl
       *      True if the ctrl key was pressed during this event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.alt
       *      True if the alt key was pressed during this event.
       * @param {Boolean} event.meta
       *      True if the meta key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the keypress event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      keyHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      focusHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      blurHandler: function() {
      }
    };
    var isInIframe = function() {
      try {
        return window.self !== window.top;
      } catch (e) {
        return true;
      }
    }();
    function canAccessEvents(target) {
      try {
        return target.addEventListener && target.removeEventListener;
      } catch (e) {
        return false;
      }
    }
    $2.MouseTracker.gesturePointVelocityTracker = /* @__PURE__ */ function() {
      var trackerPoints = [], intervalId = 0, lastTime = 0;
      var _generateGuid = function(tracker, gPoint) {
        return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
      };
      var _doTracking = function() {
        var i, len = trackerPoints.length, trackPoint, gPoint, now = $2.now(), elapsedTime, distance, speed;
        elapsedTime = now - lastTime;
        lastTime = now;
        for (i = 0; i < len; i++) {
          trackPoint = trackerPoints[i];
          gPoint = trackPoint.gPoint;
          gPoint.direction = Math.atan2(gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x);
          distance = trackPoint.lastPos.distanceTo(gPoint.currentPos);
          trackPoint.lastPos = gPoint.currentPos;
          speed = 1e3 * distance / (elapsedTime + 1);
          gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
        }
      };
      var addPoint = function(tracker, gPoint) {
        var guid = _generateGuid(tracker, gPoint);
        trackerPoints.push(
          {
            guid,
            gPoint,
            lastPos: gPoint.currentPos
          }
        );
        if (trackerPoints.length === 1) {
          lastTime = $2.now();
          intervalId = window.setInterval(_doTracking, 50);
        }
      };
      var removePoint = function(tracker, gPoint) {
        var guid = _generateGuid(tracker, gPoint), i, len = trackerPoints.length;
        for (i = 0; i < len; i++) {
          if (trackerPoints[i].guid === guid) {
            trackerPoints.splice(i, 1);
            len--;
            if (len === 0) {
              window.clearInterval(intervalId);
            }
            break;
          }
        }
      };
      return {
        addPoint,
        removePoint
      };
    }();
    $2.MouseTracker.captureElement = document;
    $2.MouseTracker.wheelEventName = $2.Browser.vendor === $2.BROWSERS.IE && $2.Browser.version > 8 || "onwheel" in document.createElement("div") ? "wheel" : (
      // Modern browsers support 'wheel'
      document.onmousewheel !== void 0 ? "mousewheel" : (
        // Webkit and IE support at least 'mousewheel'
        "DOMMouseScroll"
      )
    );
    $2.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", $2.MouseTracker.wheelEventName];
    if ($2.MouseTracker.wheelEventName === "DOMMouseScroll") {
      $2.MouseTracker.subscribeEvents.push("MozMousePixelScroll");
    }
    if (window.PointerEvent) {
      $2.MouseTracker.havePointerEvents = true;
      $2.MouseTracker.subscribeEvents.push("pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel");
      $2.MouseTracker.havePointerCapture = function() {
        var divElement = document.createElement("div");
        return $2.isFunction(divElement.setPointerCapture) && $2.isFunction(divElement.releasePointerCapture);
      }();
      if ($2.MouseTracker.havePointerCapture) {
        $2.MouseTracker.subscribeEvents.push("gotpointercapture", "lostpointercapture");
      }
    } else {
      $2.MouseTracker.havePointerEvents = false;
      $2.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove");
      $2.MouseTracker.mousePointerId = "legacy-mouse";
      $2.MouseTracker.havePointerCapture = function() {
        var divElement = document.createElement("div");
        return $2.isFunction(divElement.setCapture) && $2.isFunction(divElement.releaseCapture);
      }();
      if ($2.MouseTracker.havePointerCapture) {
        $2.MouseTracker.subscribeEvents.push("losecapture");
      }
      if ("ontouchstart" in window) {
        $2.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel");
      }
      if ("ongesturestart" in window) {
        $2.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange");
      }
    }
    $2.MouseTracker.GesturePointList = function(type) {
      this._gPoints = [];
      this.type = type;
      this.buttons = 0;
      this.contacts = 0;
      this.clicks = 0;
      this.captureCount = 0;
    };
    $2.MouseTracker.GesturePointList.prototype = {
      /**
       * @function
       * @returns {Number} Number of gesture points in the list.
       */
      getLength: function() {
        return this._gPoints.length;
      },
      /**
       * @function
       * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
       */
      asArray: function() {
        return this._gPoints;
      },
      /**
       * @function
       * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
       * @returns {Number} Number of gesture points in the list.
       */
      add: function(gp) {
        return this._gPoints.push(gp);
      },
      /**
       * @function
       * @param {Number} id - The id of the gesture point to remove from the list.
       * @returns {Number} Number of gesture points in the list.
       */
      removeById: function(id) {
        var i, len = this._gPoints.length;
        for (i = 0; i < len; i++) {
          if (this._gPoints[i].id === id) {
            this._gPoints.splice(i, 1);
            break;
          }
        }
        return this._gPoints.length;
      },
      /**
       * @function
       * @param {Number} index - The index of the gesture point to retrieve from the list.
       * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
       */
      getByIndex: function(index) {
        if (index < this._gPoints.length) {
          return this._gPoints[index];
        }
        return null;
      },
      /**
       * @function
       * @param {Number} id - The id of the gesture point to retrieve from the list.
       * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
       */
      getById: function(id) {
        var i, len = this._gPoints.length;
        for (i = 0; i < len; i++) {
          if (this._gPoints[i].id === id) {
            return this._gPoints[i];
          }
        }
        return null;
      },
      /**
       * @function
       * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
       */
      getPrimary: function(id) {
        var i, len = this._gPoints.length;
        for (i = 0; i < len; i++) {
          if (this._gPoints[i].isPrimary) {
            return this._gPoints[i];
          }
        }
        return null;
      },
      /**
       * Increment this pointer list's contact count.
       * It will evaluate whether this pointer type is allowed to have multiple contacts.
       * @function
       */
      addContact: function() {
        ++this.contacts;
        if (this.contacts > 1 && (this.type === "mouse" || this.type === "pen")) {
          $2.console.warn("GesturePointList.addContact() Implausible contacts value");
          this.contacts = 1;
        }
      },
      /**
       * Decrement this pointer list's contact count.
       * It will make sure the count does not go below 0.
       * @function
       */
      removeContact: function() {
        --this.contacts;
        if (this.contacts < 0) {
          this.contacts = 0;
        }
      }
    };
    function clearTrackedPointers(tracker) {
      var delegate = THIS[tracker.hash], i, j, pointsList, gPoints, gPointsToRemove, pointerListCount = delegate.activePointersLists.length;
      for (i = 0; i < pointerListCount; i++) {
        pointsList = delegate.activePointersLists[i];
        if (pointsList.getLength() > 0) {
          gPointsToRemove = [];
          gPoints = pointsList.asArray();
          for (j = 0; j < gPoints.length; j++) {
            gPointsToRemove.push(gPoints[j]);
          }
          for (j = 0; j < gPointsToRemove.length; j++) {
            stopTrackingPointer(tracker, pointsList, gPointsToRemove[j]);
          }
        }
      }
      for (i = 0; i < pointerListCount; i++) {
        delegate.activePointersLists.pop();
      }
      delegate.sentDragEvent = false;
    }
    function startTracking(tracker) {
      var delegate = THIS[tracker.hash], event, i;
      if (!delegate.tracking) {
        for (i = 0; i < $2.MouseTracker.subscribeEvents.length; i++) {
          event = $2.MouseTracker.subscribeEvents[i];
          $2.addEvent(
            tracker.element,
            event,
            delegate[event],
            event === $2.MouseTracker.wheelEventName ? { passive: false, capture: false } : false
          );
        }
        clearTrackedPointers(tracker);
        delegate.tracking = true;
      }
    }
    function stopTracking(tracker) {
      var delegate = THIS[tracker.hash], event, i;
      if (delegate.tracking) {
        for (i = 0; i < $2.MouseTracker.subscribeEvents.length; i++) {
          event = $2.MouseTracker.subscribeEvents[i];
          $2.removeEvent(
            tracker.element,
            event,
            delegate[event],
            false
          );
        }
        clearTrackedPointers(tracker);
        delegate.tracking = false;
      }
    }
    function getCaptureEventParams(tracker, pointerType) {
      var delegate = THIS[tracker.hash];
      if (pointerType === "pointerevent") {
        return {
          upName: "pointerup",
          upHandler: delegate.pointerupcaptured,
          moveName: "pointermove",
          moveHandler: delegate.pointermovecaptured
        };
      } else if (pointerType === "mouse") {
        return {
          upName: "pointerup",
          upHandler: delegate.pointerupcaptured,
          moveName: "pointermove",
          moveHandler: delegate.pointermovecaptured
        };
      } else if (pointerType === "touch") {
        return {
          upName: "touchend",
          upHandler: delegate.touchendcaptured,
          moveName: "touchmove",
          moveHandler: delegate.touchmovecaptured
        };
      } else {
        throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
      }
    }
    function capturePointer(tracker, gPoint) {
      var eventParams;
      if ($2.MouseTracker.havePointerCapture) {
        if ($2.MouseTracker.havePointerEvents) {
          try {
            tracker.element.setPointerCapture(gPoint.id);
          } catch (e) {
            $2.console.warn("setPointerCapture() called on invalid pointer ID");
            return;
          }
        } else {
          tracker.element.setCapture(true);
        }
      } else {
        eventParams = getCaptureEventParams(tracker, $2.MouseTracker.havePointerEvents ? "pointerevent" : gPoint.type);
        if (isInIframe && canAccessEvents(window.top)) {
          $2.addEvent(
            window.top,
            eventParams.upName,
            eventParams.upHandler,
            true
          );
        }
        $2.addEvent(
          $2.MouseTracker.captureElement,
          eventParams.upName,
          eventParams.upHandler,
          true
        );
        $2.addEvent(
          $2.MouseTracker.captureElement,
          eventParams.moveName,
          eventParams.moveHandler,
          true
        );
      }
      updatePointerCaptured(tracker, gPoint, true);
    }
    function releasePointer(tracker, gPoint) {
      var eventParams;
      var pointsList;
      var cachedGPoint;
      if ($2.MouseTracker.havePointerCapture) {
        if ($2.MouseTracker.havePointerEvents) {
          pointsList = tracker.getActivePointersListByType(gPoint.type);
          cachedGPoint = pointsList.getById(gPoint.id);
          if (!cachedGPoint || !cachedGPoint.captured) {
            return;
          }
          try {
            tracker.element.releasePointerCapture(gPoint.id);
          } catch (e) {
          }
        } else {
          tracker.element.releaseCapture();
        }
      } else {
        eventParams = getCaptureEventParams(tracker, $2.MouseTracker.havePointerEvents ? "pointerevent" : gPoint.type);
        if (isInIframe && canAccessEvents(window.top)) {
          $2.removeEvent(
            window.top,
            eventParams.upName,
            eventParams.upHandler,
            true
          );
        }
        $2.removeEvent(
          $2.MouseTracker.captureElement,
          eventParams.moveName,
          eventParams.moveHandler,
          true
        );
        $2.removeEvent(
          $2.MouseTracker.captureElement,
          eventParams.upName,
          eventParams.upHandler,
          true
        );
      }
      updatePointerCaptured(tracker, gPoint, false);
    }
    function getPointerId(event) {
      return $2.MouseTracker.havePointerEvents ? event.pointerId : $2.MouseTracker.mousePointerId;
    }
    function getPointerType(event) {
      if ($2.MouseTracker.havePointerEvents) {
        return event.pointerType || ($2.Browser.vendor === $2.BROWSERS.IE ? "mouse" : "");
      } else {
        return "mouse";
      }
    }
    function getIsPrimary(event) {
      return $2.MouseTracker.havePointerEvents ? event.isPrimary : true;
    }
    function getMouseAbsolute(event) {
      return $2.getMousePosition(event);
    }
    function getMouseRelative(event, element) {
      return getPointRelativeToAbsolute(getMouseAbsolute(event), element);
    }
    function getPointRelativeToAbsolute(point, element) {
      var offset = $2.getElementOffset(element);
      return point.minus(offset);
    }
    function getCenterPoint(point1, point2) {
      return new $2.Point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
    }
    function onClick(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "click",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onDblClick(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "dblclick",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onKeyDown(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "keydown",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.keyDownHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          keyCode: event.keyCode ? event.keyCode : event.charCode,
          ctrl: event.ctrlKey,
          shift: event.shiftKey,
          alt: event.altKey,
          meta: event.metaKey,
          originalEvent: event,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.keyDownHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onKeyUp(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "keyup",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.keyUpHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          keyCode: event.keyCode ? event.keyCode : event.charCode,
          ctrl: event.ctrlKey,
          shift: event.shiftKey,
          alt: event.altKey,
          meta: event.metaKey,
          originalEvent: event,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.keyUpHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onKeyPress(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "keypress",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.keyHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          keyCode: event.keyCode ? event.keyCode : event.charCode,
          ctrl: event.ctrlKey,
          shift: event.shiftKey,
          alt: event.altKey,
          meta: event.metaKey,
          originalEvent: event,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.keyHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onFocus(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "focus",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.focusHandler && !eventInfo.preventGesture) {
        tracker.focusHandler(
          {
            eventSource: tracker,
            originalEvent: event,
            userData: tracker.userData
          }
        );
      }
    }
    function onBlur(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "blur",
        pointerType: "",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.blurHandler && !eventInfo.preventGesture) {
        tracker.blurHandler(
          {
            eventSource: tracker,
            originalEvent: event,
            userData: tracker.userData
          }
        );
      }
    }
    function onContextMenu(tracker, event) {
      var eventArgs = null;
      var eventInfo = {
        originalEvent: event,
        eventType: "contextmenu",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.contextMenuHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          position: getPointRelativeToAbsolute(getMouseAbsolute(event), tracker.element),
          originalEvent: eventInfo.originalEvent,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.contextMenuHandler(eventArgs);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onWheel(tracker, event) {
      handleWheelEvent(tracker, event, event);
    }
    function onMouseWheel(tracker, event) {
      var simulatedEvent = {
        target: event.target || event.srcElement,
        type: "wheel",
        shiftKey: event.shiftKey || false,
        clientX: event.clientX,
        clientY: event.clientY,
        pageX: event.pageX ? event.pageX : event.clientX,
        pageY: event.pageY ? event.pageY : event.clientY,
        deltaMode: event.type === "MozMousePixelScroll" ? 0 : 1,
        // 0=pixel, 1=line, 2=page
        deltaX: 0,
        deltaZ: 0
      };
      if ($2.MouseTracker.wheelEventName === "mousewheel") {
        simulatedEvent.deltaY = -event.wheelDelta / $2.DEFAULT_SETTINGS.pixelsPerWheelLine;
      } else {
        simulatedEvent.deltaY = event.detail;
      }
      handleWheelEvent(tracker, simulatedEvent, event);
    }
    function handleWheelEvent(tracker, event, originalEvent) {
      var nDelta = 0, eventInfo;
      var eventArgs = null;
      nDelta = event.deltaY < 0 ? 1 : -1;
      eventInfo = {
        originalEvent: event,
        eventType: "wheel",
        pointerType: "mouse",
        isEmulated: event !== originalEvent
      };
      preProcessEvent(tracker, eventInfo);
      if (tracker.scrollHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventArgs = {
          eventSource: tracker,
          pointerType: "mouse",
          position: getMouseRelative(event, tracker.element),
          scroll: nDelta,
          shift: event.shiftKey,
          isTouchEvent: false,
          originalEvent,
          preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
          userData: tracker.userData
        };
        tracker.scrollHandler(eventArgs);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(originalEvent);
      }
      if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(originalEvent);
      }
    }
    function onLoseCapture(tracker, event) {
      var gPoint = {
        id: $2.MouseTracker.mousePointerId,
        type: "mouse"
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "lostpointercapture",
        pointerType: "mouse",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (event.target === tracker.element) {
        updatePointerCaptured(tracker, gPoint, false);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onTouchStart(tracker, event) {
      var time, i, touchCount = event.changedTouches.length, gPoint, pointsList = tracker.getActivePointersListByType("touch");
      time = $2.now();
      if (pointsList.getLength() > event.touches.length - touchCount) {
        $2.console.warn("Tracked touch contact count doesn't match event.touches.length");
      }
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerdown",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0; i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch",
          // Simulate isPrimary
          isPrimary: pointsList.getLength() === 0,
          currentPos: getMouseAbsolute(event.changedTouches[i]),
          currentTime: time
        };
        updatePointerEnter(tracker, eventInfo, gPoint);
        updatePointerDown(tracker, eventInfo, gPoint, 0);
        updatePointerCaptured(tracker, gPoint, true);
      }
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onTouchEnd(tracker, event) {
      var time, i, touchCount = event.changedTouches.length, gPoint;
      time = $2.now();
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerup",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0; i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch",
          currentPos: getMouseAbsolute(event.changedTouches[i]),
          currentTime: time
        };
        updatePointerUp(tracker, eventInfo, gPoint, 0);
        updatePointerCaptured(tracker, gPoint, false);
        updatePointerLeave(tracker, eventInfo, gPoint);
      }
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onTouchMove(tracker, event) {
      var time, i, touchCount = event.changedTouches.length, gPoint;
      time = $2.now();
      var eventInfo = {
        originalEvent: event,
        eventType: "pointermove",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0; i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch",
          currentPos: getMouseAbsolute(event.changedTouches[i]),
          currentTime: time
        };
        updatePointerMove(tracker, eventInfo, gPoint);
      }
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onTouchCancel(tracker, event) {
      var touchCount = event.changedTouches.length, i, gPoint;
      var eventInfo = {
        originalEvent: event,
        eventType: "pointercancel",
        pointerType: "touch",
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      for (i = 0; i < touchCount; i++) {
        gPoint = {
          id: event.changedTouches[i].identifier,
          type: "touch"
        };
        updatePointerCancel(tracker, eventInfo, gPoint);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onGestureStart(tracker, event) {
      if (!$2.eventIsCanceled(event)) {
        event.preventDefault();
      }
      return false;
    }
    function onGestureChange(tracker, event) {
      if (!$2.eventIsCanceled(event)) {
        event.preventDefault();
      }
      return false;
    }
    function onGotPointerCapture(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "gotpointercapture",
        pointerType: getPointerType(event),
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (event.target === tracker.element) {
        updatePointerCaptured(tracker, {
          id: event.pointerId,
          type: getPointerType(event)
        }, true);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onLostPointerCapture(tracker, event) {
      var eventInfo = {
        originalEvent: event,
        eventType: "lostpointercapture",
        pointerType: getPointerType(event),
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      if (event.target === tracker.element) {
        updatePointerCaptured(tracker, {
          id: event.pointerId,
          type: getPointerType(event)
        }, false);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onPointerEnter(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $2.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerenter",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerEnter(tracker, eventInfo, gPoint);
    }
    function onPointerLeave(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $2.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerleave",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerLeave(tracker, eventInfo, gPoint);
    }
    function onPointerOver(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $2.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerover",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerOver(tracker, eventInfo, gPoint);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onPointerOut(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $2.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerout",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerOut(tracker, eventInfo, gPoint);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onPointerDown(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $2.now()
      };
      var implicitlyCaptured = $2.MouseTracker.havePointerEvents && gPoint.type === "touch" && $2.Browser.vendor !== $2.BROWSERS.IE;
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerdown",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerDown(tracker, eventInfo, gPoint, event.button);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
      if (eventInfo.shouldCapture) {
        if (implicitlyCaptured) {
          updatePointerCaptured(tracker, gPoint, true);
        } else {
          capturePointer(tracker, gPoint);
        }
      }
    }
    function onPointerUp(tracker, event) {
      handlePointerUp(tracker, event);
    }
    function onPointerUpCaptured(tracker, event) {
      var pointsList = tracker.getActivePointersListByType(getPointerType(event));
      if (pointsList.getById(event.pointerId)) {
        handlePointerUp(tracker, event);
      }
      $2.stopEvent(event);
    }
    function handlePointerUp(tracker, event) {
      var gPoint;
      gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $2.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointerup",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerUp(tracker, eventInfo, gPoint, event.button);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
      if (eventInfo.shouldReleaseCapture) {
        if (event.target === tracker.element) {
          releasePointer(tracker, gPoint);
        } else {
          updatePointerCaptured(tracker, gPoint, false);
        }
      }
    }
    function onPointerMove(tracker, event) {
      handlePointerMove(tracker, event);
    }
    function onPointerMoveCaptured(tracker, event) {
      var pointsList = tracker.getActivePointersListByType(getPointerType(event));
      if (pointsList.getById(event.pointerId)) {
        handlePointerMove(tracker, event);
      }
      $2.stopEvent(event);
    }
    function handlePointerMove(tracker, event) {
      var gPoint = {
        id: getPointerId(event),
        type: getPointerType(event),
        isPrimary: getIsPrimary(event),
        currentPos: getMouseAbsolute(event),
        currentTime: $2.now()
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointermove",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerMove(tracker, eventInfo, gPoint);
      if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
        $2.cancelEvent(event);
      }
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function onPointerCancel(tracker, event) {
      var gPoint = {
        id: event.pointerId,
        type: getPointerType(event)
      };
      var eventInfo = {
        originalEvent: event,
        eventType: "pointercancel",
        pointerType: gPoint.type,
        isEmulated: false
      };
      preProcessEvent(tracker, eventInfo);
      updatePointerCancel(tracker, eventInfo, gPoint);
      if (eventInfo.stopPropagation) {
        $2.stopEvent(event);
      }
    }
    function startTrackingPointer(pointsList, gPoint) {
      gPoint.speed = 0;
      gPoint.direction = 0;
      gPoint.contactPos = gPoint.currentPos;
      gPoint.contactTime = gPoint.currentTime;
      gPoint.lastPos = gPoint.currentPos;
      gPoint.lastTime = gPoint.currentTime;
      return pointsList.add(gPoint);
    }
    function stopTrackingPointer(tracker, pointsList, gPoint) {
      var listLength;
      var trackedGPoint = pointsList.getById(gPoint.id);
      if (trackedGPoint) {
        if (trackedGPoint.captured) {
          $2.console.warn("stopTrackingPointer() called on captured pointer");
          releasePointer(tracker, trackedGPoint);
        }
        pointsList.removeContact();
        listLength = pointsList.removeById(gPoint.id);
      } else {
        listLength = pointsList.getLength();
      }
      return listLength;
    }
    function getEventProcessDefaults(tracker, eventInfo) {
      switch (eventInfo.eventType) {
        case "pointermove":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasGestureHandlers;
          eventInfo.stopPropagation = false;
          break;
        case "pointerover":
        case "pointerout":
        case "contextmenu":
        case "keydown":
        case "keyup":
        case "keypress":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "pointerdown":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasGestureHandlers;
          eventInfo.stopPropagation = false;
          break;
        case "pointerup":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasGestureHandlers;
          eventInfo.stopPropagation = false;
          break;
        case "wheel":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = !tracker.hasScrollHandler;
          eventInfo.stopPropagation = false;
          break;
        case "gotpointercapture":
        case "lostpointercapture":
        case "pointercancel":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = false;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "click":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = !!tracker.clickHandler;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "dblclick":
          eventInfo.isStoppable = true;
          eventInfo.isCancelable = true;
          eventInfo.preventDefault = !!tracker.dblClickHandler;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
        case "focus":
        case "blur":
        case "pointerenter":
        case "pointerleave":
        default:
          eventInfo.isStoppable = false;
          eventInfo.isCancelable = false;
          eventInfo.preventDefault = false;
          eventInfo.preventGesture = false;
          eventInfo.stopPropagation = false;
          break;
      }
    }
    function preProcessEvent(tracker, eventInfo) {
      eventInfo.eventSource = tracker;
      eventInfo.eventPhase = eventInfo.originalEvent ? typeof eventInfo.originalEvent.eventPhase !== "undefined" ? eventInfo.originalEvent.eventPhase : 0 : 0;
      eventInfo.defaultPrevented = $2.eventIsCanceled(eventInfo.originalEvent);
      eventInfo.shouldCapture = false;
      eventInfo.shouldReleaseCapture = false;
      eventInfo.userData = tracker.userData;
      getEventProcessDefaults(tracker, eventInfo);
      if (tracker.preProcessEventHandler) {
        tracker.preProcessEventHandler(eventInfo);
      }
    }
    function updatePointerCaptured(tracker, gPoint, isCaptured) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type);
      var updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        if (isCaptured && !updateGPoint.captured) {
          updateGPoint.captured = true;
          pointsList.captureCount++;
        } else if (!isCaptured && updateGPoint.captured) {
          updateGPoint.captured = false;
          pointsList.captureCount--;
          if (pointsList.captureCount < 0) {
            pointsList.captureCount = 0;
            $2.console.warn("updatePointerCaptured() - pointsList.captureCount went negative");
          }
        }
      } else {
        $2.console.warn("updatePointerCaptured() called on untracked pointer");
      }
    }
    function updatePointerEnter(tracker, eventInfo, gPoint) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        updateGPoint.insideElement = true;
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
        gPoint.insideElement = true;
        startTrackingPointer(pointsList, gPoint);
      }
      if (tracker.enterHandler) {
        tracker.enterHandler(
          {
            eventSource: tracker,
            pointerType: gPoint.type,
            position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
            buttons: pointsList.buttons,
            pointers: tracker.getActivePointerCount(),
            insideElementPressed: gPoint.insideElementPressed,
            buttonDownAny: pointsList.buttons !== 0,
            isTouchEvent: gPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          }
        );
      }
    }
    function updatePointerLeave(tracker, eventInfo, gPoint) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint, dispatchEventObj;
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        if (updateGPoint.captured) {
          updateGPoint.insideElement = false;
          updateGPoint.lastPos = updateGPoint.currentPos;
          updateGPoint.lastTime = updateGPoint.currentTime;
          updateGPoint.currentPos = gPoint.currentPos;
          updateGPoint.currentTime = gPoint.currentTime;
        } else {
          stopTrackingPointer(tracker, pointsList, updateGPoint);
        }
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
      }
      if (tracker.leaveHandler || tracker.exitHandler) {
        dispatchEventObj = {
          eventSource: tracker,
          pointerType: gPoint.type,
          // GitHub PR: https://github.com/openseadragon/openseadragon/pull/1754 (gPoint.currentPos && )
          position: gPoint.currentPos && getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
          buttons: pointsList.buttons,
          pointers: tracker.getActivePointerCount(),
          insideElementPressed: gPoint.insideElementPressed,
          buttonDownAny: pointsList.buttons !== 0,
          isTouchEvent: gPoint.type === "touch",
          originalEvent: eventInfo.originalEvent,
          userData: tracker.userData
        };
        if (tracker.leaveHandler) {
          tracker.leaveHandler(dispatchEventObj);
        }
        if (tracker.exitHandler) {
          tracker.exitHandler(dispatchEventObj);
        }
      }
    }
    function updatePointerOver(tracker, eventInfo, gPoint) {
      var pointsList, updateGPoint;
      pointsList = tracker.getActivePointersListByType(gPoint.type);
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
      }
      if (tracker.overHandler) {
        tracker.overHandler(
          {
            eventSource: tracker,
            pointerType: gPoint.type,
            position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
            buttons: pointsList.buttons,
            pointers: tracker.getActivePointerCount(),
            insideElementPressed: gPoint.insideElementPressed,
            buttonDownAny: pointsList.buttons !== 0,
            isTouchEvent: gPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          }
        );
      }
    }
    function updatePointerOut(tracker, eventInfo, gPoint) {
      var pointsList, updateGPoint;
      pointsList = tracker.getActivePointersListByType(gPoint.type);
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
      }
      if (tracker.outHandler) {
        tracker.outHandler({
          eventSource: tracker,
          pointerType: gPoint.type,
          position: gPoint.currentPos && getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
          buttons: pointsList.buttons,
          pointers: tracker.getActivePointerCount(),
          insideElementPressed: gPoint.insideElementPressed,
          buttonDownAny: pointsList.buttons !== 0,
          isTouchEvent: gPoint.type === "touch",
          originalEvent: eventInfo.originalEvent,
          userData: tracker.userData
        });
      }
    }
    function updatePointerDown(tracker, eventInfo, gPoint, buttonChanged) {
      var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
      if (typeof eventInfo.originalEvent.buttons !== "undefined") {
        pointsList.buttons = eventInfo.originalEvent.buttons;
      } else {
        if (buttonChanged === 0) {
          pointsList.buttons |= 1;
        } else if (buttonChanged === 1) {
          pointsList.buttons |= 4;
        } else if (buttonChanged === 2) {
          pointsList.buttons |= 2;
        } else if (buttonChanged === 3) {
          pointsList.buttons |= 8;
        } else if (buttonChanged === 4) {
          pointsList.buttons |= 16;
        } else if (buttonChanged === 5) {
          pointsList.buttons |= 32;
        }
      }
      if (buttonChanged !== 0) {
        eventInfo.shouldCapture = false;
        eventInfo.shouldReleaseCapture = false;
        if (tracker.nonPrimaryPressHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventInfo.preventDefault = true;
          tracker.nonPrimaryPressHandler(
            {
              eventSource: tracker,
              pointerType: gPoint.type,
              position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
              button: buttonChanged,
              buttons: pointsList.buttons,
              isTouchEvent: gPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
        }
        return;
      }
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        updateGPoint.insideElementPressed = true;
        updateGPoint.insideElement = true;
        updateGPoint.originalTarget = eventInfo.originalEvent.target;
        updateGPoint.contactPos = gPoint.currentPos;
        updateGPoint.contactTime = gPoint.currentTime;
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
        gPoint = updateGPoint;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = true;
        gPoint.insideElement = true;
        gPoint.originalTarget = eventInfo.originalEvent.target;
        startTrackingPointer(pointsList, gPoint);
      }
      pointsList.addContact();
      if (!eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        eventInfo.shouldCapture = true;
        eventInfo.shouldReleaseCapture = false;
        eventInfo.preventDefault = true;
        if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
          $2.MouseTracker.gesturePointVelocityTracker.addPoint(tracker, gPoint);
        }
        if (pointsList.contacts === 1) {
          if (tracker.pressHandler && !eventInfo.preventGesture) {
            tracker.pressHandler(
              {
                eventSource: tracker,
                pointerType: gPoint.type,
                position: getPointRelativeToAbsolute(gPoint.contactPos, tracker.element),
                buttons: pointsList.buttons,
                isTouchEvent: gPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
          }
        } else if (pointsList.contacts === 2) {
          if (tracker.pinchHandler && gPoint.type === "touch") {
            delegate.pinchGPoints = pointsList.asArray();
            delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
            delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
          }
        }
      } else {
        eventInfo.shouldCapture = false;
        eventInfo.shouldReleaseCapture = false;
      }
    }
    function updatePointerUp(tracker, eventInfo, gPoint, buttonChanged) {
      var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), releasePoint, releaseTime, updateGPoint, wasCaptured = false, quick;
      if (typeof eventInfo.originalEvent.buttons !== "undefined") {
        pointsList.buttons = eventInfo.originalEvent.buttons;
      } else {
        if (buttonChanged === 0) {
          pointsList.buttons ^= -2;
        } else if (buttonChanged === 1) {
          pointsList.buttons ^= -5;
        } else if (buttonChanged === 2) {
          pointsList.buttons ^= -3;
        } else if (buttonChanged === 3) {
          pointsList.buttons ^= -9;
        } else if (buttonChanged === 4) {
          pointsList.buttons ^= -17;
        } else if (buttonChanged === 5) {
          pointsList.buttons ^= -33;
        }
      }
      eventInfo.shouldCapture = false;
      if (buttonChanged !== 0) {
        eventInfo.shouldReleaseCapture = false;
        if (tracker.nonPrimaryReleaseHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventInfo.preventDefault = true;
          tracker.nonPrimaryReleaseHandler(
            {
              eventSource: tracker,
              pointerType: gPoint.type,
              position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
              button: buttonChanged,
              buttons: pointsList.buttons,
              isTouchEvent: gPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
        }
        return;
      }
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        pointsList.removeContact();
        if (updateGPoint.captured) {
          wasCaptured = true;
        }
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
        if (!updateGPoint.insideElement) {
          stopTrackingPointer(tracker, pointsList, updateGPoint);
        }
        releasePoint = updateGPoint.currentPos;
        releaseTime = updateGPoint.currentTime;
      } else {
        gPoint.captured = false;
        gPoint.insideElementPressed = false;
        gPoint.insideElement = true;
        startTrackingPointer(pointsList, gPoint);
        updateGPoint = gPoint;
      }
      if (!eventInfo.preventGesture && !eventInfo.defaultPrevented) {
        if (wasCaptured) {
          eventInfo.shouldReleaseCapture = true;
          eventInfo.preventDefault = true;
          if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
            $2.MouseTracker.gesturePointVelocityTracker.removePoint(tracker, updateGPoint);
          }
          if (pointsList.contacts === 0) {
            if (tracker.releaseHandler && releasePoint) {
              tracker.releaseHandler(
                {
                  eventSource: tracker,
                  pointerType: updateGPoint.type,
                  position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                  buttons: pointsList.buttons,
                  insideElementPressed: updateGPoint.insideElementPressed,
                  insideElementReleased: updateGPoint.insideElement,
                  isTouchEvent: updateGPoint.type === "touch",
                  originalEvent: eventInfo.originalEvent,
                  userData: tracker.userData
                }
              );
            }
            if (tracker.dragEndHandler && delegate.sentDragEvent) {
              tracker.dragEndHandler(
                {
                  eventSource: tracker,
                  pointerType: updateGPoint.type,
                  position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                  speed: updateGPoint.speed,
                  direction: updateGPoint.direction,
                  shift: eventInfo.originalEvent.shiftKey,
                  isTouchEvent: updateGPoint.type === "touch",
                  originalEvent: eventInfo.originalEvent,
                  userData: tracker.userData
                }
              );
            }
            delegate.sentDragEvent = false;
            if ((tracker.clickHandler || tracker.dblClickHandler) && updateGPoint.insideElement) {
              quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold && updateGPoint.contactPos.distanceTo(releasePoint) <= tracker.clickDistThreshold;
              if (tracker.clickHandler) {
                tracker.clickHandler(
                  {
                    eventSource: tracker,
                    pointerType: updateGPoint.type,
                    position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                    quick,
                    shift: eventInfo.originalEvent.shiftKey,
                    isTouchEvent: updateGPoint.type === "touch",
                    originalEvent: eventInfo.originalEvent,
                    originalTarget: updateGPoint.originalTarget,
                    userData: tracker.userData
                  }
                );
              }
              if (tracker.dblClickHandler && quick) {
                pointsList.clicks++;
                if (pointsList.clicks === 1) {
                  delegate.lastClickPos = releasePoint;
                  delegate.dblClickTimeOut = setTimeout(function() {
                    pointsList.clicks = 0;
                  }, tracker.dblClickTimeThreshold);
                } else if (pointsList.clicks === 2) {
                  clearTimeout(delegate.dblClickTimeOut);
                  pointsList.clicks = 0;
                  if (delegate.lastClickPos.distanceTo(releasePoint) <= tracker.dblClickDistThreshold) {
                    tracker.dblClickHandler(
                      {
                        eventSource: tracker,
                        pointerType: updateGPoint.type,
                        position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                        shift: eventInfo.originalEvent.shiftKey,
                        isTouchEvent: updateGPoint.type === "touch",
                        originalEvent: eventInfo.originalEvent,
                        userData: tracker.userData
                      }
                    );
                  }
                  delegate.lastClickPos = null;
                }
              }
            }
          } else if (pointsList.contacts === 2) {
            if (tracker.pinchHandler && updateGPoint.type === "touch") {
              delegate.pinchGPoints = pointsList.asArray();
              delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
              delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
            }
          }
        } else {
          eventInfo.shouldReleaseCapture = false;
          if (tracker.releaseHandler && releasePoint) {
            tracker.releaseHandler(
              {
                eventSource: tracker,
                pointerType: updateGPoint.type,
                position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                buttons: pointsList.buttons,
                insideElementPressed: updateGPoint.insideElementPressed,
                insideElementReleased: updateGPoint.insideElement,
                isTouchEvent: updateGPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
            eventInfo.preventDefault = true;
          }
        }
      }
    }
    function updatePointerMove(tracker, eventInfo, gPoint) {
      var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint, gPointArray, delta;
      if (typeof eventInfo.originalEvent.buttons !== "undefined") {
        pointsList.buttons = eventInfo.originalEvent.buttons;
      }
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        updateGPoint.lastPos = updateGPoint.currentPos;
        updateGPoint.lastTime = updateGPoint.currentTime;
        updateGPoint.currentPos = gPoint.currentPos;
        updateGPoint.currentTime = gPoint.currentTime;
      } else {
        return;
      }
      eventInfo.shouldCapture = false;
      eventInfo.shouldReleaseCapture = false;
      if (tracker.stopHandler && gPoint.type === "mouse") {
        clearTimeout(tracker.stopTimeOut);
        tracker.stopTimeOut = setTimeout(function() {
          handlePointerStop(tracker, eventInfo.originalEvent, gPoint.type);
        }, tracker.stopDelay);
      }
      if (pointsList.contacts === 0) {
        if (tracker.moveHandler) {
          tracker.moveHandler(
            {
              eventSource: tracker,
              pointerType: gPoint.type,
              position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
              buttons: pointsList.buttons,
              isTouchEvent: gPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
        }
      } else if (pointsList.contacts === 1) {
        if (tracker.moveHandler) {
          updateGPoint = pointsList.asArray()[0];
          tracker.moveHandler(
            {
              eventSource: tracker,
              pointerType: updateGPoint.type,
              position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
              buttons: pointsList.buttons,
              isTouchEvent: updateGPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
        }
        if (tracker.dragHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          updateGPoint = pointsList.asArray()[0];
          delta = updateGPoint.currentPos.minus(updateGPoint.lastPos);
          tracker.dragHandler(
            {
              eventSource: tracker,
              pointerType: updateGPoint.type,
              position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
              buttons: pointsList.buttons,
              delta,
              speed: updateGPoint.speed,
              direction: updateGPoint.direction,
              shift: eventInfo.originalEvent.shiftKey,
              isTouchEvent: updateGPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
          eventInfo.preventDefault = true;
          delegate.sentDragEvent = true;
        }
      } else if (pointsList.contacts === 2) {
        if (tracker.moveHandler) {
          gPointArray = pointsList.asArray();
          tracker.moveHandler(
            {
              eventSource: tracker,
              pointerType: gPointArray[0].type,
              position: getPointRelativeToAbsolute(getCenterPoint(gPointArray[0].currentPos, gPointArray[1].currentPos), tracker.element),
              buttons: pointsList.buttons,
              isTouchEvent: gPointArray[0].type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
        }
        if (tracker.pinchHandler && gPoint.type === "touch" && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          delta = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
          if (delta !== delegate.currentPinchDist) {
            delegate.lastPinchDist = delegate.currentPinchDist;
            delegate.currentPinchDist = delta;
            delegate.lastPinchCenter = delegate.currentPinchCenter;
            delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
            tracker.pinchHandler(
              {
                eventSource: tracker,
                pointerType: "touch",
                gesturePoints: delegate.pinchGPoints,
                lastCenter: getPointRelativeToAbsolute(delegate.lastPinchCenter, tracker.element),
                center: getPointRelativeToAbsolute(delegate.currentPinchCenter, tracker.element),
                lastDistance: delegate.lastPinchDist,
                distance: delegate.currentPinchDist,
                shift: eventInfo.originalEvent.shiftKey,
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
            eventInfo.preventDefault = true;
          }
        }
      }
    }
    function updatePointerCancel(tracker, eventInfo, gPoint) {
      var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
      updateGPoint = pointsList.getById(gPoint.id);
      if (updateGPoint) {
        stopTrackingPointer(tracker, pointsList, updateGPoint);
      }
    }
    function handlePointerStop(tracker, originalMoveEvent, pointerType) {
      if (tracker.stopHandler) {
        tracker.stopHandler({
          eventSource: tracker,
          pointerType,
          position: getMouseRelative(originalMoveEvent, tracker.element),
          buttons: tracker.getActivePointersListByType(pointerType).buttons,
          isTouchEvent: pointerType === "touch",
          originalEvent: originalMoveEvent,
          userData: tracker.userData
        });
      }
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.ControlAnchor = {
      NONE: 0,
      TOP_LEFT: 1,
      TOP_RIGHT: 2,
      BOTTOM_RIGHT: 3,
      BOTTOM_LEFT: 4,
      ABSOLUTE: 5
    };
    $2.Control = function(element, options, container) {
      var parent = element.parentNode;
      if (typeof options === "number") {
        $2.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013");
        options = { anchor: options };
      }
      options.attachToViewer = typeof options.attachToViewer === "undefined" ? true : options.attachToViewer;
      this.autoFade = typeof options.autoFade === "undefined" ? true : options.autoFade;
      this.element = element;
      this.anchor = options.anchor;
      this.container = container;
      if (this.anchor === $2.ControlAnchor.ABSOLUTE) {
        this.wrapper = $2.makeNeutralElement("div");
        this.wrapper.style.position = "absolute";
        this.wrapper.style.top = typeof options.top === "number" ? options.top + "px" : options.top;
        this.wrapper.style.left = typeof options.left === "number" ? options.left + "px" : options.left;
        this.wrapper.style.height = typeof options.height === "number" ? options.height + "px" : options.height;
        this.wrapper.style.width = typeof options.width === "number" ? options.width + "px" : options.width;
        this.wrapper.style.margin = "0px";
        this.wrapper.style.padding = "0px";
        this.element.style.position = "relative";
        this.element.style.top = "0px";
        this.element.style.left = "0px";
        this.element.style.height = "100%";
        this.element.style.width = "100%";
      } else {
        this.wrapper = $2.makeNeutralElement("div");
        this.wrapper.style.display = "inline-block";
        if (this.anchor === $2.ControlAnchor.NONE) {
          this.wrapper.style.width = this.wrapper.style.height = "100%";
        }
      }
      this.wrapper.appendChild(this.element);
      if (options.attachToViewer) {
        if (this.anchor === $2.ControlAnchor.TOP_RIGHT || this.anchor === $2.ControlAnchor.BOTTOM_RIGHT) {
          this.container.insertBefore(
            this.wrapper,
            this.container.firstChild
          );
        } else {
          this.container.appendChild(this.wrapper);
        }
      } else {
        parent.appendChild(this.wrapper);
      }
    };
    $2.Control.prototype = {
      /**
       * Removes the control from the container.
       * @function
       */
      destroy: function() {
        this.wrapper.removeChild(this.element);
        if (this.anchor !== $2.ControlAnchor.NONE) {
          this.container.removeChild(this.wrapper);
        }
      },
      /**
       * Determines if the control is currently visible.
       * @function
       * @returns {Boolean} true if currently visible, false otherwise.
       */
      isVisible: function() {
        return this.wrapper.style.display !== "none";
      },
      /**
       * Toggles the visibility of the control.
       * @function
       * @param {Boolean} visible - true to make visible, false to hide.
       */
      setVisible: function(visible) {
        this.wrapper.style.display = visible ? this.anchor === $2.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
      },
      /**
       * Sets the opacity level for the control.
       * @function
       * @param {Number} opactiy - a value between 1 and 0 inclusively.
       */
      setOpacity: function(opacity) {
        if (this.element[$2.SIGNAL] && $2.Browser.vendor === $2.BROWSERS.IE) {
          $2.setElementOpacity(this.element, opacity, true);
        } else {
          $2.setElementOpacity(this.wrapper, opacity, true);
        }
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.ControlDock = function(options) {
      var layouts = ["topleft", "topright", "bottomright", "bottomleft"], layout, i;
      $2.extend(true, this, {
        id: "controldock-" + $2.now() + "-" + Math.floor(Math.random() * 1e6),
        container: $2.makeNeutralElement("div"),
        controls: []
      }, options);
      this.container.onsubmit = function() {
        return false;
      };
      if (this.element) {
        this.element = $2.getElement(this.element);
        this.element.appendChild(this.container);
        this.element.style.position = "relative";
        this.container.style.width = "100%";
        this.container.style.height = "100%";
      }
      for (i = 0; i < layouts.length; i++) {
        layout = layouts[i];
        this.controls[layout] = $2.makeNeutralElement("div");
        this.controls[layout].style.position = "absolute";
        if (layout.match("left")) {
          this.controls[layout].style.left = "0px";
        }
        if (layout.match("right")) {
          this.controls[layout].style.right = "0px";
        }
        if (layout.match("top")) {
          this.controls[layout].style.top = "0px";
        }
        if (layout.match("bottom")) {
          this.controls[layout].style.bottom = "0px";
        }
      }
      this.container.appendChild(this.controls.topleft);
      this.container.appendChild(this.controls.topright);
      this.container.appendChild(this.controls.bottomright);
      this.container.appendChild(this.controls.bottomleft);
    };
    $2.ControlDock.prototype = {
      /**
       * @function
       */
      addControl: function(element, controlOptions) {
        element = $2.getElement(element);
        var div = null;
        if (getControlIndex(this, element) >= 0) {
          return;
        }
        switch (controlOptions.anchor) {
          case $2.ControlAnchor.TOP_RIGHT:
            div = this.controls.topright;
            element.style.position = "relative";
            element.style.paddingRight = "0px";
            element.style.paddingTop = "0px";
            break;
          case $2.ControlAnchor.BOTTOM_RIGHT:
            div = this.controls.bottomright;
            element.style.position = "relative";
            element.style.paddingRight = "0px";
            element.style.paddingBottom = "0px";
            break;
          case $2.ControlAnchor.BOTTOM_LEFT:
            div = this.controls.bottomleft;
            element.style.position = "relative";
            element.style.paddingLeft = "0px";
            element.style.paddingBottom = "0px";
            break;
          case $2.ControlAnchor.TOP_LEFT:
            div = this.controls.topleft;
            element.style.position = "relative";
            element.style.paddingLeft = "0px";
            element.style.paddingTop = "0px";
            break;
          case $2.ControlAnchor.ABSOLUTE:
            div = this.container;
            element.style.margin = "0px";
            element.style.padding = "0px";
            break;
          default:
          case $2.ControlAnchor.NONE:
            div = this.container;
            element.style.margin = "0px";
            element.style.padding = "0px";
            break;
        }
        this.controls.push(
          new $2.Control(element, controlOptions, div)
        );
        element.style.display = "inline-block";
      },
      /**
       * @function
       * @returns {OpenSeadragon.ControlDock} Chainable.
       */
      removeControl: function(element) {
        element = $2.getElement(element);
        var i = getControlIndex(this, element);
        if (i >= 0) {
          this.controls[i].destroy();
          this.controls.splice(i, 1);
        }
        return this;
      },
      /**
       * @function
       * @returns {OpenSeadragon.ControlDock} Chainable.
       */
      clearControls: function() {
        while (this.controls.length > 0) {
          this.controls.pop().destroy();
        }
        return this;
      },
      /**
       * @function
       * @returns {Boolean}
       */
      areControlsEnabled: function() {
        var i;
        for (i = this.controls.length - 1; i >= 0; i--) {
          if (this.controls[i].isVisible()) {
            return true;
          }
        }
        return false;
      },
      /**
       * @function
       * @returns {OpenSeadragon.ControlDock} Chainable.
       */
      setControlsEnabled: function(enabled) {
        var i;
        for (i = this.controls.length - 1; i >= 0; i--) {
          this.controls[i].setVisible(enabled);
        }
        return this;
      }
    };
    function getControlIndex(dock, element) {
      var controls = dock.controls, i;
      for (i = controls.length - 1; i >= 0; i--) {
        if (controls[i].element === element) {
          return i;
        }
      }
      return -1;
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.Placement = $2.freezeObject({
      CENTER: 0,
      TOP_LEFT: 1,
      TOP: 2,
      TOP_RIGHT: 3,
      RIGHT: 4,
      BOTTOM_RIGHT: 5,
      BOTTOM: 6,
      BOTTOM_LEFT: 7,
      LEFT: 8,
      properties: {
        0: {
          isLeft: false,
          isHorizontallyCentered: true,
          isRight: false,
          isTop: false,
          isVerticallyCentered: true,
          isBottom: false
        },
        1: {
          isLeft: true,
          isHorizontallyCentered: false,
          isRight: false,
          isTop: true,
          isVerticallyCentered: false,
          isBottom: false
        },
        2: {
          isLeft: false,
          isHorizontallyCentered: true,
          isRight: false,
          isTop: true,
          isVerticallyCentered: false,
          isBottom: false
        },
        3: {
          isLeft: false,
          isHorizontallyCentered: false,
          isRight: true,
          isTop: true,
          isVerticallyCentered: false,
          isBottom: false
        },
        4: {
          isLeft: false,
          isHorizontallyCentered: false,
          isRight: true,
          isTop: false,
          isVerticallyCentered: true,
          isBottom: false
        },
        5: {
          isLeft: false,
          isHorizontallyCentered: false,
          isRight: true,
          isTop: false,
          isVerticallyCentered: false,
          isBottom: true
        },
        6: {
          isLeft: false,
          isHorizontallyCentered: true,
          isRight: false,
          isTop: false,
          isVerticallyCentered: false,
          isBottom: true
        },
        7: {
          isLeft: true,
          isHorizontallyCentered: false,
          isRight: false,
          isTop: false,
          isVerticallyCentered: false,
          isBottom: true
        },
        8: {
          isLeft: true,
          isHorizontallyCentered: false,
          isRight: false,
          isTop: false,
          isVerticallyCentered: true,
          isBottom: false
        }
      }
    });
  })(OpenSeadragon2);
  (function($2) {
    var THIS = {};
    var nextHash = 1;
    $2.Viewer = function(options) {
      var args = arguments, _this = this, i;
      if (!$2.isPlainObject(options)) {
        options = {
          id: args[0],
          xmlPath: args.length > 1 ? args[1] : void 0,
          prefixUrl: args.length > 2 ? args[2] : void 0,
          controls: args.length > 3 ? args[3] : void 0,
          overlays: args.length > 4 ? args[4] : void 0
        };
      }
      if (options.config) {
        $2.extend(true, options, options.config);
        delete options.config;
      }
      $2.extend(true, this, {
        //internal state and dom identifiers
        id: options.id,
        hash: options.hash || nextHash++,
        /**
         * Index for page to be shown first next time open() is called (only used in sequenceMode).
         * @member {Number} initialPage
         * @memberof OpenSeadragon.Viewer#
         */
        initialPage: 0,
        //dom nodes
        /**
         * The parent element of this Viewer instance, passed in when the Viewer was created.
         * @member {Element} element
         * @memberof OpenSeadragon.Viewer#
         */
        element: null,
        /**
         * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
         * Child element of {@link OpenSeadragon.Viewer#element}.
         * @member {Element} container
         * @memberof OpenSeadragon.Viewer#
         */
        container: null,
        /**
         * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
         * Child element of {@link OpenSeadragon.Viewer#container},
         * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
         * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
         * @member {Element} canvas
         * @memberof OpenSeadragon.Viewer#
         */
        canvas: null,
        // Overlays list. An overlay allows to add html on top of the viewer.
        overlays: [],
        // Container inside the canvas where overlays are drawn.
        overlaysContainer: null,
        //private state properties
        previousBody: [],
        //This was originally initialized in the constructor and so could never
        //have anything in it.  now it can because we allow it to be specified
        //in the options and is only empty by default if not specified. Also
        //this array was returned from get_controls which I find confusing
        //since this object has a controls property which is treated in other
        //functions like clearControls.  I'm removing the accessors.
        customControls: [],
        //These are originally not part options but declared as members
        //in initialize.  It's still considered idiomatic to put them here
        //source is here for backwards compatibility. It is not an official
        //part of the API and should not be relied upon.
        source: null,
        /**
         * Handles rendering of tiles in the viewer. Created for each TileSource opened.
         * @member {OpenSeadragon.Drawer} drawer
         * @memberof OpenSeadragon.Viewer#
         */
        drawer: null,
        /**
         * Keeps track of all of the tiled images in the scene.
         * @member {OpenSeadragon.World} world
         * @memberof OpenSeadragon.Viewer#
         */
        world: null,
        /**
         * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
         * @member {OpenSeadragon.Viewport} viewport
         * @memberof OpenSeadragon.Viewer#
         */
        viewport: null,
        /**
         * @member {OpenSeadragon.Navigator} navigator
         * @memberof OpenSeadragon.Viewer#
         */
        navigator: null,
        //A collection viewport is a separate viewport used to provide
        //simultaneous rendering of sets of tiles
        collectionViewport: null,
        collectionDrawer: null,
        //UI image resources
        //TODO: rename navImages to uiImages
        navImages: null,
        //interface button controls
        buttonGroup: null,
        //TODO: this is defunct so safely remove it
        profiler: null
      }, $2.DEFAULT_SETTINGS, options);
      if (typeof this.hash === "undefined") {
        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
      }
      if (typeof THIS[this.hash] !== "undefined") {
        $2.console.warn("Hash " + this.hash + " has already been used.");
      }
      THIS[this.hash] = {
        fsBoundsDelta: new $2.Point(1, 1),
        prevContainerSize: null,
        animating: false,
        forceRedraw: false,
        needsResize: false,
        forceResize: false,
        mouseInside: false,
        group: null,
        // whether we should be continuously zooming
        zooming: false,
        // how much we should be continuously zooming by
        zoomFactor: null,
        lastZoomTime: null,
        fullPage: false,
        onfullscreenchange: null,
        lastClickTime: null,
        draggingToZoom: false
      };
      this._sequenceIndex = 0;
      this._firstOpen = true;
      this._updateRequestId = null;
      this._loadQueue = [];
      this.currentOverlays = [];
      this._updatePixelDensityRatioBind = null;
      this._lastScrollTime = $2.now();
      $2.EventSource.call(this);
      this.addHandler("open-failed", function(event) {
        var msg = $2.getString("Errors.OpenFailed", event.eventSource, event.message);
        _this._showMessage(msg);
      });
      $2.ControlDock.call(this, options);
      if (this.xmlPath) {
        this.tileSources = [this.xmlPath];
      }
      this.element = this.element || document.getElementById(this.id);
      this.canvas = $2.makeNeutralElement("div");
      this.canvas.className = "openseadragon-canvas";
      (function(style2) {
        style2.width = "100%";
        style2.height = "100%";
        style2.overflow = "hidden";
        style2.position = "absolute";
        style2.top = "0px";
        style2.left = "0px";
      })(this.canvas.style);
      $2.setElementTouchActionNone(this.canvas);
      if (options.tabIndex !== "") {
        this.canvas.tabIndex = options.tabIndex === void 0 ? 0 : options.tabIndex;
      }
      this.container.className = "openseadragon-container";
      (function(style2) {
        style2.width = "100%";
        style2.height = "100%";
        style2.position = "relative";
        style2.overflow = "hidden";
        style2.left = "0px";
        style2.top = "0px";
        style2.textAlign = "left";
      })(this.container.style);
      $2.setElementTouchActionNone(this.container);
      this.container.insertBefore(this.canvas, this.container.firstChild);
      this.element.appendChild(this.container);
      this.bodyWidth = document.body.style.width;
      this.bodyHeight = document.body.style.height;
      this.bodyOverflow = document.body.style.overflow;
      this.docOverflow = document.documentElement.style.overflow;
      this.innerTracker = new $2.MouseTracker({
        userData: "Viewer.innerTracker",
        element: this.canvas,
        startDisabled: !this.mouseNavEnabled,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        dblClickTimeThreshold: this.dblClickTimeThreshold,
        dblClickDistThreshold: this.dblClickDistThreshold,
        contextMenuHandler: $2.delegate(this, onCanvasContextMenu),
        keyDownHandler: $2.delegate(this, onCanvasKeyDown),
        keyHandler: $2.delegate(this, onCanvasKeyPress),
        clickHandler: $2.delegate(this, onCanvasClick),
        dblClickHandler: $2.delegate(this, onCanvasDblClick),
        dragHandler: $2.delegate(this, onCanvasDrag),
        dragEndHandler: $2.delegate(this, onCanvasDragEnd),
        enterHandler: $2.delegate(this, onCanvasEnter),
        leaveHandler: $2.delegate(this, onCanvasLeave),
        pressHandler: $2.delegate(this, onCanvasPress),
        releaseHandler: $2.delegate(this, onCanvasRelease),
        nonPrimaryPressHandler: $2.delegate(this, onCanvasNonPrimaryPress),
        nonPrimaryReleaseHandler: $2.delegate(this, onCanvasNonPrimaryRelease),
        scrollHandler: $2.delegate(this, onCanvasScroll),
        pinchHandler: $2.delegate(this, onCanvasPinch),
        focusHandler: $2.delegate(this, onCanvasFocus),
        blurHandler: $2.delegate(this, onCanvasBlur)
      });
      this.outerTracker = new $2.MouseTracker({
        userData: "Viewer.outerTracker",
        element: this.container,
        startDisabled: !this.mouseNavEnabled,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        dblClickTimeThreshold: this.dblClickTimeThreshold,
        dblClickDistThreshold: this.dblClickDistThreshold,
        enterHandler: $2.delegate(this, onContainerEnter),
        leaveHandler: $2.delegate(this, onContainerLeave)
      });
      if (this.toolbar) {
        this.toolbar = new $2.ControlDock({ element: this.toolbar });
      }
      this.bindStandardControls();
      THIS[this.hash].prevContainerSize = _getSafeElemSize(this.container);
      if (window.ResizeObserver) {
        this._autoResizePolling = false;
        this._resizeObserver = new ResizeObserver(function() {
          THIS[_this.hash].needsResize = true;
        });
        this._resizeObserver.observe(this.container, {});
      } else {
        this._autoResizePolling = true;
      }
      this.world = new $2.World({
        viewer: this
      });
      this.world.addHandler("add-item", function(event) {
        _this.source = _this.world.getItemAt(0).source;
        THIS[_this.hash].forceRedraw = true;
        if (!_this._updateRequestId) {
          _this._updateRequestId = scheduleUpdate(_this, updateMulti);
        }
      });
      this.world.addHandler("remove-item", function(event) {
        if (_this.world.getItemCount()) {
          _this.source = _this.world.getItemAt(0).source;
        } else {
          _this.source = null;
        }
        THIS[_this.hash].forceRedraw = true;
      });
      this.world.addHandler("metrics-change", function(event) {
        if (_this.viewport) {
          _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
        }
      });
      this.world.addHandler("item-index-change", function(event) {
        _this.source = _this.world.getItemAt(0).source;
      });
      this.viewport = new $2.Viewport({
        containerSize: THIS[this.hash].prevContainerSize,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime,
        minZoomImageRatio: this.minZoomImageRatio,
        maxZoomPixelRatio: this.maxZoomPixelRatio,
        visibilityRatio: this.visibilityRatio,
        wrapHorizontal: this.wrapHorizontal,
        wrapVertical: this.wrapVertical,
        defaultZoomLevel: this.defaultZoomLevel,
        minZoomLevel: this.minZoomLevel,
        maxZoomLevel: this.maxZoomLevel,
        viewer: this,
        degrees: this.degrees,
        flipped: this.flipped,
        navigatorRotate: this.navigatorRotate,
        homeFillsViewer: this.homeFillsViewer,
        margins: this.viewportMargins,
        silenceMultiImageWarnings: this.silenceMultiImageWarnings
      });
      this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());
      this.imageLoader = new $2.ImageLoader({
        jobLimit: this.imageLoaderLimit,
        timeout: options.timeout,
        tileRetryMax: this.tileRetryMax,
        tileRetryDelay: this.tileRetryDelay
      });
      this.tileCache = new $2.TileCache({
        maxImageCacheCount: this.maxImageCacheCount
      });
      this.drawer = new $2.Drawer({
        viewer: this,
        viewport: this.viewport,
        element: this.canvas,
        debugGridColor: this.debugGridColor
      });
      this.overlaysContainer = $2.makeNeutralElement("div");
      this.canvas.appendChild(this.overlaysContainer);
      if (!this.drawer.canRotate()) {
        if (this.rotateLeft) {
          i = this.buttonGroup.buttons.indexOf(this.rotateLeft);
          this.buttonGroup.buttons.splice(i, 1);
          this.buttonGroup.element.removeChild(this.rotateLeft.element);
        }
        if (this.rotateRight) {
          i = this.buttonGroup.buttons.indexOf(this.rotateRight);
          this.buttonGroup.buttons.splice(i, 1);
          this.buttonGroup.element.removeChild(this.rotateRight.element);
        }
      }
      this._addUpdatePixelDensityRatioEvent();
      if (this.showNavigator) {
        this.navigator = new $2.Navigator({
          element: this.navigatorElement,
          id: this.navigatorId,
          position: this.navigatorPosition,
          sizeRatio: this.navigatorSizeRatio,
          maintainSizeRatio: this.navigatorMaintainSizeRatio,
          top: this.navigatorTop,
          left: this.navigatorLeft,
          width: this.navigatorWidth,
          height: this.navigatorHeight,
          autoResize: this.navigatorAutoResize,
          autoFade: this.navigatorAutoFade,
          prefixUrl: this.prefixUrl,
          viewer: this,
          navigatorRotate: this.navigatorRotate,
          background: this.navigatorBackground,
          opacity: this.navigatorOpacity,
          borderColor: this.navigatorBorderColor,
          displayRegionColor: this.navigatorDisplayRegionColor,
          crossOriginPolicy: this.crossOriginPolicy,
          animationTime: this.animationTime
        });
      }
      if (this.sequenceMode) {
        this.bindSequenceControls();
      }
      if (this.tileSources) {
        this.open(this.tileSources);
      }
      for (i = 0; i < this.customControls.length; i++) {
        this.addControl(
          this.customControls[i].id,
          { anchor: this.customControls[i].anchor }
        );
      }
      $2.requestAnimationFrame(function() {
        beginControlsAutoHide(_this);
      });
      if (this.imageSmoothingEnabled !== void 0 && !this.imageSmoothingEnabled) {
        this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);
      }
      $2._viewers.set(this.element, this);
    };
    $2.extend(
      $2.Viewer.prototype,
      $2.EventSource.prototype,
      $2.ControlDock.prototype,
      /** @lends OpenSeadragon.Viewer.prototype */
      {
        /**
         * @function
         * @returns {Boolean}
         */
        isOpen: function() {
          return !!this.world.getItemCount();
        },
        // deprecated
        openDzi: function(dzi) {
          $2.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead.");
          return this.open(dzi);
        },
        // deprecated
        openTileSource: function(tileSource) {
          $2.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead.");
          return this.open(tileSource);
        },
        //deprecated
        get buttons() {
          $2.console.warn("Viewer.buttons is deprecated; Please use Viewer.buttonGroup");
          return this.buttonGroup;
        },
        /**
         * Open tiled images into the viewer, closing any others.
         * To get the TiledImage instance created by open, add an event listener for
         * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
         * to the instance, i.e., viewer.world.getItemAt(0).
         * @function
         * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
         * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
         * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
         * except for the index property; images are added in sequence.
         * A TileSource specifier is anything you could pass as the tileSource property
         * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
         * @param {Number} initialPage - If sequenceMode is true, display this page initially
         * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:open
         * @fires OpenSeadragon.Viewer.event:open-failed
         */
        open: function(tileSources, initialPage) {
          var _this = this;
          this.close();
          if (!tileSources) {
            return this;
          }
          if (this.sequenceMode && $2.isArray(tileSources)) {
            if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
            }
            if (typeof initialPage !== "undefined" && !isNaN(initialPage)) {
              this.initialPage = initialPage;
            }
            this.tileSources = tileSources;
            this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
            if (this.tileSources.length) {
              this.open(this.tileSources[this._sequenceIndex]);
              if (this.showReferenceStrip) {
                this.addReferenceStrip();
              }
            }
            this._updateSequenceButtons(this._sequenceIndex);
            return this;
          }
          if (!$2.isArray(tileSources)) {
            tileSources = [tileSources];
          }
          if (!tileSources.length) {
            return this;
          }
          this._opening = true;
          var expected = tileSources.length;
          var successes = 0;
          var failures = 0;
          var failEvent;
          var checkCompletion = function() {
            if (successes + failures === expected) {
              if (successes) {
                if (_this._firstOpen || !_this.preserveViewport) {
                  _this.viewport.goHome(true);
                  _this.viewport.update();
                }
                _this._firstOpen = false;
                var source = tileSources[0];
                if (source.tileSource) {
                  source = source.tileSource;
                }
                if (_this.overlays && !_this.preserveOverlays) {
                  for (var i2 = 0; i2 < _this.overlays.length; i2++) {
                    _this.currentOverlays[i2] = getOverlayObject(_this, _this.overlays[i2]);
                  }
                }
                _this._drawOverlays();
                _this._opening = false;
                _this.raiseEvent("open", { source });
              } else {
                _this._opening = false;
                _this.raiseEvent("open-failed", failEvent);
              }
            }
          };
          var doOne = function(options) {
            if (!$2.isPlainObject(options) || !options.tileSource) {
              options = {
                tileSource: options
              };
            }
            if (options.index !== void 0) {
              $2.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead");
              delete options.index;
            }
            if (options.collectionImmediately === void 0) {
              options.collectionImmediately = true;
            }
            var originalSuccess = options.success;
            options.success = function(event) {
              successes++;
              if (options.tileSource.overlays) {
                for (var i2 = 0; i2 < options.tileSource.overlays.length; i2++) {
                  _this.addOverlay(options.tileSource.overlays[i2]);
                }
              }
              if (originalSuccess) {
                originalSuccess(event);
              }
              checkCompletion();
            };
            var originalError = options.error;
            options.error = function(event) {
              failures++;
              if (!failEvent) {
                failEvent = event;
              }
              if (originalError) {
                originalError(event);
              }
              checkCompletion();
            };
            _this.addTiledImage(options);
          };
          for (var i = 0; i < tileSources.length; i++) {
            doOne(tileSources[i]);
          }
          return this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:close
         */
        close: function() {
          if (!THIS[this.hash]) {
            return this;
          }
          this._opening = false;
          if (this.navigator) {
            this.navigator.close();
          }
          if (!this.preserveOverlays) {
            this.clearOverlays();
            this.overlaysContainer.innerHTML = "";
          }
          THIS[this.hash].animating = false;
          this.world.removeAll();
          this.imageLoader.clear();
          this.raiseEvent("close");
          return this;
        },
        /**
         * Function to destroy the viewer and clean up everything created by OpenSeadragon.
         *
         * Example:
         * var viewer = OpenSeadragon({
         *   [...]
         * });
         *
         * //when you are done with the viewer:
         * viewer.destroy();
         * viewer = null; //important
         *
         * @function
         * @fires OpenSeadragon.Viewer.event:before-destroy
         * @fires OpenSeadragon.Viewer.event:destroy
         */
        destroy: function() {
          if (!THIS[this.hash]) {
            return;
          }
          this.raiseEvent("before-destroy");
          this._removeUpdatePixelDensityRatioEvent();
          this.close();
          this.clearOverlays();
          this.overlaysContainer.innerHTML = "";
          if (this._resizeObserver) {
            this._resizeObserver.disconnect();
          }
          if (this.referenceStrip) {
            this.referenceStrip.destroy();
            this.referenceStrip = null;
          }
          if (this._updateRequestId !== null) {
            $2.cancelAnimationFrame(this._updateRequestId);
            this._updateRequestId = null;
          }
          if (this.drawer) {
            this.drawer.destroy();
          }
          if (this.navigator) {
            this.navigator.destroy();
            THIS[this.navigator.hash] = null;
            delete THIS[this.navigator.hash];
            this.navigator = null;
          }
          if (this.buttonGroup) {
            this.buttonGroup.destroy();
          } else if (this.customButtons) {
            while (this.customButtons.length) {
              this.customButtons.pop().destroy();
            }
          }
          if (this.paging) {
            this.paging.destroy();
          }
          if (this.element) {
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild);
            }
          }
          this.container.onsubmit = null;
          this.clearControls();
          if (this.innerTracker) {
            this.innerTracker.destroy();
          }
          if (this.outerTracker) {
            this.outerTracker.destroy();
          }
          THIS[this.hash] = null;
          delete THIS[this.hash];
          this.canvas = null;
          this.container = null;
          $2._viewers.delete(this.element);
          this.element = null;
          this.raiseEvent("destroy");
          this.removeAllHandlers();
        },
        /**
         * @function
         * @returns {Boolean}
         */
        isMouseNavEnabled: function() {
          return this.innerTracker.isTracking();
        },
        /**
         * @function
         * @param {Boolean} enabled - true to enable, false to disable
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:mouse-enabled
         */
        setMouseNavEnabled: function(enabled) {
          this.innerTracker.setTracking(enabled);
          this.outerTracker.setTracking(enabled);
          this.raiseEvent("mouse-enabled", { enabled });
          return this;
        },
        /**
         * @function
         * @returns {Boolean}
         */
        areControlsEnabled: function() {
          var enabled = this.controls.length, i;
          for (i = 0; i < this.controls.length; i++) {
            enabled = enabled && this.controls[i].isVisible();
          }
          return enabled;
        },
        /**
         * Shows or hides the controls (e.g. the default navigation buttons).
         *
         * @function
         * @param {Boolean} true to show, false to hide.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:controls-enabled
         */
        setControlsEnabled: function(enabled) {
          if (enabled) {
            abortControlsAutoHide(this);
          } else {
            beginControlsAutoHide(this);
          }
          this.raiseEvent("controls-enabled", { enabled });
          return this;
        },
        /**
         * Turns debugging mode on or off for this viewer.
         *
         * @function
         * @param {Boolean} debugMode true to turn debug on, false to turn debug off.
         */
        setDebugMode: function(debugMode) {
          for (var i = 0; i < this.world.getItemCount(); i++) {
            this.world.getItemAt(i).debugMode = debugMode;
          }
          this.debugMode = debugMode;
          this.forceRedraw();
        },
        /**
         * Update headers to include when making AJAX requests.
         *
         * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
         * the updated headers are propagated to all tiled images, each of which will subsequently
         * propagate the changed headers to all their tiles.
         * If applicable, the headers of the viewer's navigator and reference strip will also be updated.
         *
         * Note that the rules for merging headers still apply, i.e. headers returned by
         * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
         * `TiledImage.ajaxHeaders`, which take precedence over the headers here in the viewer.
         *
         * @function
         * @param {Object} ajaxHeaders Updated AJAX headers.
         * @param {Boolean} [propagate=true] Whether to propagate updated headers to tiled images, etc.
         */
        setAjaxHeaders: function(ajaxHeaders, propagate) {
          if (ajaxHeaders === null) {
            ajaxHeaders = {};
          }
          if (!$2.isPlainObject(ajaxHeaders)) {
            console.error("[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
            return;
          }
          if (propagate === void 0) {
            propagate = true;
          }
          this.ajaxHeaders = ajaxHeaders;
          if (propagate) {
            for (var i = 0; i < this.world.getItemCount(); i++) {
              this.world.getItemAt(i)._updateAjaxHeaders(true);
            }
            if (this.navigator) {
              this.navigator.setAjaxHeaders(this.ajaxHeaders, true);
            }
            if (this.referenceStrip && this.referenceStrip.miniViewers) {
              for (var key in this.referenceStrip.miniViewers) {
                this.referenceStrip.miniViewers[key].setAjaxHeaders(this.ajaxHeaders, true);
              }
            }
          }
        },
        /**
         * Adds the given button to this viewer.
         *
         * @function
         * @param {OpenSeadragon.Button} button
         */
        addButton: function(button) {
          this.buttonGroup.addButton(button);
        },
        /**
         * @function
         * @returns {Boolean}
         */
        isFullPage: function() {
          return THIS[this.hash].fullPage;
        },
        /**
         * Toggle full page mode.
         * @function
         * @param {Boolean} fullPage
         *      If true, enter full page mode.  If false, exit full page mode.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:pre-full-page
         * @fires OpenSeadragon.Viewer.event:full-page
         */
        setFullPage: function(fullPage) {
          var body = document.body, bodyStyle = body.style, docStyle = document.documentElement.style, _this = this, nodes, i;
          if (fullPage === this.isFullPage()) {
            return this;
          }
          var fullPageEventArgs = {
            fullPage,
            preventDefaultAction: false
          };
          this.raiseEvent("pre-full-page", fullPageEventArgs);
          if (fullPageEventArgs.preventDefaultAction) {
            return this;
          }
          if (fullPage) {
            this.elementSize = $2.getElementSize(this.element);
            this.pageScroll = $2.getPageScroll();
            this.elementMargin = this.element.style.margin;
            this.element.style.margin = "0";
            this.elementPadding = this.element.style.padding;
            this.element.style.padding = "0";
            this.bodyMargin = bodyStyle.margin;
            this.docMargin = docStyle.margin;
            bodyStyle.margin = "0";
            docStyle.margin = "0";
            this.bodyPadding = bodyStyle.padding;
            this.docPadding = docStyle.padding;
            bodyStyle.padding = "0";
            docStyle.padding = "0";
            this.bodyWidth = bodyStyle.width;
            this.docWidth = docStyle.width;
            bodyStyle.width = "100%";
            docStyle.width = "100%";
            this.bodyHeight = bodyStyle.height;
            this.docHeight = docStyle.height;
            bodyStyle.height = "100%";
            docStyle.height = "100%";
            this.bodyDisplay = bodyStyle.display;
            bodyStyle.display = "block";
            this.previousBody = [];
            THIS[this.hash].prevElementParent = this.element.parentNode;
            THIS[this.hash].prevNextSibling = this.element.nextSibling;
            THIS[this.hash].prevElementWidth = this.element.style.width;
            THIS[this.hash].prevElementHeight = this.element.style.height;
            nodes = body.childNodes.length;
            for (i = 0; i < nodes; i++) {
              this.previousBody.push(body.childNodes[0]);
              body.removeChild(body.childNodes[0]);
            }
            if (this.toolbar && this.toolbar.element) {
              this.toolbar.parentNode = this.toolbar.element.parentNode;
              this.toolbar.nextSibling = this.toolbar.element.nextSibling;
              body.appendChild(this.toolbar.element);
              $2.addClass(this.toolbar.element, "fullpage");
            }
            $2.addClass(this.element, "fullpage");
            body.appendChild(this.element);
            this.element.style.height = "100vh";
            this.element.style.width = "100vw";
            if (this.toolbar && this.toolbar.element) {
              this.element.style.height = $2.getElementSize(this.element).y - $2.getElementSize(this.toolbar.element).y + "px";
            }
            THIS[this.hash].fullPage = true;
            $2.delegate(this, onContainerEnter)({});
          } else {
            this.element.style.margin = this.elementMargin;
            this.element.style.padding = this.elementPadding;
            bodyStyle.margin = this.bodyMargin;
            docStyle.margin = this.docMargin;
            bodyStyle.padding = this.bodyPadding;
            docStyle.padding = this.docPadding;
            bodyStyle.width = this.bodyWidth;
            docStyle.width = this.docWidth;
            bodyStyle.height = this.bodyHeight;
            docStyle.height = this.docHeight;
            bodyStyle.display = this.bodyDisplay;
            body.removeChild(this.element);
            nodes = this.previousBody.length;
            for (i = 0; i < nodes; i++) {
              body.appendChild(this.previousBody.shift());
            }
            $2.removeClass(this.element, "fullpage");
            THIS[this.hash].prevElementParent.insertBefore(
              this.element,
              THIS[this.hash].prevNextSibling
            );
            if (this.toolbar && this.toolbar.element) {
              body.removeChild(this.toolbar.element);
              $2.removeClass(this.toolbar.element, "fullpage");
              this.toolbar.parentNode.insertBefore(
                this.toolbar.element,
                this.toolbar.nextSibling
              );
              delete this.toolbar.parentNode;
              delete this.toolbar.nextSibling;
            }
            this.element.style.width = THIS[this.hash].prevElementWidth;
            this.element.style.height = THIS[this.hash].prevElementHeight;
            var restoreScrollCounter = 0;
            var restoreScroll = function() {
              $2.setPageScroll(_this.pageScroll);
              var pageScroll = $2.getPageScroll();
              restoreScrollCounter++;
              if (restoreScrollCounter < 10 && (pageScroll.x !== _this.pageScroll.x || pageScroll.y !== _this.pageScroll.y)) {
                $2.requestAnimationFrame(restoreScroll);
              }
            };
            $2.requestAnimationFrame(restoreScroll);
            THIS[this.hash].fullPage = false;
            $2.delegate(this, onContainerLeave)({});
          }
          if (this.navigator && this.viewport) {
            this.navigator.update(this.viewport);
          }
          this.raiseEvent("full-page", { fullPage });
          return this;
        },
        /**
         * Toggle full screen mode if supported. Toggle full page mode otherwise.
         * @function
         * @param {Boolean} fullScreen
         *      If true, enter full screen mode.  If false, exit full screen mode.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:pre-full-screen
         * @fires OpenSeadragon.Viewer.event:full-screen
         */
        setFullScreen: function(fullScreen) {
          var _this = this;
          if (!$2.supportsFullScreen) {
            return this.setFullPage(fullScreen);
          }
          if ($2.isFullScreen() === fullScreen) {
            return this;
          }
          var fullScreeEventArgs = {
            fullScreen,
            preventDefaultAction: false
          };
          this.raiseEvent("pre-full-screen", fullScreeEventArgs);
          if (fullScreeEventArgs.preventDefaultAction) {
            return this;
          }
          if (fullScreen) {
            this.setFullPage(true);
            if (!this.isFullPage()) {
              return this;
            }
            this.fullPageStyleWidth = this.element.style.width;
            this.fullPageStyleHeight = this.element.style.height;
            this.element.style.width = "100%";
            this.element.style.height = "100%";
            var onFullScreenChange = function() {
              var isFullScreen = $2.isFullScreen();
              if (!isFullScreen) {
                $2.removeEvent(document, $2.fullScreenEventName, onFullScreenChange);
                $2.removeEvent(document, $2.fullScreenErrorEventName, onFullScreenChange);
                _this.setFullPage(false);
                if (_this.isFullPage()) {
                  _this.element.style.width = _this.fullPageStyleWidth;
                  _this.element.style.height = _this.fullPageStyleHeight;
                }
              }
              if (_this.navigator && _this.viewport) {
                setTimeout(function() {
                  _this.navigator.update(_this.viewport);
                });
              }
              _this.raiseEvent("full-screen", { fullScreen: isFullScreen });
            };
            $2.addEvent(document, $2.fullScreenEventName, onFullScreenChange);
            $2.addEvent(document, $2.fullScreenErrorEventName, onFullScreenChange);
            $2.requestFullScreen(document.body);
          } else {
            $2.exitFullScreen();
          }
          return this;
        },
        /**
         * @function
         * @returns {Boolean}
         */
        isVisible: function() {
          return this.container.style.visibility !== "hidden";
        },
        //
        /**
         * @function
         * @returns {Boolean} returns true if the viewer is in fullscreen
         */
        isFullScreen: function() {
          return $2.isFullScreen() && this.isFullPage();
        },
        /**
         * @function
         * @param {Boolean} visible
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:visible
         */
        setVisible: function(visible) {
          this.container.style.visibility = visible ? "" : "hidden";
          this.raiseEvent("visible", { visible });
          return this;
        },
        /**
         * Add a tiled image to the viewer.
         * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
         *  supports except arrays of images.
         * Note that you can specify options.width or options.height, but not both.
         * The other dimension will be calculated according to the item's aspect ratio.
         * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
         * automatically arranged with the others.
         * @function
         * @param {Object} options
         * @param {String|Object|Function} options.tileSource - The TileSource specifier.
         * A String implies a url used to determine the tileSource implementation
         *      based on the file extension of url. JSONP is implied by *.js,
         *      otherwise the url is retrieved as text and the resulting text is
         *      introspected to determine if its json, xml, or text and parsed.
         * An Object implies an inline configuration which has a single
         *      property sufficient for being able to determine tileSource
         *      implementation. If the object has a property which is a function
         *      named 'getTileUrl', it is treated as a custom TileSource.
         * @param {Number} [options.index] The index of the item. Added on top of
         * all other items if not specified.
         * @param {Boolean} [options.replace=false] If true, the item at options.index will be
         * removed and the new item is added in its place. options.tileSource will be
         * interpreted and fetched if necessary before the old item is removed to avoid leaving
         * a gap in the world.
         * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
         * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
         * @param {Number} [options.width=1] The width for the image in viewport coordinates.
         * @param {Number} [options.height] The height for the image in viewport coordinates.
         * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
         * to fit the image into. If specified, x, y, width and height get ignored.
         * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
         * How to anchor the image in the bounds if options.fitBounds is set.
         * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
         * (portions of the image outside of this area will not be visible). Only works on
         * browsers that support the HTML5 canvas.
         * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
         * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
         * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
         * its top left corner in degrees.
         * @param {Boolean} [options.flipped=false] Whether to horizontally flip the image.
         * @param {String} [options.compositeOperation] How the image is composited onto other images.
         * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
         * overriding viewer.crossOriginPolicy.
         * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
         * @param {Boolean} [options.loadTilesWithAjax]
         *      Whether to load tile data using AJAX requests.
         *      Defaults to the setting in {@link OpenSeadragon.Options}.
         * @param {Object} [options.ajaxHeaders]
         *      A set of headers to include when making tile AJAX requests.
         *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
         *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
         * @param {Function} [options.success] A function that gets called when the image is
         * successfully added. It's passed the event object which contains a single property:
         * "item", which is the resulting instance of TiledImage.
         * @param {Function} [options.error] A function that gets called if the image is
         * unable to be added. It's passed the error event object, which contains "message"
         * and "source" properties.
         * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
         * specifies whether to snap to the new arrangement immediately or to animate to it.
         * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
         * @fires OpenSeadragon.World.event:add-item
         * @fires OpenSeadragon.Viewer.event:add-item-failed
         */
        addTiledImage: function(options) {
          $2.console.assert(options, "[Viewer.addTiledImage] options is required");
          $2.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
          $2.console.assert(
            !options.replace || options.index > -1 && options.index < this.world.getItemCount(),
            "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world"
          );
          var _this = this;
          if (options.replace) {
            options.replaceItem = _this.world.getItemAt(options.index);
          }
          this._hideMessage();
          if (options.placeholderFillStyle === void 0) {
            options.placeholderFillStyle = this.placeholderFillStyle;
          }
          if (options.opacity === void 0) {
            options.opacity = this.opacity;
          }
          if (options.preload === void 0) {
            options.preload = this.preload;
          }
          if (options.compositeOperation === void 0) {
            options.compositeOperation = this.compositeOperation;
          }
          if (options.crossOriginPolicy === void 0) {
            options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== void 0 ? options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
          }
          if (options.ajaxWithCredentials === void 0) {
            options.ajaxWithCredentials = this.ajaxWithCredentials;
          }
          if (options.loadTilesWithAjax === void 0) {
            options.loadTilesWithAjax = this.loadTilesWithAjax;
          }
          if (!$2.isPlainObject(options.ajaxHeaders)) {
            options.ajaxHeaders = {};
          }
          var myQueueItem = {
            options
          };
          function raiseAddItemFailed(event) {
            for (var i = 0; i < _this._loadQueue.length; i++) {
              if (_this._loadQueue[i] === myQueueItem) {
                _this._loadQueue.splice(i, 1);
                break;
              }
            }
            if (_this._loadQueue.length === 0) {
              refreshWorld(myQueueItem);
            }
            _this.raiseEvent("add-item-failed", event);
            if (options.error) {
              options.error(event);
            }
          }
          function refreshWorld(theItem) {
            if (_this.collectionMode) {
              _this.world.arrange({
                immediately: theItem.options.collectionImmediately,
                rows: _this.collectionRows,
                columns: _this.collectionColumns,
                layout: _this.collectionLayout,
                tileSize: _this.collectionTileSize,
                tileMargin: _this.collectionTileMargin
              });
              _this.world.setAutoRefigureSizes(true);
            }
          }
          if ($2.isArray(options.tileSource)) {
            setTimeout(function() {
              raiseAddItemFailed({
                message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                source: options.tileSource,
                options
              });
            });
            return;
          }
          this._loadQueue.push(myQueueItem);
          function processReadyItems() {
            var queueItem, tiledImage, optionsClone;
            while (_this._loadQueue.length) {
              queueItem = _this._loadQueue[0];
              if (!queueItem.tileSource) {
                break;
              }
              _this._loadQueue.splice(0, 1);
              if (queueItem.options.replace) {
                var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);
                if (newIndex !== -1) {
                  queueItem.options.index = newIndex;
                }
                _this.world.removeItem(queueItem.options.replaceItem);
              }
              tiledImage = new $2.TiledImage({
                viewer: _this,
                source: queueItem.tileSource,
                viewport: _this.viewport,
                drawer: _this.drawer,
                tileCache: _this.tileCache,
                imageLoader: _this.imageLoader,
                x: queueItem.options.x,
                y: queueItem.options.y,
                width: queueItem.options.width,
                height: queueItem.options.height,
                fitBounds: queueItem.options.fitBounds,
                fitBoundsPlacement: queueItem.options.fitBoundsPlacement,
                clip: queueItem.options.clip,
                placeholderFillStyle: queueItem.options.placeholderFillStyle,
                opacity: queueItem.options.opacity,
                preload: queueItem.options.preload,
                degrees: queueItem.options.degrees,
                flipped: queueItem.options.flipped,
                compositeOperation: queueItem.options.compositeOperation,
                springStiffness: _this.springStiffness,
                animationTime: _this.animationTime,
                minZoomImageRatio: _this.minZoomImageRatio,
                wrapHorizontal: _this.wrapHorizontal,
                wrapVertical: _this.wrapVertical,
                immediateRender: _this.immediateRender,
                blendTime: _this.blendTime,
                alwaysBlend: _this.alwaysBlend,
                minPixelRatio: _this.minPixelRatio,
                smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,
                iOSDevice: _this.iOSDevice,
                crossOriginPolicy: queueItem.options.crossOriginPolicy,
                ajaxWithCredentials: queueItem.options.ajaxWithCredentials,
                loadTilesWithAjax: queueItem.options.loadTilesWithAjax,
                ajaxHeaders: queueItem.options.ajaxHeaders,
                debugMode: _this.debugMode,
                subPixelRoundingForTransparency: _this.subPixelRoundingForTransparency
              });
              if (_this.collectionMode) {
                _this.world.setAutoRefigureSizes(false);
              }
              if (_this.navigator) {
                optionsClone = $2.extend({}, queueItem.options, {
                  replace: false,
                  // navigator already removed the layer, nothing to replace
                  originalTiledImage: tiledImage,
                  tileSource: queueItem.tileSource
                });
                _this.navigator.addTiledImage(optionsClone);
              }
              _this.world.addItem(tiledImage, {
                index: queueItem.options.index
              });
              if (_this._loadQueue.length === 0) {
                refreshWorld(queueItem);
              }
              if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {
                _this.viewport.goHome(true);
              }
              if (queueItem.options.success) {
                queueItem.options.success({
                  item: tiledImage
                });
              }
            }
          }
          getTileSourceImplementation(this, options.tileSource, options, function(tileSource) {
            myQueueItem.tileSource = tileSource;
            processReadyItems();
          }, function(event) {
            event.options = options;
            raiseAddItemFailed(event);
            processReadyItems();
          });
        },
        /**
         * Add a simple image to the viewer.
         * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
         * except for options.tileSource which is replaced by options.url.
         * @function
         * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
         * for all the options
         * @param {String} options.url - The URL of the image to add.
         * @fires OpenSeadragon.World.event:add-item
         * @fires OpenSeadragon.Viewer.event:add-item-failed
         */
        addSimpleImage: function(options) {
          $2.console.assert(options, "[Viewer.addSimpleImage] options is required");
          $2.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");
          var opts = $2.extend({}, options, {
            tileSource: {
              type: "image",
              url: options.url
            }
          });
          delete opts.url;
          this.addTiledImage(opts);
        },
        // deprecated
        addLayer: function(options) {
          var _this = this;
          $2.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
          var optionsClone = $2.extend({}, options, {
            success: function(event) {
              _this.raiseEvent("add-layer", {
                options,
                drawer: event.item
              });
            },
            error: function(event) {
              _this.raiseEvent("add-layer-failed", event);
            }
          });
          this.addTiledImage(optionsClone);
          return this;
        },
        // deprecated
        getLayerAtLevel: function(level) {
          $2.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead.");
          return this.world.getItemAt(level);
        },
        // deprecated
        getLevelOfLayer: function(drawer) {
          $2.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead.");
          return this.world.getIndexOfItem(drawer);
        },
        // deprecated
        getLayersCount: function() {
          $2.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead.");
          return this.world.getItemCount();
        },
        // deprecated
        setLayerLevel: function(drawer, level) {
          $2.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead.");
          return this.world.setItemIndex(drawer, level);
        },
        // deprecated
        removeLayer: function(drawer) {
          $2.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead.");
          return this.world.removeItem(drawer);
        },
        /**
         * Force the viewer to redraw its contents.
         * @returns {OpenSeadragon.Viewer} Chainable.
         */
        forceRedraw: function() {
          THIS[this.hash].forceRedraw = true;
          return this;
        },
        /**
         * Force the viewer to reset its size to match its container.
         */
        forceResize: function() {
          THIS[this.hash].needsResize = true;
          THIS[this.hash].forceResize = true;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         */
        bindSequenceControls: function() {
          var onFocusHandler = $2.delegate(this, onFocus), onBlurHandler = $2.delegate(this, onBlur), onNextHandler = $2.delegate(this, this.goToNextPage), onPreviousHandler = $2.delegate(this, this.goToPreviousPage), navImages = this.navImages, useGroup = true;
          if (this.showSequenceControl) {
            if (this.previousButton || this.nextButton) {
              useGroup = false;
            }
            this.previousButton = new $2.Button({
              element: this.previousButton ? $2.getElement(this.previousButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $2.getString("Tooltips.PreviousPage"),
              srcRest: resolveUrl(this.prefixUrl, navImages.previous.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.previous.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.previous.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.previous.DOWN),
              onRelease: onPreviousHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            });
            this.nextButton = new $2.Button({
              element: this.nextButton ? $2.getElement(this.nextButton) : null,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              tooltip: $2.getString("Tooltips.NextPage"),
              srcRest: resolveUrl(this.prefixUrl, navImages.next.REST),
              srcGroup: resolveUrl(this.prefixUrl, navImages.next.GROUP),
              srcHover: resolveUrl(this.prefixUrl, navImages.next.HOVER),
              srcDown: resolveUrl(this.prefixUrl, navImages.next.DOWN),
              onRelease: onNextHandler,
              onFocus: onFocusHandler,
              onBlur: onBlurHandler
            });
            if (!this.navPrevNextWrap) {
              this.previousButton.disable();
            }
            if (!this.tileSources || !this.tileSources.length) {
              this.nextButton.disable();
            }
            if (useGroup) {
              this.paging = new $2.ButtonGroup({
                buttons: [
                  this.previousButton,
                  this.nextButton
                ],
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold
              });
              this.pagingControl = this.paging.element;
              if (this.toolbar) {
                this.toolbar.addControl(
                  this.pagingControl,
                  { anchor: $2.ControlAnchor.BOTTOM_RIGHT }
                );
              } else {
                this.addControl(
                  this.pagingControl,
                  { anchor: this.sequenceControlAnchor || $2.ControlAnchor.TOP_LEFT }
                );
              }
            }
          }
          return this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         */
        bindStandardControls: function() {
          var beginZoomingInHandler = $2.delegate(this, beginZoomingIn), endZoomingHandler = $2.delegate(this, endZooming), doSingleZoomInHandler = $2.delegate(this, doSingleZoomIn), beginZoomingOutHandler = $2.delegate(this, beginZoomingOut), doSingleZoomOutHandler = $2.delegate(this, doSingleZoomOut), onHomeHandler = $2.delegate(this, onHome), onFullScreenHandler = $2.delegate(this, onFullScreen), onRotateLeftHandler = $2.delegate(this, onRotateLeft), onRotateRightHandler = $2.delegate(this, onRotateRight), onFlipHandler = $2.delegate(this, onFlip), onFocusHandler = $2.delegate(this, onFocus), onBlurHandler = $2.delegate(this, onBlur), navImages = this.navImages, buttons = [], useGroup = true;
          if (this.showNavigationControl) {
            if (this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) {
              useGroup = false;
            }
            if (this.showZoomControl) {
              buttons.push(this.zoomInButton = new $2.Button({
                element: this.zoomInButton ? $2.getElement(this.zoomInButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.ZoomIn"),
                srcRest: resolveUrl(this.prefixUrl, navImages.zoomIn.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.zoomIn.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.zoomIn.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.zoomIn.DOWN),
                onPress: beginZoomingInHandler,
                onRelease: endZoomingHandler,
                onClick: doSingleZoomInHandler,
                onEnter: beginZoomingInHandler,
                onExit: endZoomingHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              }));
              buttons.push(this.zoomOutButton = new $2.Button({
                element: this.zoomOutButton ? $2.getElement(this.zoomOutButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.ZoomOut"),
                srcRest: resolveUrl(this.prefixUrl, navImages.zoomOut.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.zoomOut.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.zoomOut.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.zoomOut.DOWN),
                onPress: beginZoomingOutHandler,
                onRelease: endZoomingHandler,
                onClick: doSingleZoomOutHandler,
                onEnter: beginZoomingOutHandler,
                onExit: endZoomingHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              }));
            }
            if (this.showHomeControl) {
              buttons.push(this.homeButton = new $2.Button({
                element: this.homeButton ? $2.getElement(this.homeButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.Home"),
                srcRest: resolveUrl(this.prefixUrl, navImages.home.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.home.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.home.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.home.DOWN),
                onRelease: onHomeHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              }));
            }
            if (this.showFullPageControl) {
              buttons.push(this.fullPageButton = new $2.Button({
                element: this.fullPageButton ? $2.getElement(this.fullPageButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.FullPage"),
                srcRest: resolveUrl(this.prefixUrl, navImages.fullpage.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.fullpage.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.fullpage.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.fullpage.DOWN),
                onRelease: onFullScreenHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              }));
            }
            if (this.showRotationControl) {
              buttons.push(this.rotateLeftButton = new $2.Button({
                element: this.rotateLeftButton ? $2.getElement(this.rotateLeftButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.RotateLeft"),
                srcRest: resolveUrl(this.prefixUrl, navImages.rotateleft.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.rotateleft.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.rotateleft.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.rotateleft.DOWN),
                onRelease: onRotateLeftHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              }));
              buttons.push(this.rotateRightButton = new $2.Button({
                element: this.rotateRightButton ? $2.getElement(this.rotateRightButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.RotateRight"),
                srcRest: resolveUrl(this.prefixUrl, navImages.rotateright.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.rotateright.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.rotateright.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.rotateright.DOWN),
                onRelease: onRotateRightHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              }));
            }
            if (this.showFlipControl) {
              buttons.push(this.flipButton = new $2.Button({
                element: this.flipButton ? $2.getElement(this.flipButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $2.getString("Tooltips.Flip"),
                srcRest: resolveUrl(this.prefixUrl, navImages.flip.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.flip.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.flip.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.flip.DOWN),
                onRelease: onFlipHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              }));
            }
            if (useGroup) {
              this.buttonGroup = new $2.ButtonGroup({
                buttons,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold
              });
              this.navControl = this.buttonGroup.element;
              this.addHandler("open", $2.delegate(this, lightUp));
              if (this.toolbar) {
                this.toolbar.addControl(
                  this.navControl,
                  { anchor: this.navigationControlAnchor || $2.ControlAnchor.TOP_LEFT }
                );
              } else {
                this.addControl(
                  this.navControl,
                  { anchor: this.navigationControlAnchor || $2.ControlAnchor.TOP_LEFT }
                );
              }
            } else {
              this.customButtons = buttons;
            }
          }
          return this;
        },
        /**
         * Gets the active page of a sequence
         * @function
         * @returns {Number}
         */
        currentPage: function() {
          return this._sequenceIndex;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:page
         */
        goToPage: function(page) {
          if (this.tileSources && page >= 0 && page < this.tileSources.length) {
            this._sequenceIndex = page;
            this._updateSequenceButtons(page);
            this.open(this.tileSources[page]);
            if (this.referenceStrip) {
              this.referenceStrip.setFocus(page);
            }
            this.raiseEvent("page", { page });
          }
          return this;
        },
        /**
          * Adds an html element as an overlay to the current viewport.  Useful for
          * highlighting words or areas of interest on an image or other zoomable
          * interface. The overlays added via this method are removed when the viewport
          * is closed which include when changing page.
          * @method
          * @param {Element|String|Object} element - A reference to an element or an id for
          *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
          *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
          *      all available options.
          * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
          *      rectangle which will be overlaid. This is a viewport relative location.
          * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
          *      viewport which the location coordinates will be treated as relative
          *      to.
          * @param {function} [onDraw] - If supplied the callback is called when the overlay
          *      needs to be drawn. It it the responsibility of the callback to do any drawing/positioning.
          *      It is passed position, size and element.
          * @returns {OpenSeadragon.Viewer} Chainable.
          * @fires OpenSeadragon.Viewer.event:add-overlay
          */
        addOverlay: function(element, location, placement, onDraw) {
          var options;
          if ($2.isPlainObject(element)) {
            options = element;
          } else {
            options = {
              element,
              location,
              placement,
              onDraw
            };
          }
          element = $2.getElement(options.element);
          if (getOverlayIndex(this.currentOverlays, element) >= 0) {
            return this;
          }
          var overlay = getOverlayObject(this, options);
          this.currentOverlays.push(overlay);
          overlay.drawHTML(this.overlaysContainer, this.viewport);
          this.raiseEvent("add-overlay", {
            element,
            location: options.location,
            placement: options.placement
          });
          return this;
        },
        /**
         * Updates the overlay represented by the reference to the element or
         * element id moving it to the new location, relative to the new placement.
         * @method
         * @param {Element|String} element - A reference to an element or an id for
         *      the element which is overlaid.
         * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
         *      rectangle which will be overlaid. This is a viewport relative location.
         * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
         *      viewport which the location coordinates will be treated as relative
         *      to.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:update-overlay
         */
        updateOverlay: function(element, location, placement) {
          var i;
          element = $2.getElement(element);
          i = getOverlayIndex(this.currentOverlays, element);
          if (i >= 0) {
            this.currentOverlays[i].update(location, placement);
            THIS[this.hash].forceRedraw = true;
            this.raiseEvent("update-overlay", {
              element,
              location,
              placement
            });
          }
          return this;
        },
        /**
         * Removes an overlay identified by the reference element or element id
         * and schedules an update.
         * @method
         * @param {Element|String} element - A reference to the element or an
         *      element id which represent the ovelay content to be removed.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:remove-overlay
         */
        removeOverlay: function(element) {
          var i;
          element = $2.getElement(element);
          i = getOverlayIndex(this.currentOverlays, element);
          if (i >= 0) {
            this.currentOverlays[i].destroy();
            this.currentOverlays.splice(i, 1);
            THIS[this.hash].forceRedraw = true;
            this.raiseEvent("remove-overlay", {
              element
            });
          }
          return this;
        },
        /**
         * Removes all currently configured Overlays from this Viewer and schedules
         * an update.
         * @method
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:clear-overlay
         */
        clearOverlays: function() {
          while (this.currentOverlays.length > 0) {
            this.currentOverlays.pop().destroy();
          }
          THIS[this.hash].forceRedraw = true;
          this.raiseEvent("clear-overlay", {});
          return this;
        },
        /**
        * Finds an overlay identified by the reference element or element id
        * and returns it as an object, return null if not found.
        * @method
        * @param {Element|String} element - A reference to the element or an
        *      element id which represents the overlay content.
        * @returns {OpenSeadragon.Overlay} the matching overlay or null if none found.
        */
        getOverlayById: function(element) {
          var i;
          element = $2.getElement(element);
          i = getOverlayIndex(this.currentOverlays, element);
          if (i >= 0) {
            return this.currentOverlays[i];
          } else {
            return null;
          }
        },
        /**
         * Updates the sequence buttons.
         * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
         * @private
         * @param {Number} Sequence Value
         */
        _updateSequenceButtons: function(page) {
          if (this.nextButton) {
            if (!this.tileSources || this.tileSources.length - 1 === page) {
              if (!this.navPrevNextWrap) {
                this.nextButton.disable();
              }
            } else {
              this.nextButton.enable();
            }
          }
          if (this.previousButton) {
            if (page > 0) {
              this.previousButton.enable();
            } else {
              if (!this.navPrevNextWrap) {
                this.previousButton.disable();
              }
            }
          }
        },
        /**
         * Display a message in the viewport
         * @function OpenSeadragon.Viewer.prototype._showMessage
         * @private
         * @param {String} text message
         */
        _showMessage: function(message) {
          this._hideMessage();
          var div = $2.makeNeutralElement("div");
          div.appendChild(document.createTextNode(message));
          this.messageDiv = $2.makeCenteredNode(div);
          $2.addClass(this.messageDiv, "openseadragon-message");
          this.container.appendChild(this.messageDiv);
        },
        /**
         * Hide any currently displayed viewport message
         * @function OpenSeadragon.Viewer.prototype._hideMessage
         * @private
         */
        _hideMessage: function() {
          var div = this.messageDiv;
          if (div) {
            div.parentNode.removeChild(div);
            delete this.messageDiv;
          }
        },
        /**
         * Gets this viewer's gesture settings for the given pointer device type.
         * @method
         * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
         * @returns {OpenSeadragon.GestureSettings}
         */
        gestureSettingsByDeviceType: function(type) {
          switch (type) {
            case "mouse":
              return this.gestureSettingsMouse;
            case "touch":
              return this.gestureSettingsTouch;
            case "pen":
              return this.gestureSettingsPen;
            default:
              return this.gestureSettingsUnknown;
          }
        },
        // private
        _drawOverlays: function() {
          var i, length = this.currentOverlays.length;
          for (i = 0; i < length; i++) {
            this.currentOverlays[i].drawHTML(this.overlaysContainer, this.viewport);
          }
        },
        /**
         * Cancel the "in flight" images.
         */
        _cancelPendingImages: function() {
          this._loadQueue = [];
        },
        /**
         * Removes the reference strip and disables displaying it.
         * @function
         */
        removeReferenceStrip: function() {
          this.showReferenceStrip = false;
          if (this.referenceStrip) {
            this.referenceStrip.destroy();
            this.referenceStrip = null;
          }
        },
        /**
         * Enables and displays the reference strip based on the currently set tileSources.
         * Works only when the Viewer has sequenceMode set to true.
         * @function
         */
        addReferenceStrip: function() {
          this.showReferenceStrip = true;
          if (this.sequenceMode) {
            if (this.referenceStrip) {
              return;
            }
            if (this.tileSources.length && this.tileSources.length > 1) {
              this.referenceStrip = new $2.ReferenceStrip({
                id: this.referenceStripElement,
                position: this.referenceStripPosition,
                sizeRatio: this.referenceStripSizeRatio,
                scroll: this.referenceStripScroll,
                height: this.referenceStripHeight,
                width: this.referenceStripWidth,
                tileSources: this.tileSources,
                prefixUrl: this.prefixUrl,
                useCanvas: this.useCanvas,
                viewer: this
              });
              this.referenceStrip.setFocus(this._sequenceIndex);
            }
          } else {
            $2.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
          }
        },
        /**
         * Adds _updatePixelDensityRatio to the window resize event.
         * @private
         */
        _addUpdatePixelDensityRatioEvent: function() {
          this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this);
          $2.addEvent(window, "resize", this._updatePixelDensityRatioBind);
        },
        /**
         * Removes _updatePixelDensityRatio from the window resize event.
         * @private
         */
        _removeUpdatePixelDensityRatioEvent: function() {
          $2.removeEvent(window, "resize", this._updatePixelDensityRatioBind);
        },
        /**
         * Update pixel density ratio, clears all tiles and triggers updates for
         * all items if the ratio has changed.
         * @private
         */
        _updatePixelDensityRatio: function() {
          var previusPixelDensityRatio = $2.pixelDensityRatio;
          var currentPixelDensityRatio = $2.getCurrentPixelDensityRatio();
          if (previusPixelDensityRatio !== currentPixelDensityRatio) {
            $2.pixelDensityRatio = currentPixelDensityRatio;
            this.world.resetItems();
            this.forceRedraw();
          }
        },
        /**
         * Sets the image source to the source with index equal to
         * currentIndex - 1. Changes current image in sequence mode.
         * If specified, wraps around (see navPrevNextWrap in
         * {@link OpenSeadragon.Options})
         *
         * @method
         */
        goToPreviousPage: function() {
          var previous = this._sequenceIndex - 1;
          if (this.navPrevNextWrap && previous < 0) {
            previous += this.tileSources.length;
          }
          this.goToPage(previous);
        },
        /**
         * Sets the image source to the source with index equal to
         * currentIndex + 1. Changes current image in sequence mode.
         * If specified, wraps around (see navPrevNextWrap in
         * {@link OpenSeadragon.Options})
         *
         * @method
         */
        goToNextPage: function() {
          var next = this._sequenceIndex + 1;
          if (this.navPrevNextWrap && next >= this.tileSources.length) {
            next = 0;
          }
          this.goToPage(next);
        },
        isAnimating: function() {
          return THIS[this.hash].animating;
        }
      }
    );
    function _getSafeElemSize(oElement) {
      oElement = $2.getElement(oElement);
      return new $2.Point(
        oElement.clientWidth === 0 ? 1 : oElement.clientWidth,
        oElement.clientHeight === 0 ? 1 : oElement.clientHeight
      );
    }
    function getTileSourceImplementation(viewer, tileSource, imgOptions, successCallback, failCallback) {
      var _this = viewer;
      if ($2.type(tileSource) === "string") {
        if (tileSource.match(/^\s*<.*>\s*$/)) {
          tileSource = $2.parseXml(tileSource);
        } else if (tileSource.match(/^\s*[{[].*[}\]]\s*$/)) {
          try {
            var tileSourceJ = $2.parseJSON(tileSource);
            tileSource = tileSourceJ;
          } catch (e) {
          }
        }
      }
      function waitUntilReady(tileSource2, originalTileSource) {
        if (tileSource2.ready) {
          successCallback(tileSource2);
        } else {
          tileSource2.addHandler("ready", function() {
            successCallback(tileSource2);
          });
          tileSource2.addHandler("open-failed", function(event) {
            failCallback({
              message: event.message,
              source: originalTileSource
            });
          });
        }
      }
      setTimeout(function() {
        if ($2.type(tileSource) === "string") {
          tileSource = new $2.TileSource({
            url: tileSource,
            crossOriginPolicy: imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy,
            ajaxWithCredentials: viewer.ajaxWithCredentials,
            ajaxHeaders: imgOptions.ajaxHeaders ? imgOptions.ajaxHeaders : viewer.ajaxHeaders,
            splitHashDataForPost: viewer.splitHashDataForPost,
            useCanvas: viewer.useCanvas,
            success: function(event) {
              successCallback(event.tileSource);
            }
          });
          tileSource.addHandler("open-failed", function(event) {
            failCallback(event);
          });
        } else if ($2.isPlainObject(tileSource) || tileSource.nodeType) {
          if (tileSource.crossOriginPolicy === void 0 && (imgOptions.crossOriginPolicy !== void 0 || viewer.crossOriginPolicy !== void 0)) {
            tileSource.crossOriginPolicy = imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy;
          }
          if (tileSource.ajaxWithCredentials === void 0) {
            tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
          }
          if (tileSource.useCanvas === void 0) {
            tileSource.useCanvas = viewer.useCanvas;
          }
          if ($2.isFunction(tileSource.getTileUrl)) {
            var customTileSource = new $2.TileSource(tileSource);
            customTileSource.getTileUrl = tileSource.getTileUrl;
            successCallback(customTileSource);
          } else {
            var $TileSource = $2.TileSource.determineType(_this, tileSource);
            if (!$TileSource) {
              failCallback({
                message: "Unable to load TileSource",
                source: tileSource
              });
              return;
            }
            var options = $TileSource.prototype.configure.apply(_this, [tileSource]);
            waitUntilReady(new $TileSource(options), tileSource);
          }
        } else {
          waitUntilReady(tileSource, tileSource);
        }
      });
    }
    function getOverlayObject(viewer, overlay) {
      if (overlay instanceof $2.Overlay) {
        return overlay;
      }
      var element = null;
      if (overlay.element) {
        element = $2.getElement(overlay.element);
      } else {
        var id = overlay.id ? overlay.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
        element = $2.getElement(overlay.id);
        if (!element) {
          element = document.createElement("a");
          element.href = "#/overlay/" + id;
        }
        element.id = id;
        $2.addClass(
          element,
          overlay.className ? overlay.className : "openseadragon-overlay"
        );
      }
      var location = overlay.location;
      var width = overlay.width;
      var height = overlay.height;
      if (!location) {
        var x2 = overlay.x;
        var y = overlay.y;
        if (overlay.px !== void 0) {
          var rect = viewer.viewport.imageToViewportRectangle(new $2.Rect(
            overlay.px,
            overlay.py,
            width || 0,
            height || 0
          ));
          x2 = rect.x;
          y = rect.y;
          width = width !== void 0 ? rect.width : void 0;
          height = height !== void 0 ? rect.height : void 0;
        }
        location = new $2.Point(x2, y);
      }
      var placement = overlay.placement;
      if (placement && $2.type(placement) === "string") {
        placement = $2.Placement[overlay.placement.toUpperCase()];
      }
      return new $2.Overlay({
        element,
        location,
        placement,
        onDraw: overlay.onDraw,
        checkResize: overlay.checkResize,
        width,
        height,
        rotationMode: overlay.rotationMode
      });
    }
    function getOverlayIndex(overlays, element) {
      var i;
      for (i = overlays.length - 1; i >= 0; i--) {
        if (overlays[i].element === element) {
          return i;
        }
      }
      return -1;
    }
    function scheduleUpdate(viewer, updateFunc) {
      return $2.requestAnimationFrame(function() {
        updateFunc(viewer);
      });
    }
    function scheduleControlsFade(viewer) {
      $2.requestAnimationFrame(function() {
        updateControlsFade(viewer);
      });
    }
    function beginControlsAutoHide(viewer) {
      if (!viewer.autoHideControls) {
        return;
      }
      viewer.controlsShouldFade = true;
      viewer.controlsFadeBeginTime = $2.now() + viewer.controlsFadeDelay;
      window.setTimeout(function() {
        scheduleControlsFade(viewer);
      }, viewer.controlsFadeDelay);
    }
    function updateControlsFade(viewer) {
      var currentTime, deltaTime, opacity, i;
      if (viewer.controlsShouldFade) {
        currentTime = $2.now();
        deltaTime = currentTime - viewer.controlsFadeBeginTime;
        opacity = 1 - deltaTime / viewer.controlsFadeLength;
        opacity = Math.min(1, opacity);
        opacity = Math.max(0, opacity);
        for (i = viewer.controls.length - 1; i >= 0; i--) {
          if (viewer.controls[i].autoFade) {
            viewer.controls[i].setOpacity(opacity);
          }
        }
        if (opacity > 0) {
          scheduleControlsFade(viewer);
        }
      }
    }
    function abortControlsAutoHide(viewer) {
      var i;
      viewer.controlsShouldFade = false;
      for (i = viewer.controls.length - 1; i >= 0; i--) {
        viewer.controls[i].setOpacity(1);
      }
    }
    function onFocus() {
      abortControlsAutoHide(this);
    }
    function onBlur() {
      beginControlsAutoHide(this);
    }
    function onCanvasContextMenu(event) {
      var eventArgs = {
        tracker: event.eventSource,
        position: event.position,
        originalEvent: event.originalEvent,
        preventDefault: event.preventDefault
      };
      this.raiseEvent("canvas-contextmenu", eventArgs);
      event.preventDefault = eventArgs.preventDefault;
    }
    function onCanvasKeyDown(event) {
      var canvasKeyDownEventArgs = {
        originalEvent: event.originalEvent,
        preventDefaultAction: false,
        preventVerticalPan: event.preventVerticalPan || !this.panVertical,
        preventHorizontalPan: event.preventHorizontalPan || !this.panHorizontal
      };
      this.raiseEvent("canvas-key", canvasKeyDownEventArgs);
      if (!canvasKeyDownEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
        switch (event.keyCode) {
          case 38:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(1.1);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, -this.pixelsPerArrowPress)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 40:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(0.9);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, this.pixelsPerArrowPress)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 37:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(-this.pixelsPerArrowPress, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 39:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(this.pixelsPerArrowPress, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 187:
            this.viewport.zoomBy(1.1);
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 189:
            this.viewport.zoomBy(0.9);
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 48:
            this.viewport.goHome();
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 87:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(1.1);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, -40)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 83:
            if (!canvasKeyDownEventArgs.preventVerticalPan) {
              if (event.shift) {
                this.viewport.zoomBy(0.9);
              } else {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(0, 40)));
              }
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 65:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(-40, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 68:
            if (!canvasKeyDownEventArgs.preventHorizontalPan) {
              this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $2.Point(40, 0)));
              this.viewport.applyConstraints();
            }
            event.preventDefault = true;
            break;
          case 82:
            if (event.shift) {
              if (this.viewport.flipped) {
                this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
              } else {
                this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
              }
            } else {
              if (this.viewport.flipped) {
                this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
              } else {
                this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
              }
            }
            this.viewport.applyConstraints();
            event.preventDefault = true;
            break;
          case 70:
            this.viewport.toggleFlip();
            event.preventDefault = true;
            break;
          case 74:
            this.goToPreviousPage();
            break;
          case 75:
            this.goToNextPage();
            break;
          default:
            event.preventDefault = false;
            break;
        }
      } else {
        event.preventDefault = false;
      }
    }
    function onCanvasKeyPress(event) {
      var canvasKeyPressEventArgs = {
        originalEvent: event.originalEvent
      };
      this.raiseEvent("canvas-key-press", canvasKeyPressEventArgs);
    }
    function onCanvasClick(event) {
      var gestureSettings;
      var haveKeyboardFocus = document.activeElement === this.canvas;
      if (!haveKeyboardFocus) {
        this.canvas.focus();
      }
      if (this.viewport.flipped) {
        event.position.x = this.viewport.getContainerSize().x - event.position.x;
      }
      var canvasClickEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        quick: event.quick,
        shift: event.shift,
        originalEvent: event.originalEvent,
        originalTarget: event.originalTarget,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-click", canvasClickEventArgs);
      if (!canvasClickEventArgs.preventDefaultAction && this.viewport && event.quick) {
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (gestureSettings.clickToZoom === true) {
          this.viewport.zoomBy(
            event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
            gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
          );
          this.viewport.applyConstraints();
        }
        if (gestureSettings.dblClickDragToZoom) {
          if (THIS[this.hash].draggingToZoom === true) {
            THIS[this.hash].lastClickTime = null;
            THIS[this.hash].draggingToZoom = false;
          } else {
            THIS[this.hash].lastClickTime = $2.now();
          }
        }
      }
    }
    function onCanvasDblClick(event) {
      var gestureSettings;
      var canvasDblClickEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-double-click", canvasDblClickEventArgs);
      if (!canvasDblClickEventArgs.preventDefaultAction && this.viewport) {
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (gestureSettings.dblClickToZoom) {
          this.viewport.zoomBy(
            event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
            gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
          );
          this.viewport.applyConstraints();
        }
      }
    }
    function onCanvasDrag(event) {
      var gestureSettings;
      var canvasDragEventArgs = {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        delta: event.delta,
        speed: event.speed,
        direction: event.direction,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-drag", canvasDragEventArgs);
      gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
      if (!canvasDragEventArgs.preventDefaultAction && this.viewport) {
        if (gestureSettings.dblClickDragToZoom && THIS[this.hash].draggingToZoom) {
          var factor = Math.pow(this.zoomPerDblClickDrag, event.delta.y / 50);
          this.viewport.zoomBy(factor);
        } else if (gestureSettings.dragToPan && !THIS[this.hash].draggingToZoom) {
          if (!this.panHorizontal) {
            event.delta.x = 0;
          }
          if (!this.panVertical) {
            event.delta.y = 0;
          }
          if (this.viewport.flipped) {
            event.delta.x = -event.delta.x;
          }
          if (this.constrainDuringPan) {
            var delta = this.viewport.deltaPointsFromPixels(event.delta.negate());
            this.viewport.centerSpringX.target.value += delta.x;
            this.viewport.centerSpringY.target.value += delta.y;
            var constrainedBounds = this.viewport.getConstrainedBounds();
            this.viewport.centerSpringX.target.value -= delta.x;
            this.viewport.centerSpringY.target.value -= delta.y;
            if (constrainedBounds.xConstrained) {
              event.delta.x = 0;
            }
            if (constrainedBounds.yConstrained) {
              event.delta.y = 0;
            }
          }
          this.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta.negate()), gestureSettings.flickEnabled && !this.constrainDuringPan);
        }
      }
    }
    function onCanvasDragEnd(event) {
      var gestureSettings;
      var canvasDragEndEventArgs = {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        speed: event.speed,
        direction: event.direction,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.raiseEvent("canvas-drag-end", canvasDragEndEventArgs);
      gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
      if (!canvasDragEndEventArgs.preventDefaultAction && this.viewport) {
        if (!THIS[this.hash].draggingToZoom && gestureSettings.flickEnabled && event.speed >= gestureSettings.flickMinSpeed) {
          var amplitudeX = 0;
          if (this.panHorizontal) {
            amplitudeX = gestureSettings.flickMomentum * event.speed * Math.cos(event.direction);
          }
          var amplitudeY = 0;
          if (this.panVertical) {
            amplitudeY = gestureSettings.flickMomentum * event.speed * Math.sin(event.direction);
          }
          var center = this.viewport.pixelFromPoint(
            this.viewport.getCenter(true)
          );
          var target = this.viewport.pointFromPixel(
            new $2.Point(center.x - amplitudeX, center.y - amplitudeY)
          );
          this.viewport.panTo(target, false);
        }
        this.viewport.applyConstraints();
      }
      if (gestureSettings.dblClickDragToZoom && THIS[this.hash].draggingToZoom === true) {
        THIS[this.hash].draggingToZoom = false;
      }
    }
    function onCanvasEnter(event) {
      this.raiseEvent("canvas-enter", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasLeave(event) {
      this.raiseEvent("canvas-exit", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasPress(event) {
      var gestureSettings;
      this.raiseEvent("canvas-press", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        insideElementPressed: event.insideElementPressed,
        insideElementReleased: event.insideElementReleased,
        originalEvent: event.originalEvent
      });
      gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
      if (gestureSettings.dblClickDragToZoom) {
        var lastClickTime = THIS[this.hash].lastClickTime;
        var currClickTime = $2.now();
        if (lastClickTime === null) {
          return;
        }
        if (currClickTime - lastClickTime < this.dblClickTimeThreshold) {
          THIS[this.hash].draggingToZoom = true;
        }
        THIS[this.hash].lastClickTime = null;
      }
    }
    function onCanvasRelease(event) {
      this.raiseEvent("canvas-release", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        insideElementPressed: event.insideElementPressed,
        insideElementReleased: event.insideElementReleased,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasNonPrimaryPress(event) {
      this.raiseEvent("canvas-nonprimary-press", {
        tracker: event.eventSource,
        position: event.position,
        pointerType: event.pointerType,
        button: event.button,
        buttons: event.buttons,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasNonPrimaryRelease(event) {
      this.raiseEvent("canvas-nonprimary-release", {
        tracker: event.eventSource,
        position: event.position,
        pointerType: event.pointerType,
        button: event.button,
        buttons: event.buttons,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasPinch(event) {
      var gestureSettings, centerPt, lastCenterPt, panByPt;
      var canvasPinchEventArgs = {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        gesturePoints: event.gesturePoints,
        lastCenter: event.lastCenter,
        center: event.center,
        lastDistance: event.lastDistance,
        distance: event.distance,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultPanAction: false,
        preventDefaultZoomAction: false,
        preventDefaultRotateAction: false
      };
      this.raiseEvent("canvas-pinch", canvasPinchEventArgs);
      if (this.viewport) {
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (gestureSettings.pinchToZoom && (!canvasPinchEventArgs.preventDefaultPanAction || !canvasPinchEventArgs.preventDefaultZoomAction)) {
          centerPt = this.viewport.pointFromPixel(event.center, true);
          if (gestureSettings.zoomToRefPoint && !canvasPinchEventArgs.preventDefaultPanAction) {
            lastCenterPt = this.viewport.pointFromPixel(event.lastCenter, true);
            panByPt = lastCenterPt.minus(centerPt);
            if (!this.panHorizontal) {
              panByPt.x = 0;
            }
            if (!this.panVertical) {
              panByPt.y = 0;
            }
            this.viewport.panBy(panByPt, true);
          }
          if (!canvasPinchEventArgs.preventDefaultZoomAction) {
            this.viewport.zoomBy(event.distance / event.lastDistance, centerPt, true);
          }
          this.viewport.applyConstraints();
        }
        if (gestureSettings.pinchRotate && !canvasPinchEventArgs.preventDefaultRotateAction) {
          var angle1 = Math.atan2(
            event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,
            event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x
          );
          var angle2 = Math.atan2(
            event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,
            event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x
          );
          centerPt = this.viewport.pointFromPixel(event.center, true);
          this.viewport.rotateTo(this.viewport.getRotation(true) + (angle1 - angle2) * (180 / Math.PI), centerPt, true);
        }
      }
    }
    function onCanvasFocus(event) {
      this.raiseEvent("canvas-focus", {
        tracker: event.eventSource,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasBlur(event) {
      this.raiseEvent("canvas-blur", {
        tracker: event.eventSource,
        originalEvent: event.originalEvent
      });
    }
    function onCanvasScroll(event) {
      var canvasScrollEventArgs, gestureSettings, factor, thisScrollTime, deltaScrollTime;
      thisScrollTime = $2.now();
      deltaScrollTime = thisScrollTime - this._lastScrollTime;
      if (deltaScrollTime > this.minScrollDeltaTime) {
        this._lastScrollTime = thisScrollTime;
        canvasScrollEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          scroll: event.scroll,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: false,
          preventDefault: true
        };
        this.raiseEvent("canvas-scroll", canvasScrollEventArgs);
        if (!canvasScrollEventArgs.preventDefaultAction && this.viewport) {
          if (this.viewport.flipped) {
            event.position.x = this.viewport.getContainerSize().x - event.position.x;
          }
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.scrollToZoom) {
            factor = Math.pow(this.zoomPerScroll, event.scroll);
            this.viewport.zoomBy(
              factor,
              gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
            );
            this.viewport.applyConstraints();
          }
        }
        event.preventDefault = canvasScrollEventArgs.preventDefault;
      } else {
        event.preventDefault = true;
      }
    }
    function onContainerEnter(event) {
      THIS[this.hash].mouseInside = true;
      abortControlsAutoHide(this);
      this.raiseEvent("container-enter", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function onContainerLeave(event) {
      if (event.pointers < 1) {
        THIS[this.hash].mouseInside = false;
        if (!THIS[this.hash].animating) {
          beginControlsAutoHide(this);
        }
      }
      this.raiseEvent("container-exit", {
        tracker: event.eventSource,
        pointerType: event.pointerType,
        position: event.position,
        buttons: event.buttons,
        pointers: event.pointers,
        insideElementPressed: event.insideElementPressed,
        buttonDownAny: event.buttonDownAny,
        originalEvent: event.originalEvent
      });
    }
    function updateMulti(viewer) {
      updateOnce(viewer);
      if (viewer.isOpen()) {
        viewer._updateRequestId = scheduleUpdate(viewer, updateMulti);
      } else {
        viewer._updateRequestId = false;
      }
    }
    function doViewerResize(viewer, containerSize) {
      var viewport = viewer.viewport;
      var zoom = viewport.getZoom();
      var center = viewport.getCenter();
      viewport.resize(containerSize, viewer.preserveImageSizeOnResize);
      viewport.panTo(center, true);
      var resizeRatio;
      if (viewer.preserveImageSizeOnResize) {
        resizeRatio = THIS[viewer.hash].prevContainerSize.x / containerSize.x;
      } else {
        var origin = new $2.Point(0, 0);
        var prevDiag = new $2.Point(THIS[viewer.hash].prevContainerSize.x, THIS[viewer.hash].prevContainerSize.y).distanceTo(origin);
        var newDiag = new $2.Point(containerSize.x, containerSize.y).distanceTo(origin);
        resizeRatio = newDiag / prevDiag * THIS[viewer.hash].prevContainerSize.x / containerSize.x;
      }
      viewport.zoomTo(zoom * resizeRatio, null, true);
      THIS[viewer.hash].prevContainerSize = containerSize;
      THIS[viewer.hash].forceRedraw = true;
      THIS[viewer.hash].needsResize = false;
      THIS[viewer.hash].forceResize = false;
    }
    function updateOnce(viewer) {
      if (viewer._opening || !THIS[viewer.hash]) {
        return;
      }
      if (viewer.autoResize || THIS[viewer.hash].forceResize) {
        var containerSize;
        if (viewer._autoResizePolling) {
          containerSize = _getSafeElemSize(viewer.container);
          var prevContainerSize = THIS[viewer.hash].prevContainerSize;
          if (!containerSize.equals(prevContainerSize)) {
            THIS[viewer.hash].needsResize = true;
          }
        }
        if (THIS[viewer.hash].needsResize) {
          doViewerResize(viewer, containerSize || _getSafeElemSize(viewer.container));
        }
      }
      var viewportChange = viewer.viewport.update();
      var animated = viewer.world.update() || viewportChange;
      if (viewportChange) {
        viewer.raiseEvent("viewport-change");
      }
      if (viewer.referenceStrip) {
        animated = viewer.referenceStrip.update(viewer.viewport) || animated;
      }
      var currentAnimating = THIS[viewer.hash].animating;
      if (!currentAnimating && animated) {
        viewer.raiseEvent("animation-start");
        abortControlsAutoHide(viewer);
      }
      var isAnimationFinished = currentAnimating && !animated;
      if (isAnimationFinished) {
        THIS[viewer.hash].animating = false;
      }
      if (animated || isAnimationFinished || THIS[viewer.hash].forceRedraw || viewer.world.needsDraw()) {
        drawWorld(viewer);
        viewer._drawOverlays();
        if (viewer.navigator) {
          viewer.navigator.update(viewer.viewport);
        }
        THIS[viewer.hash].forceRedraw = false;
        if (animated) {
          viewer.raiseEvent("animation");
        }
      }
      if (isAnimationFinished) {
        viewer.raiseEvent("animation-finish");
        if (!THIS[viewer.hash].mouseInside) {
          beginControlsAutoHide(viewer);
        }
      }
      THIS[viewer.hash].animating = animated;
    }
    function drawWorld(viewer) {
      viewer.imageLoader.clear();
      viewer.drawer.clear();
      viewer.world.draw();
      viewer.raiseEvent("update-viewport", {});
    }
    function resolveUrl(prefix, url) {
      return prefix ? prefix + url : url;
    }
    function beginZoomingIn() {
      THIS[this.hash].lastZoomTime = $2.now();
      THIS[this.hash].zoomFactor = this.zoomPerSecond;
      THIS[this.hash].zooming = true;
      scheduleZoom(this);
    }
    function beginZoomingOut() {
      THIS[this.hash].lastZoomTime = $2.now();
      THIS[this.hash].zoomFactor = 1 / this.zoomPerSecond;
      THIS[this.hash].zooming = true;
      scheduleZoom(this);
    }
    function endZooming() {
      THIS[this.hash].zooming = false;
    }
    function scheduleZoom(viewer) {
      $2.requestAnimationFrame($2.delegate(viewer, doZoom));
    }
    function doZoom() {
      var currentTime, deltaTime, adjustedFactor;
      if (THIS[this.hash].zooming && this.viewport) {
        currentTime = $2.now();
        deltaTime = currentTime - THIS[this.hash].lastZoomTime;
        adjustedFactor = Math.pow(THIS[this.hash].zoomFactor, deltaTime / 1e3);
        this.viewport.zoomBy(adjustedFactor);
        this.viewport.applyConstraints();
        THIS[this.hash].lastZoomTime = currentTime;
        scheduleZoom(this);
      }
    }
    function doSingleZoomIn() {
      if (this.viewport) {
        THIS[this.hash].zooming = false;
        this.viewport.zoomBy(
          this.zoomPerClick / 1
        );
        this.viewport.applyConstraints();
      }
    }
    function doSingleZoomOut() {
      if (this.viewport) {
        THIS[this.hash].zooming = false;
        this.viewport.zoomBy(
          1 / this.zoomPerClick
        );
        this.viewport.applyConstraints();
      }
    }
    function lightUp() {
      if (this.buttonGroup) {
        this.buttonGroup.emulateEnter();
        this.buttonGroup.emulateLeave();
      }
    }
    function onHome() {
      if (this.viewport) {
        this.viewport.goHome();
      }
    }
    function onFullScreen() {
      if (this.isFullPage() && !$2.isFullScreen()) {
        this.setFullPage(false);
      } else {
        this.setFullScreen(!this.isFullPage());
      }
      if (this.buttonGroup) {
        this.buttonGroup.emulateLeave();
      }
      this.fullPageButton.element.focus();
      if (this.viewport) {
        this.viewport.applyConstraints();
      }
    }
    function onRotateLeft() {
      if (this.viewport) {
        var currRotation = this.viewport.getRotation();
        if (this.viewport.flipped) {
          currRotation += this.rotationIncrement;
        } else {
          currRotation -= this.rotationIncrement;
        }
        this.viewport.setRotation(currRotation);
      }
    }
    function onRotateRight() {
      if (this.viewport) {
        var currRotation = this.viewport.getRotation();
        if (this.viewport.flipped) {
          currRotation -= this.rotationIncrement;
        } else {
          currRotation += this.rotationIncrement;
        }
        this.viewport.setRotation(currRotation);
      }
    }
    function onFlip() {
      this.viewport.toggleFlip();
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.Navigator = function(options) {
      var viewer = options.viewer, _this = this, viewerSize, navigatorSize;
      if (options.element || options.id) {
        if (options.element) {
          if (options.id) {
            $2.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead.");
          }
          if (options.element.id) {
            options.id = options.element.id;
          } else {
            options.id = "navigator-" + $2.now();
          }
          this.element = options.element;
        } else {
          this.element = document.getElementById(options.id);
        }
        options.controlOptions = {
          anchor: $2.ControlAnchor.NONE,
          attachToViewer: false,
          autoFade: false
        };
      } else {
        options.id = "navigator-" + $2.now();
        this.element = $2.makeNeutralElement("div");
        options.controlOptions = {
          anchor: $2.ControlAnchor.TOP_RIGHT,
          attachToViewer: true,
          autoFade: options.autoFade
        };
        if (options.position) {
          if ("BOTTOM_RIGHT" === options.position) {
            options.controlOptions.anchor = $2.ControlAnchor.BOTTOM_RIGHT;
          } else if ("BOTTOM_LEFT" === options.position) {
            options.controlOptions.anchor = $2.ControlAnchor.BOTTOM_LEFT;
          } else if ("TOP_RIGHT" === options.position) {
            options.controlOptions.anchor = $2.ControlAnchor.TOP_RIGHT;
          } else if ("TOP_LEFT" === options.position) {
            options.controlOptions.anchor = $2.ControlAnchor.TOP_LEFT;
          } else if ("ABSOLUTE" === options.position) {
            options.controlOptions.anchor = $2.ControlAnchor.ABSOLUTE;
            options.controlOptions.top = options.top;
            options.controlOptions.left = options.left;
            options.controlOptions.height = options.height;
            options.controlOptions.width = options.width;
          }
        }
      }
      this.element.id = options.id;
      this.element.className += " navigator";
      options = $2.extend(true, {
        sizeRatio: $2.DEFAULT_SETTINGS.navigatorSizeRatio
      }, options, {
        element: this.element,
        tabIndex: -1,
        // No keyboard navigation, omit from tab order
        //These need to be overridden to prevent recursion since
        //the navigator is a viewer and a viewer has a navigator
        showNavigator: false,
        mouseNavEnabled: false,
        showNavigationControl: false,
        showSequenceControl: false,
        immediateRender: true,
        blendTime: 0,
        animationTime: options.animationTime,
        // disable autoResize since resize behavior is implemented differently by the navigator
        autoResize: false,
        // prevent resizing the navigator from adding unwanted space around the image
        minZoomImageRatio: 1,
        background: options.background,
        opacity: options.opacity,
        borderColor: options.borderColor,
        displayRegionColor: options.displayRegionColor
      });
      options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
      $2.setElementTouchActionNone(this.element);
      this.borderWidth = 2;
      this.fudge = new $2.Point(1, 1);
      this.totalBorderWidths = new $2.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);
      if (options.controlOptions.anchor !== $2.ControlAnchor.NONE) {
        (function(style2, borderWidth) {
          style2.margin = "0px";
          style2.border = borderWidth + "px solid " + options.borderColor;
          style2.padding = "0px";
          style2.background = options.background;
          style2.opacity = options.opacity;
          style2.overflow = "hidden";
        })(this.element.style, this.borderWidth);
      }
      this.displayRegion = $2.makeNeutralElement("div");
      this.displayRegion.id = this.element.id + "-displayregion";
      this.displayRegion.className = "displayregion";
      (function(style2, borderWidth) {
        style2.position = "relative";
        style2.top = "0px";
        style2.left = "0px";
        style2.fontSize = "0px";
        style2.overflow = "hidden";
        style2.border = borderWidth + "px solid " + options.displayRegionColor;
        style2.margin = "0px";
        style2.padding = "0px";
        style2.background = "transparent";
        style2["float"] = "left";
        style2.cssFloat = "left";
        style2.styleFloat = "left";
        style2.zIndex = 999999999;
        style2.cursor = "default";
        style2.boxSizing = "content-box";
      })(this.displayRegion.style, this.borderWidth);
      $2.setElementPointerEventsNone(this.displayRegion);
      $2.setElementTouchActionNone(this.displayRegion);
      this.displayRegionContainer = $2.makeNeutralElement("div");
      this.displayRegionContainer.id = this.element.id + "-displayregioncontainer";
      this.displayRegionContainer.className = "displayregioncontainer";
      this.displayRegionContainer.style.width = "100%";
      this.displayRegionContainer.style.height = "100%";
      $2.setElementPointerEventsNone(this.displayRegionContainer);
      $2.setElementTouchActionNone(this.displayRegionContainer);
      viewer.addControl(
        this.element,
        options.controlOptions
      );
      this._resizeWithViewer = options.controlOptions.anchor !== $2.ControlAnchor.ABSOLUTE && options.controlOptions.anchor !== $2.ControlAnchor.NONE;
      if (options.width && options.height) {
        this.setWidth(options.width);
        this.setHeight(options.height);
      } else if (this._resizeWithViewer) {
        viewerSize = $2.getElementSize(viewer.element);
        this.element.style.height = Math.round(viewerSize.y * options.sizeRatio) + "px";
        this.element.style.width = Math.round(viewerSize.x * options.sizeRatio) + "px";
        this.oldViewerSize = viewerSize;
        navigatorSize = $2.getElementSize(this.element);
        this.elementArea = navigatorSize.x * navigatorSize.y;
      }
      this.oldContainerSize = new $2.Point(0, 0);
      $2.Viewer.apply(this, [options]);
      this.displayRegionContainer.appendChild(this.displayRegion);
      this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
      function rotate(degrees2, immediately) {
        _setTransformRotate(_this.displayRegionContainer, degrees2);
        _setTransformRotate(_this.displayRegion, -degrees2);
        _this.viewport.setRotation(degrees2, immediately);
      }
      if (options.navigatorRotate) {
        var degrees = options.viewer.viewport ? options.viewer.viewport.getRotation() : options.viewer.degrees || 0;
        rotate(degrees, true);
        options.viewer.addHandler("rotate", function(args) {
          rotate(args.degrees, args.immediately);
        });
      }
      this.innerTracker.destroy();
      this.innerTracker = new $2.MouseTracker({
        userData: "Navigator.innerTracker",
        element: this.element,
        //this.canvas,
        dragHandler: $2.delegate(this, onCanvasDrag),
        clickHandler: $2.delegate(this, onCanvasClick),
        releaseHandler: $2.delegate(this, onCanvasRelease),
        scrollHandler: $2.delegate(this, onCanvasScroll),
        preProcessEventHandler: function(eventInfo) {
          if (eventInfo.eventType === "wheel") {
            eventInfo.preventDefault = true;
          }
        }
      });
      this.outerTracker.userData = "Navigator.outerTracker";
      $2.setElementPointerEventsNone(this.canvas);
      $2.setElementPointerEventsNone(this.container);
      this.addHandler("reset-size", function() {
        if (_this.viewport) {
          _this.viewport.goHome(true);
        }
      });
      viewer.world.addHandler("item-index-change", function(event) {
        window.setTimeout(function() {
          var item = _this.world.getItemAt(event.previousIndex);
          _this.world.setItemIndex(item, event.newIndex);
        }, 1);
      });
      viewer.world.addHandler("remove-item", function(event) {
        var theirItem = event.item;
        var myItem = _this._getMatchingItem(theirItem);
        if (myItem) {
          _this.world.removeItem(myItem);
        }
      });
      this.update(viewer.viewport);
    };
    $2.extend(
      $2.Navigator.prototype,
      $2.EventSource.prototype,
      $2.Viewer.prototype,
      /** @lends OpenSeadragon.Navigator.prototype */
      {
        /**
         * Used to notify the navigator when its size has changed.
         * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
         * @function
         */
        updateSize: function() {
          if (this.viewport) {
            var containerSize = new $2.Point(
              this.container.clientWidth === 0 ? 1 : this.container.clientWidth,
              this.container.clientHeight === 0 ? 1 : this.container.clientHeight
            );
            if (!containerSize.equals(this.oldContainerSize)) {
              this.viewport.resize(containerSize, true);
              this.viewport.goHome(true);
              this.oldContainerSize = containerSize;
              this.drawer.clear();
              this.world.draw();
            }
          }
        },
        /**
         * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
         * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
         */
        setWidth: function(width) {
          this.width = width;
          this.element.style.width = typeof width === "number" ? width + "px" : width;
          this._resizeWithViewer = false;
          this.updateSize();
        },
        /**
         * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
         * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
         */
        setHeight: function(height) {
          this.height = height;
          this.element.style.height = typeof height === "number" ? height + "px" : height;
          this._resizeWithViewer = false;
          this.updateSize();
        },
        /**
          * Flip navigator element
          * @param {Boolean} state - Flip state to set.
          */
        setFlip: function(state) {
          this.viewport.setFlip(state);
          this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
          return this;
        },
        setDisplayTransform: function(rule) {
          setElementTransform(this.displayRegion, rule);
          setElementTransform(this.canvas, rule);
          setElementTransform(this.element, rule);
        },
        /**
         * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
         * @function
         * @param {OpenSeadragon.Viewport} The viewport this navigator is tracking.
         */
        update: function(viewport) {
          var viewerSize, newWidth, newHeight, bounds, topleft, bottomright;
          viewerSize = $2.getElementSize(this.viewer.element);
          if (this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals(this.oldViewerSize)) {
            this.oldViewerSize = viewerSize;
            if (this.maintainSizeRatio || !this.elementArea) {
              newWidth = viewerSize.x * this.sizeRatio;
              newHeight = viewerSize.y * this.sizeRatio;
            } else {
              newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
              newHeight = this.elementArea / newWidth;
            }
            this.element.style.width = Math.round(newWidth) + "px";
            this.element.style.height = Math.round(newHeight) + "px";
            if (!this.elementArea) {
              this.elementArea = newWidth * newHeight;
            }
            this.updateSize();
          }
          if (viewport && this.viewport) {
            bounds = viewport.getBoundsNoRotate(true);
            topleft = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
            bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false).minus(this.totalBorderWidths);
            if (!this.navigatorRotate) {
              var degrees = viewport.getRotation(true);
              _setTransformRotate(this.displayRegion, -degrees);
            }
            var style2 = this.displayRegion.style;
            style2.display = this.world.getItemCount() ? "block" : "none";
            style2.top = topleft.y.toFixed(2) + "px";
            style2.left = topleft.x.toFixed(2) + "px";
            var width = bottomright.x - topleft.x;
            var height = bottomright.y - topleft.y;
            style2.width = Math.round(Math.max(width, 0)) + "px";
            style2.height = Math.round(Math.max(height, 0)) + "px";
          }
        },
        // overrides Viewer.addTiledImage
        addTiledImage: function(options) {
          var _this = this;
          var original = options.originalTiledImage;
          delete options.original;
          var optionsClone = $2.extend({}, options, {
            success: function(event) {
              var myItem = event.item;
              myItem._originalForNavigator = original;
              _this._matchBounds(myItem, original, true);
              _this._matchOpacity(myItem, original);
              _this._matchCompositeOperation(myItem, original);
              function matchBounds() {
                _this._matchBounds(myItem, original);
              }
              function matchOpacity() {
                _this._matchOpacity(myItem, original);
              }
              function matchCompositeOperation() {
                _this._matchCompositeOperation(myItem, original);
              }
              original.addHandler("bounds-change", matchBounds);
              original.addHandler("clip-change", matchBounds);
              original.addHandler("opacity-change", matchOpacity);
              original.addHandler("composite-operation-change", matchCompositeOperation);
            }
          });
          return $2.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
        },
        destroy: function() {
          return $2.Viewer.prototype.destroy.apply(this);
        },
        // private
        _getMatchingItem: function(theirItem) {
          var count = this.world.getItemCount();
          var item;
          for (var i = 0; i < count; i++) {
            item = this.world.getItemAt(i);
            if (item._originalForNavigator === theirItem) {
              return item;
            }
          }
          return null;
        },
        // private
        _matchBounds: function(myItem, theirItem, immediately) {
          var bounds = theirItem.getBoundsNoRotate();
          myItem.setPosition(bounds.getTopLeft(), immediately);
          myItem.setWidth(bounds.width, immediately);
          myItem.setRotation(theirItem.getRotation(), immediately);
          myItem.setClip(theirItem.getClip());
          myItem.setFlip(theirItem.getFlip());
        },
        // private
        _matchOpacity: function(myItem, theirItem) {
          myItem.setOpacity(theirItem.opacity);
        },
        // private
        _matchCompositeOperation: function(myItem, theirItem) {
          myItem.setCompositeOperation(theirItem.compositeOperation);
        }
      }
    );
    function onCanvasClick(event) {
      var canvasClickEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        quick: event.quick,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.viewer.raiseEvent("navigator-click", canvasClickEventArgs);
      if (!canvasClickEventArgs.preventDefaultAction && event.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
        if (this.viewer.viewport.flipped) {
          event.position.x = this.viewport.getContainerSize().x - event.position.x;
        }
        var target = this.viewport.pointFromPixel(event.position);
        if (!this.panVertical) {
          target.y = this.viewer.viewport.getCenter(true).y;
        } else if (!this.panHorizontal) {
          target.x = this.viewer.viewport.getCenter(true).x;
        }
        this.viewer.viewport.panTo(target);
        this.viewer.viewport.applyConstraints();
      }
    }
    function onCanvasDrag(event) {
      var canvasDragEventArgs = {
        tracker: event.eventSource,
        position: event.position,
        delta: event.delta,
        speed: event.speed,
        direction: event.direction,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefaultAction: false
      };
      this.viewer.raiseEvent("navigator-drag", canvasDragEventArgs);
      if (!canvasDragEventArgs.preventDefaultAction && this.viewer.viewport) {
        if (!this.panHorizontal) {
          event.delta.x = 0;
        }
        if (!this.panVertical) {
          event.delta.y = 0;
        }
        if (this.viewer.viewport.flipped) {
          event.delta.x = -event.delta.x;
        }
        this.viewer.viewport.panBy(
          this.viewport.deltaPointsFromPixels(
            event.delta
          )
        );
        if (this.viewer.constrainDuringPan) {
          this.viewer.viewport.applyConstraints();
        }
      }
    }
    function onCanvasRelease(event) {
      if (event.insideElementPressed && this.viewer.viewport) {
        this.viewer.viewport.applyConstraints();
      }
    }
    function onCanvasScroll(event) {
      var eventArgs = {
        tracker: event.eventSource,
        position: event.position,
        scroll: event.scroll,
        shift: event.shift,
        originalEvent: event.originalEvent,
        preventDefault: event.preventDefault
      };
      this.viewer.raiseEvent("navigator-scroll", eventArgs);
      event.preventDefault = eventArgs.preventDefault;
    }
    function _setTransformRotate(element, degrees) {
      setElementTransform(element, "rotate(" + degrees + "deg)");
    }
    function setElementTransform(element, rule) {
      element.style.webkitTransform = rule;
      element.style.mozTransform = rule;
      element.style.msTransform = rule;
      element.style.oTransform = rule;
      element.style.transform = rule;
    }
  })(OpenSeadragon2);
  (function($2) {
    var I18N = {
      Errors: {
        Dzc: "Sorry, we don't support Deep Zoom Collections!",
        Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
        Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
        ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
        Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.",
        Status: "This space unintentionally left blank ({0} {1}).",
        OpenFailed: "Unable to open {0}: {1}"
      },
      Tooltips: {
        FullPage: "Toggle full page",
        Home: "Go home",
        ZoomIn: "Zoom in",
        ZoomOut: "Zoom out",
        NextPage: "Next page",
        PreviousPage: "Previous page",
        RotateLeft: "Rotate left",
        RotateRight: "Rotate right",
        Flip: "Flip Horizontally"
      }
    };
    $2.extend(
      $2,
      /** @lends OpenSeadragon */
      {
        /**
         * @function
         * @param {String} property
         */
        getString: function(prop) {
          var props = prop.split("."), string = null, args = arguments, container = I18N, i;
          for (i = 0; i < props.length - 1; i++) {
            container = container[props[i]] || {};
          }
          string = container[props[i]];
          if (typeof string !== "string") {
            $2.console.error("Untranslated source string:", prop);
            string = "";
          }
          return string.replace(/\{\d+\}/g, function(capture) {
            var i2 = parseInt(capture.match(/\d+/), 10) + 1;
            return i2 < args.length ? args[i2] : "";
          });
        },
        /**
         * @function
         * @param {String} property
         * @param {*} value
         */
        setString: function(prop, value) {
          var props = prop.split("."), container = I18N, i;
          for (i = 0; i < props.length - 1; i++) {
            if (!container[props[i]]) {
              container[props[i]] = {};
            }
            container = container[props[i]];
          }
          container[props[i]] = value;
        }
      }
    );
  })(OpenSeadragon2);
  (function($2) {
    $2.Point = function(x2, y) {
      this.x = typeof x2 === "number" ? x2 : 0;
      this.y = typeof y === "number" ? y : 0;
    };
    $2.Point.prototype = {
      /**
       * @function
       * @returns {OpenSeadragon.Point} a duplicate of this Point
       */
      clone: function() {
        return new $2.Point(this.x, this.y);
      },
      /**
       * Add another Point to this point and return a new Point.
       * @function
       * @param {OpenSeadragon.Point} point The point to add vector components.
       * @returns {OpenSeadragon.Point} A new point representing the sum of the
       *  vector components
       */
      plus: function(point) {
        return new $2.Point(
          this.x + point.x,
          this.y + point.y
        );
      },
      /**
       * Subtract another Point to this point and return a new Point.
       * @function
       * @param {OpenSeadragon.Point} point The point to subtract vector components.
       * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
       *  vector components
       */
      minus: function(point) {
        return new $2.Point(
          this.x - point.x,
          this.y - point.y
        );
      },
      /**
       * Multiply this point by a factor and return a new Point.
       * @function
       * @param {Number} factor The factor to multiply vector components.
       * @returns {OpenSeadragon.Point} A new point representing the multiplication
       *  of the vector components by the factor
       */
      times: function(factor) {
        return new $2.Point(
          this.x * factor,
          this.y * factor
        );
      },
      /**
       * Divide this point by a factor and return a new Point.
       * @function
       * @param {Number} factor The factor to divide vector components.
       * @returns {OpenSeadragon.Point} A new point representing the division of the
       *  vector components by the factor
       */
      divide: function(factor) {
        return new $2.Point(
          this.x / factor,
          this.y / factor
        );
      },
      /**
       * Compute the opposite of this point and return a new Point.
       * @function
       * @returns {OpenSeadragon.Point} A new point representing the opposite of the
       *  vector components
       */
      negate: function() {
        return new $2.Point(-this.x, -this.y);
      },
      /**
       * Compute the distance between this point and another point.
       * @function
       * @param {OpenSeadragon.Point} point The point to compute the distance with.
       * @returns {Number} The distance between the 2 points
       */
      distanceTo: function(point) {
        return Math.sqrt(
          Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2)
        );
      },
      /**
       * Compute the squared distance between this point and another point.
       * Useful for optimizing things like comparing distances.
       * @function
       * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
       * @returns {Number} The squared distance between the 2 points
       */
      squaredDistanceTo: function(point) {
        return Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2);
      },
      /**
       * Apply a function to each coordinate of this point and return a new point.
       * @function
       * @param {function} func The function to apply to each coordinate.
       * @returns {OpenSeadragon.Point} A new point with the coordinates computed
       * by the specified function
       */
      apply: function(func) {
        return new $2.Point(func(this.x), func(this.y));
      },
      /**
       * Check if this point is equal to another one.
       * @function
       * @param {OpenSeadragon.Point} point The point to compare this point with.
       * @returns {Boolean} true if they are equal, false otherwise.
       */
      equals: function(point) {
        return point instanceof $2.Point && this.x === point.x && this.y === point.y;
      },
      /**
       * Rotates the point around the specified pivot
       * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
       * @function
       * @param {Number} degress to rotate around the pivot.
       * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
       * Defaults to the origin.
       * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
       */
      rotate: function(degrees, pivot) {
        pivot = pivot || new $2.Point(0, 0);
        var cos;
        var sin;
        if (degrees % 90 === 0) {
          var d = $2.positiveModulo(degrees, 360);
          switch (d) {
            case 0:
              cos = 1;
              sin = 0;
              break;
            case 90:
              cos = 0;
              sin = 1;
              break;
            case 180:
              cos = -1;
              sin = 0;
              break;
            case 270:
              cos = 0;
              sin = -1;
              break;
          }
        } else {
          var angle = degrees * Math.PI / 180;
          cos = Math.cos(angle);
          sin = Math.sin(angle);
        }
        var x2 = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
        var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
        return new $2.Point(x2, y);
      },
      /**
       * Convert this point to a string in the format (x,y) where x and y are
       * rounded to the nearest integer.
       * @function
       * @returns {String} A string representation of this point.
       */
      toString: function() {
        return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.TileSource = function(width, height, tileSize, tileOverlap, minLevel, maxLevel) {
      var _this = this;
      var args = arguments, options, i;
      if ($2.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: args[0],
          height: args[1],
          tileSize: args[2],
          tileOverlap: args[3],
          minLevel: args[4],
          maxLevel: args[5]
        };
      }
      $2.EventSource.call(this);
      $2.extend(true, this, options);
      if (!this.success) {
        for (i = 0; i < arguments.length; i++) {
          if ($2.isFunction(arguments[i])) {
            this.success = arguments[i];
            break;
          }
        }
      }
      if (this.success) {
        this.addHandler("ready", function(event) {
          _this.success(event);
        });
      }
      if ("string" === $2.type(arguments[0])) {
        this.url = arguments[0];
      }
      if (this.url) {
        this.aspectRatio = 1;
        this.dimensions = new $2.Point(10, 10);
        this._tileWidth = 0;
        this._tileHeight = 0;
        this.tileOverlap = 0;
        this.minLevel = 0;
        this.maxLevel = 0;
        this.ready = false;
        this.getImageInfo(this.url);
      } else {
        this.ready = true;
        this.aspectRatio = options.width && options.height ? options.width / options.height : 1;
        this.dimensions = new $2.Point(options.width, options.height);
        if (this.tileSize) {
          this._tileWidth = this._tileHeight = this.tileSize;
          delete this.tileSize;
        } else {
          if (this.tileWidth) {
            this._tileWidth = this.tileWidth;
            delete this.tileWidth;
          } else {
            this._tileWidth = 0;
          }
          if (this.tileHeight) {
            this._tileHeight = this.tileHeight;
            delete this.tileHeight;
          } else {
            this._tileHeight = 0;
          }
        }
        this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
        this.minLevel = options.minLevel ? options.minLevel : 0;
        this.maxLevel = void 0 !== options.maxLevel && null !== options.maxLevel ? options.maxLevel : options.width && options.height ? Math.ceil(
          Math.log(Math.max(options.width, options.height)) / Math.log(2)
        ) : 0;
        if (this.success && $2.isFunction(this.success)) {
          this.success(this);
        }
      }
    };
    $2.TileSource.prototype = {
      getTileSize: function(level) {
        $2.console.error(
          "[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
        );
        return this._tileWidth;
      },
      /**
       * Return the tileWidth for a given level.
       * Subclasses should override this if tileWidth can be different at different levels
       *   such as in IIIFTileSource.  Code should use this function rather than reading
       *   from ._tileWidth directly.
       * @function
       * @param {Number} level
       */
      getTileWidth: function(level) {
        if (!this._tileWidth) {
          return this.getTileSize(level);
        }
        return this._tileWidth;
      },
      /**
       * Return the tileHeight for a given level.
       * Subclasses should override this if tileHeight can be different at different levels
       *   such as in IIIFTileSource.  Code should use this function rather than reading
       *   from ._tileHeight directly.
       * @function
       * @param {Number} level
       */
      getTileHeight: function(level) {
        if (!this._tileHeight) {
          return this.getTileSize(level);
        }
        return this._tileHeight;
      },
      /**
       * Set the maxLevel to the given level, and perform the memoization of
       * getLevelScale with the new maxLevel. This function can be useful if the
       * memoization is required before the first call of getLevelScale, or both
       * memoized getLevelScale and maxLevel should be changed accordingly.
       * @function
       * @param {Number} level
       */
      setMaxLevel: function(level) {
        this.maxLevel = level;
        this._memoizeLevelScale();
      },
      /**
       * @function
       * @param {Number} level
       */
      getLevelScale: function(level) {
        this._memoizeLevelScale();
        return this.getLevelScale(level);
      },
      // private
      _memoizeLevelScale: function() {
        var levelScaleCache = {}, i;
        for (i = 0; i <= this.maxLevel; i++) {
          levelScaleCache[i] = 1 / Math.pow(2, this.maxLevel - i);
        }
        this.getLevelScale = function(_level) {
          return levelScaleCache[_level];
        };
      },
      /**
       * @function
       * @param {Number} level
       */
      getNumTiles: function(level) {
        var scale = this.getLevelScale(level), x2 = Math.ceil(scale * this.dimensions.x / this.getTileWidth(level)), y = Math.ceil(scale * this.dimensions.y / this.getTileHeight(level));
        return new $2.Point(x2, y);
      },
      /**
       * @function
       * @param {Number} level
       */
      getPixelRatio: function(level) {
        var imageSizeScaled = this.dimensions.times(this.getLevelScale(level)), rx = 1 / imageSizeScaled.x * $2.pixelDensityRatio, ry = 1 / imageSizeScaled.y * $2.pixelDensityRatio;
        return new $2.Point(rx, ry);
      },
      /**
       * @function
       * @returns {Number} The highest level in this tile source that can be contained in a single tile.
       */
      getClosestLevel: function() {
        var i, tiles;
        for (i = this.minLevel + 1; i <= this.maxLevel; i++) {
          tiles = this.getNumTiles(i);
          if (tiles.x > 1 || tiles.y > 1) {
            break;
          }
        }
        return i - 1;
      },
      /**
       * @function
       * @param {Number} level
       * @param {OpenSeadragon.Point} point
       */
      getTileAtPoint: function(level, point) {
        var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
        $2.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
        var widthScaled = this.dimensions.x * this.getLevelScale(level);
        var pixelX = point.x * widthScaled;
        var pixelY = point.y * widthScaled;
        var x2 = Math.floor(pixelX / this.getTileWidth(level));
        var y = Math.floor(pixelY / this.getTileHeight(level));
        if (point.x >= 1) {
          x2 = this.getNumTiles(level).x - 1;
        }
        var EPSILON = 1e-15;
        if (point.y >= 1 / this.aspectRatio - EPSILON) {
          y = this.getNumTiles(level).y - 1;
        }
        return new $2.Point(x2, y);
      },
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
       * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
       * portion of the tile to use as the source of the drawing operation (in pixels), depending on
       * the isSource parameter.
       */
      getTileBounds: function(level, x2, y, isSource) {
        var dimensionsScaled = this.dimensions.times(this.getLevelScale(level)), tileWidth = this.getTileWidth(level), tileHeight = this.getTileHeight(level), px = x2 === 0 ? 0 : tileWidth * x2 - this.tileOverlap, py = y === 0 ? 0 : tileHeight * y - this.tileOverlap, sx = tileWidth + (x2 === 0 ? 1 : 2) * this.tileOverlap, sy = tileHeight + (y === 0 ? 1 : 2) * this.tileOverlap, scale = 1 / dimensionsScaled.x;
        sx = Math.min(sx, dimensionsScaled.x - px);
        sy = Math.min(sy, dimensionsScaled.y - py);
        if (isSource) {
          return new $2.Rect(0, 0, sx, sy);
        }
        return new $2.Rect(px * scale, py * scale, sx * scale, sy * scale);
      },
      /**
       * Responsible for retrieving, and caching the
       * image metadata pertinent to this TileSources implementation.
       * @function
       * @param {String} url
       * @throws {Error}
       */
      getImageInfo: function(url) {
        var _this = this, callbackName, callback, readySource, options, urlParts, filename, lastDot;
        if (url) {
          urlParts = url.split("/");
          filename = urlParts[urlParts.length - 1];
          lastDot = filename.lastIndexOf(".");
          if (lastDot > -1) {
            urlParts[urlParts.length - 1] = filename.slice(0, lastDot);
          }
        }
        var postData = null;
        if (this.splitHashDataForPost) {
          var hashIdx = url.indexOf("#");
          if (hashIdx !== -1) {
            postData = url.substring(hashIdx + 1);
            url = url.substr(0, hashIdx);
          }
        }
        callback = function(data) {
          if (typeof data === "string") {
            data = $2.parseXml(data);
          }
          var $TileSource = $2.TileSource.determineType(_this, data, url);
          if (!$TileSource) {
            _this.raiseEvent("open-failed", { message: "Unable to load TileSource", source: url });
            return;
          }
          options = $TileSource.prototype.configure.apply(_this, [data, url, postData]);
          if (options.ajaxWithCredentials === void 0) {
            options.ajaxWithCredentials = _this.ajaxWithCredentials;
          }
          readySource = new $TileSource(options);
          _this.ready = true;
          _this.raiseEvent("ready", { tileSource: readySource });
        };
        if (url.match(/\.js$/)) {
          callbackName = url.split("/").pop().replace(".js", "");
          $2.jsonp({
            url,
            async: false,
            callbackName,
            callback
          });
        } else {
          $2.makeAjaxRequest({
            url,
            postData,
            withCredentials: this.ajaxWithCredentials,
            headers: this.ajaxHeaders,
            success: function(xhr) {
              var data = processResponse(xhr);
              callback(data);
            },
            error: function(xhr, exc) {
              var msg;
              try {
                msg = "HTTP " + xhr.status + " attempting to load TileSource: " + url;
              } catch (e) {
                var formattedExc;
                if (typeof exc === "undefined" || !exc.toString) {
                  formattedExc = "Unknown error";
                } else {
                  formattedExc = exc.toString();
                }
                msg = formattedExc + " attempting to load TileSource: " + url;
              }
              $2.console.error(msg);
              _this.raiseEvent("open-failed", {
                message: msg,
                source: url,
                postData
              });
            }
          });
        }
      },
      /**
       * Responsible determining if a the particular TileSource supports the
       * data format ( and allowed to apply logic against the url the data was
       * loaded from, if any ). Overriding implementations are expected to do
       * something smart with data and / or url to determine support.  Also
       * understand that iteration order of TileSources is not guarunteed so
       * please make sure your data or url is expressive enough to ensure a simple
       * and sufficient mechanisim for clear determination.
       * @function
       * @param {String|Object|Array|Document} data
       * @param {String} url - the url the data was loaded
       *      from if any.
       * @returns {Boolean}
       */
      supports: function(data, url) {
        return false;
      },
      /**
       * Responsible for parsing and configuring the
       * image metadata pertinent to this TileSources implementation.
       * This method is not implemented by this class other than to throw an Error
       * announcing you have to implement it.  Because of the variety of tile
       * server technologies, and various specifications for building image
       * pyramids, this method is here to allow easy integration.
       * @function
       * @param {String|Object|Array|Document} data
       * @param {String} url - the url the data was loaded
       *      from if any.
       * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null value obtained from
       *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
       * @returns {Object} options - A dictionary of keyword arguments sufficient
       *      to configure the tile source constructor (include all values you want to
       *      instantiate the TileSource subclass with - what _options_ object should contain).
       * @throws {Error}
       */
      configure: function(data, url, postData) {
        throw new Error("Method not implemented.");
      },
      /**
       * Responsible for retrieving the url which will return an image for the
       * region specified by the given x, y, and level components.
       * This method is not implemented by this class other than to throw an Error
       * announcing you have to implement it.  Because of the variety of tile
       * server technologies, and various specifications for building image
       * pyramids, this method is here to allow easy integration.
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @returns {String|Function} url - A string for the url or a function that returns a url string.
       * @throws {Error}
       */
      getTileUrl: function(level, x2, y) {
        throw new Error("Method not implemented.");
      },
      /**
       * Must use AJAX in order to work, i.e. loadTilesWithAjax = true is set.
       * If a value is returned, ajax issues POST request to the tile url.
       * If null is returned, ajax issues GET request.
       * The return value must comply to the header 'content type'.
       *
       * Examples (USED HEADER --> getTilePostData CODE):
       * 'Content-type': 'application/x-www-form-urlencoded' -->
       *   return "key1=value=1&key2=value2";
       *
       * 'Content-type': 'application/x-www-form-urlencoded' -->
       *   return JSON.stringify({key: "value", number: 5});
       *
       * 'Content-type': 'multipart/form-data' -->
       *   let result = new FormData();
       *   result.append("data", myData);
       *   return result;
       *
       * IMPORTANT: in case you move all the logic on image fetching
       * to post data, you must re-define 'getTileHashKey(...)' to
       * stay unique for different tile images.
       *
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @returns {*|null} post data to send with tile configuration request
       */
      getTilePostData: function(level, x2, y) {
        return null;
      },
      /**
       * Responsible for retrieving the headers which will be attached to the image request for the
       * region specified by the given x, y, and level components.
       * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
       * The headers returned here will override headers specified at the Viewer or TiledImage level.
       * Specifying a falsy value for a header will clear its existing value set at the Viewer or
       * TiledImage level (if any).
       *
       * Note that the headers of existing tiles don't automatically change when this function
       * returns updated headers. To do that, you need to call {@link OpenSeadragon.Viewer#setAjaxHeaders}
       * and propagate the changes.
       *
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @returns {Object}
       */
      getTileAjaxHeaders: function(level, x2, y) {
        return {};
      },
      /**
       * The tile cache object is uniquely determined by this key and used to lookup
       * the image data in cache: keys should be different if images are different.
       *
       * In case a tile has context2D property defined (TileSource.prototype.getContext2D)
       * or its context2D is set manually; the cache is not used and this function
       * is irrelevant.
       * Note: default behaviour does not take into account post data.
       * @param {Number} level tile level it was fetched with
       * @param {Number} x x-coordinate in the pyramid level
       * @param {Number} y y-coordinate in the pyramid level
       * @param {String} url the tile was fetched with
       * @param {Object} ajaxHeaders the tile was fetched with
       * @param {*} postData data the tile was fetched with (type depends on getTilePostData(..) return type)
       */
      getTileHashKey: function(level, x2, y, url, ajaxHeaders, postData) {
        function withHeaders(hash) {
          return ajaxHeaders ? hash + "+" + JSON.stringify(ajaxHeaders) : hash;
        }
        if (typeof url !== "string") {
          return withHeaders(level + "/" + x2 + "_" + y);
        }
        return withHeaders(url);
      },
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       */
      tileExists: function(level, x2, y) {
        var numTiles = this.getNumTiles(level);
        return level >= this.minLevel && level <= this.maxLevel && x2 >= 0 && y >= 0 && x2 < numTiles.x && y < numTiles.y;
      },
      /**
       * Decide whether tiles have transparency: this is crucial for correct images blending.
       * @returns {boolean} true if the image has transparency
       */
      hasTransparency: function(context2D, url, ajaxHeaders, post) {
        return !!context2D || url.match(".png");
      },
      /**
       * Download tile data.
       * Note that if you override this function, you should override also downloadTileAbort().
       * @param {ImageJob} context job context that you have to call finish(...) on.
       * @param {String} [context.src] - URL of image to download.
       * @param {String} [context.loadWithAjax] - Whether to load this image with AJAX.
       * @param {String} [context.ajaxHeaders] - Headers to add to the image request if using AJAX.
       * @param {Boolean} [context.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
       * @param {String} [context.crossOriginPolicy] - CORS policy to use for downloads
       * @param {String} [context.postData] - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
       *   see TileSource::getPostData) or null
       * @param {*} [context.userData] - Empty object to attach your own data and helper variables to.
       * @param {Function} [context.finish] - Should be called unless abort() was executed, e.g. on all occasions,
       *   be it successful or unsuccessful request.
       *   Usage: context.finish(data, request, errMessage). Pass the downloaded data object or null upon failure.
       *   Add also reference to an ajax request if used. Provide error message in case of failure.
       * @param {Function} [context.abort] - Called automatically when the job times out.
       *   Usage: context.abort().
       * @param {Function} [context.callback] @private - Called automatically once image has been downloaded
       *   (triggered by finish).
       * @param {Number} [context.timeout] @private - The max number of milliseconds that
       *   this image job may take to complete.
       * @param {string} [context.errorMsg] @private - The final error message, default null (set by finish).
       */
      downloadTileStart: function(context) {
        var dataStore = context.userData, image = new Image();
        dataStore.image = image;
        dataStore.request = null;
        var finish = function(error) {
          if (!image) {
            context.finish(null, dataStore.request, "Image load failed: undefined Image instance.");
            return;
          }
          image.onload = image.onerror = image.onabort = null;
          context.finish(error ? null : image, dataStore.request, error);
        };
        image.onload = function() {
          finish();
        };
        image.onabort = image.onerror = function() {
          finish("Image load aborted.");
        };
        if (context.loadWithAjax) {
          dataStore.request = $2.makeAjaxRequest({
            url: context.src,
            withCredentials: context.ajaxWithCredentials,
            headers: context.ajaxHeaders,
            responseType: "arraybuffer",
            postData: context.postData,
            success: function(request) {
              var blb;
              try {
                blb = new window.Blob([request.response]);
              } catch (e) {
                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                if (e.name === "TypeError" && BlobBuilder) {
                  var bb = new BlobBuilder();
                  bb.append(request.response);
                  blb = bb.getBlob();
                }
              }
              if (blb.size === 0) {
                finish("Empty image response.");
              } else {
                image.src = (window.URL || window.webkitURL).createObjectURL(blb);
              }
            },
            error: function(request) {
              finish("Image load aborted - XHR error");
            }
          });
        } else {
          if (context.crossOriginPolicy !== false) {
            image.crossOrigin = context.crossOriginPolicy;
          }
          image.src = context.src;
        }
      },
      /**
       * Provide means of aborting the execution.
       * Note that if you override this function, you should override also downloadTileStart().
       * @param {ImageJob} context job, the same object as with downloadTileStart(..)
       * @param {*} [context.userData] - Empty object to attach (and mainly read) your own data.
       */
      downloadTileAbort: function(context) {
        if (context.userData.request) {
          context.userData.request.abort();
        }
        var image = context.userData.image;
        if (context.userData.image) {
          image.onload = image.onerror = image.onabort = null;
        }
      },
      /**
       * Create cache object from the result of the download process. The
       * cacheObject parameter should be used to attach the data to, there are no
       * conventions on how it should be stored - all the logic is implemented within *TileCache() functions.
       *
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
       * @param {Tile} tile instance the cache was created with
       */
      createTileCache: function(cacheObject, data, tile) {
        cacheObject._data = data;
      },
      /**
       * Cache object destructor, unset all properties you created to allow GC collection.
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       */
      destroyTileCache: function(cacheObject) {
        cacheObject._data = null;
        cacheObject._renderedContext = null;
      },
      /**
       * Raw data getter
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       * @returns {*} cache data
       */
      getTileCacheData: function(cacheObject) {
        return cacheObject._data;
      },
      /**
       * Compatibility image element getter
       *  - plugins might need image representation of the data
       *  - div HTML rendering relies on image element presence
       * Note that if you override any of *TileCache() functions, you should override all of them.
       *  @param {object} cacheObject context cache object
       *  @returns {Image} cache data as an Image
       */
      getTileCacheDataAsImage: function(cacheObject) {
        return cacheObject._data;
      },
      /**
       * Compatibility context 2D getter
       *  - most heavily used rendering method is a canvas-based approach,
       *    convert the data to a canvas and return it's 2D context
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       * @returns {CanvasRenderingContext2D} context of the canvas representation of the cache data
       */
      getTileCacheDataAsContext2D: function(cacheObject) {
        if (!cacheObject._renderedContext) {
          var canvas = document.createElement("canvas");
          canvas.width = cacheObject._data.width;
          canvas.height = cacheObject._data.height;
          cacheObject._renderedContext = canvas.getContext("2d");
          cacheObject._renderedContext.drawImage(cacheObject._data, 0, 0);
          cacheObject._data = null;
        }
        return cacheObject._renderedContext;
      }
    };
    $2.extend(true, $2.TileSource.prototype, $2.EventSource.prototype);
    function processResponse(xhr) {
      var responseText = xhr.responseText, status = xhr.status, statusText, data;
      if (!xhr) {
        throw new Error($2.getString("Errors.Security"));
      } else if (xhr.status !== 200 && xhr.status !== 0) {
        status = xhr.status;
        statusText = status === 404 ? "Not Found" : xhr.statusText;
        throw new Error($2.getString("Errors.Status", status, statusText));
      }
      if (responseText.match(/^\s*<.*/)) {
        try {
          data = xhr.responseXML && xhr.responseXML.documentElement ? xhr.responseXML : $2.parseXml(responseText);
        } catch (e) {
          data = xhr.responseText;
        }
      } else if (responseText.match(/\s*[{[].*/)) {
        try {
          data = $2.parseJSON(responseText);
        } catch (e) {
          data = responseText;
        }
      } else {
        data = responseText;
      }
      return data;
    }
    $2.TileSource.determineType = function(tileSource, data, url) {
      var property2;
      for (property2 in OpenSeadragon2) {
        if (property2.match(/.+TileSource$/) && $2.isFunction(OpenSeadragon2[property2]) && $2.isFunction(OpenSeadragon2[property2].prototype.supports) && OpenSeadragon2[property2].prototype.supports.call(tileSource, data, url)) {
          return OpenSeadragon2[property2];
        }
      }
      $2.console.error("No TileSource was able to open %s %s", url, data);
      return null;
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.DziTileSource = function(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel) {
      var i, rect, level, options;
      if ($2.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4],
          fileFormat: arguments[5],
          displayRects: arguments[6],
          minLevel: arguments[7],
          maxLevel: arguments[8]
        };
      }
      this._levelRects = {};
      this.tilesUrl = options.tilesUrl;
      this.fileFormat = options.fileFormat;
      this.displayRects = options.displayRects;
      if (this.displayRects) {
        for (i = this.displayRects.length - 1; i >= 0; i--) {
          rect = this.displayRects[i];
          for (level = rect.minLevel; level <= rect.maxLevel; level++) {
            if (!this._levelRects[level]) {
              this._levelRects[level] = [];
            }
            this._levelRects[level].push(rect);
          }
        }
      }
      $2.TileSource.apply(this, [options]);
    };
    $2.extend(
      $2.DziTileSource.prototype,
      $2.TileSource.prototype,
      /** @lends OpenSeadragon.DziTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(data, url) {
          var ns;
          if (data.Image) {
            ns = data.Image.xmlns;
          } else if (data.documentElement) {
            if ("Image" === data.documentElement.localName || "Image" === data.documentElement.tagName) {
              ns = data.documentElement.namespaceURI;
            }
          }
          ns = (ns || "").toLowerCase();
          return ns.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || ns.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
        },
        /**
         *
         * @function
         * @param {Object|XMLDocument} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(data, url, postData) {
          var options;
          if (!$2.isPlainObject(data)) {
            options = configureFromXML(this, data);
          } else {
            options = configureFromObject(this, data);
          }
          if (url && !options.tilesUrl) {
            options.tilesUrl = url.replace(
              /([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/,
              "$1_files/"
            );
            if (url.search(/\.(dzi|xml|js)\?/) !== -1) {
              options.queryParams = url.match(/\?.*/);
            } else {
              options.queryParams = "";
            }
          }
          return options;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(level, x2, y) {
          return [this.tilesUrl, level, "/", x2, "_", y, ".", this.fileFormat, this.queryParams].join("");
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        tileExists: function(level, x2, y) {
          var rects = this._levelRects[level], rect, scale, xMin, yMin, xMax, yMax, i;
          if (this.minLevel && level < this.minLevel || this.maxLevel && level > this.maxLevel) {
            return false;
          }
          if (!rects || !rects.length) {
            return true;
          }
          for (i = rects.length - 1; i >= 0; i--) {
            rect = rects[i];
            if (level < rect.minLevel || level > rect.maxLevel) {
              continue;
            }
            scale = this.getLevelScale(level);
            xMin = rect.x * scale;
            yMin = rect.y * scale;
            xMax = xMin + rect.width * scale;
            yMax = yMin + rect.height * scale;
            xMin = Math.floor(xMin / this._tileWidth);
            yMin = Math.floor(yMin / this._tileWidth);
            xMax = Math.ceil(xMax / this._tileWidth);
            yMax = Math.ceil(yMax / this._tileWidth);
            if (xMin <= x2 && x2 < xMax && yMin <= y && y < yMax) {
              return true;
            }
          }
          return false;
        }
      }
    );
    function configureFromXML(tileSource, xmlDoc) {
      if (!xmlDoc || !xmlDoc.documentElement) {
        throw new Error($2.getString("Errors.Xml"));
      }
      var root2 = xmlDoc.documentElement, rootName = root2.localName || root2.tagName, ns = xmlDoc.documentElement.namespaceURI, configuration = null, displayRects = [], dispRectNodes, dispRectNode, rectNode, sizeNode, i;
      if (rootName === "Image") {
        try {
          sizeNode = root2.getElementsByTagName("Size")[0];
          if (sizeNode === void 0) {
            sizeNode = root2.getElementsByTagNameNS(ns, "Size")[0];
          }
          configuration = {
            Image: {
              xmlns: "http://schemas.microsoft.com/deepzoom/2008",
              Url: root2.getAttribute("Url"),
              Format: root2.getAttribute("Format"),
              DisplayRect: null,
              Overlap: parseInt(root2.getAttribute("Overlap"), 10),
              TileSize: parseInt(root2.getAttribute("TileSize"), 10),
              Size: {
                Height: parseInt(sizeNode.getAttribute("Height"), 10),
                Width: parseInt(sizeNode.getAttribute("Width"), 10)
              }
            }
          };
          if (!$2.imageFormatSupported(configuration.Image.Format)) {
            throw new Error(
              $2.getString("Errors.ImageFormat", configuration.Image.Format.toUpperCase())
            );
          }
          dispRectNodes = root2.getElementsByTagName("DisplayRect");
          if (dispRectNodes === void 0) {
            dispRectNodes = root2.getElementsByTagNameNS(ns, "DisplayRect")[0];
          }
          for (i = 0; i < dispRectNodes.length; i++) {
            dispRectNode = dispRectNodes[i];
            rectNode = dispRectNode.getElementsByTagName("Rect")[0];
            if (rectNode === void 0) {
              rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect")[0];
            }
            displayRects.push({
              Rect: {
                X: parseInt(rectNode.getAttribute("X"), 10),
                Y: parseInt(rectNode.getAttribute("Y"), 10),
                Width: parseInt(rectNode.getAttribute("Width"), 10),
                Height: parseInt(rectNode.getAttribute("Height"), 10),
                MinLevel: parseInt(dispRectNode.getAttribute("MinLevel"), 10),
                MaxLevel: parseInt(dispRectNode.getAttribute("MaxLevel"), 10)
              }
            });
          }
          if (displayRects.length) {
            configuration.Image.DisplayRect = displayRects;
          }
          return configureFromObject(tileSource, configuration);
        } catch (e) {
          throw e instanceof Error ? e : new Error($2.getString("Errors.Dzi"));
        }
      } else if (rootName === "Collection") {
        throw new Error($2.getString("Errors.Dzc"));
      } else if (rootName === "Error") {
        var messageNode = root2.getElementsByTagName("Message")[0];
        var message = messageNode.firstChild.nodeValue;
        throw new Error(message);
      }
      throw new Error($2.getString("Errors.Dzi"));
    }
    function configureFromObject(tileSource, configuration) {
      var imageData = configuration.Image, tilesUrl = imageData.Url, fileFormat = imageData.Format, sizeData = imageData.Size, dispRectData = imageData.DisplayRect || [], width = parseInt(sizeData.Width, 10), height = parseInt(sizeData.Height, 10), tileSize = parseInt(imageData.TileSize, 10), tileOverlap = parseInt(imageData.Overlap, 10), displayRects = [], rectData, i;
      for (i = 0; i < dispRectData.length; i++) {
        rectData = dispRectData[i].Rect;
        displayRects.push(new $2.DisplayRect(
          parseInt(rectData.X, 10),
          parseInt(rectData.Y, 10),
          parseInt(rectData.Width, 10),
          parseInt(rectData.Height, 10),
          parseInt(rectData.MinLevel, 10),
          parseInt(rectData.MaxLevel, 10)
        ));
      }
      return $2.extend(true, {
        width,
        /* width *required */
        height,
        /* height *required */
        tileSize,
        /* tileSize *required */
        tileOverlap,
        /* tileOverlap *required */
        minLevel: null,
        /* minLevel */
        maxLevel: null,
        /* maxLevel */
        tilesUrl,
        /* tilesUrl */
        fileFormat,
        /* fileFormat */
        displayRects
        /* displayRects */
      }, configuration);
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.IIIFTileSource = function(options) {
      $2.extend(true, this, options);
      this._id = this["@id"] || this["id"] || this["identifier"] || null;
      if (!(this.height && this.width && this._id)) {
        throw new Error("IIIF required parameters (width, height, or id) not provided.");
      }
      options.tileSizePerScaleFactor = {};
      this.tileFormat = this.tileFormat || "jpg";
      this.version = options.version;
      if (this.tile_width && this.tile_height) {
        options.tileWidth = this.tile_width;
        options.tileHeight = this.tile_height;
      } else if (this.tile_width) {
        options.tileSize = this.tile_width;
      } else if (this.tile_height) {
        options.tileSize = this.tile_height;
      } else if (this.tiles) {
        if (this.tiles.length === 1) {
          options.tileWidth = this.tiles[0].width;
          options.tileHeight = this.tiles[0].height || this.tiles[0].width;
          this.scale_factors = this.tiles[0].scaleFactors;
        } else {
          this.scale_factors = [];
          for (var t = 0; t < this.tiles.length; t++) {
            for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {
              var scaleFactor = this.tiles[t].scaleFactors[sf];
              this.scale_factors.push(scaleFactor);
              options.tileSizePerScaleFactor[scaleFactor] = {
                width: this.tiles[t].width,
                height: this.tiles[t].height || this.tiles[t].width
              };
            }
          }
        }
      } else if (canBeTiled(options)) {
        var shortDim = Math.min(this.height, this.width), tileOptions = [256, 512, 1024], smallerTiles = [];
        for (var c = 0; c < tileOptions.length; c++) {
          if (tileOptions[c] <= shortDim) {
            smallerTiles.push(tileOptions[c]);
          }
        }
        if (smallerTiles.length > 0) {
          options.tileSize = Math.max.apply(null, smallerTiles);
        } else {
          options.tileSize = shortDim;
        }
      } else if (this.sizes && this.sizes.length > 0) {
        this.emulateLegacyImagePyramid = true;
        options.levels = constructLevels(this);
        $2.extend(true, options, {
          width: options.levels[options.levels.length - 1].width,
          height: options.levels[options.levels.length - 1].height,
          tileSize: Math.max(options.height, options.width),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: options.levels.length - 1
        });
        this.levels = options.levels;
      } else {
        $2.console.error("Nothing in the info.json to construct image pyramids from");
      }
      if (!options.maxLevel && !this.emulateLegacyImagePyramid) {
        if (!this.scale_factors) {
          options.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
        } else {
          var maxScaleFactor = Math.max.apply(null, this.scale_factors);
          options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
        }
      }
      if (this.sizes) {
        var sizeLength = this.sizes.length;
        if (sizeLength === options.maxLevel || sizeLength === options.maxLevel + 1) {
          this.levelSizes = this.sizes.slice().sort(function(size1, size2) {
            return size1.width - size2.width;
          });
          if (sizeLength === options.maxLevel) {
            this.levelSizes.push({ width: this.width, height: this.height });
          }
        }
      }
      $2.TileSource.apply(this, [options]);
    };
    $2.extend(
      $2.IIIFTileSource.prototype,
      $2.TileSource.prototype,
      /** @lends OpenSeadragon.IIIFTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} [url] - url
         */
        supports: function(data, url) {
          if (data.protocol && data.protocol === "http://iiif.io/api/image") {
            return true;
          } else if (data["@context"] && (data["@context"] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" || data["@context"] === "http://iiif.io/api/image/1/context.json")) {
            return true;
          } else if (data.profile && data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
            return true;
          } else if (data.identifier && data.width && data.height) {
            return true;
          } else if (data.documentElement && "info" === data.documentElement.tagName && "http://library.stanford.edu/iiif/image-api/ns/" === data.documentElement.namespaceURI) {
            return true;
          } else {
            return false;
          }
        },
        /**
         * A static function used to prepare an incoming IIIF Image API info.json
         * response for processing by the tile handler. Normalizes data for all
         * versions of IIIF (1.0, 1.1, 2.x, 3.x) and returns a data object that
         * may be passed to the IIIFTileSource.
         *
         * @function
         * @static
         * @param {Object} data - the raw configuration
         * @param {String} url - the url configuration was retrieved from
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} A normalized IIIF data object
         * @example <caption>IIIF 2.x Info Looks like this</caption>
         * {
         * "@context": "http://iiif.io/api/image/2/context.json",
         * "@id": "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
         * "protocol": "http://iiif.io/api/image",
         * "height": 1024,
         * "width": 775,
         * "tiles" : [{"width":256, "scaleFactors":[1,2,4,8]}],
         *  "profile": ["http://iiif.io/api/image/2/level1.json", {
         *    "qualities": [ "native", "bitonal", "grey", "color" ],
         *    "formats": [ "jpg", "png", "gif" ]
         *   }]
         * }
         */
        configure: function(data, url, postData) {
          if (!$2.isPlainObject(data)) {
            var options = configureFromXml10(data);
            options["@context"] = "http://iiif.io/api/image/1.0/context.json";
            options["@id"] = url.replace("/info.xml", "");
            options.version = 1;
            return options;
          } else {
            if (!data["@context"]) {
              data["@context"] = "http://iiif.io/api/image/1.0/context.json";
              data["@id"] = url.replace("/info.json", "");
              data.version = 1;
            } else {
              var context = data["@context"];
              if (Array.isArray(context)) {
                for (var i = 0; i < context.length; i++) {
                  if (typeof context[i] === "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i]) || context[i] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                    context = context[i];
                    break;
                  }
                }
              }
              switch (context) {
                case "http://iiif.io/api/image/1/context.json":
                case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                  data.version = 1;
                  break;
                case "http://iiif.io/api/image/2/context.json":
                  data.version = 2;
                  break;
                case "http://iiif.io/api/image/3/context.json":
                  data.version = 3;
                  break;
                default:
                  $2.console.error("Data has a @context property which contains no known IIIF context URI.");
              }
            }
            if (data.preferredFormats) {
              for (var f = 0; f < data.preferredFormats.length; f++) {
                if (OpenSeadragon2.imageFormatSupported(data.preferredFormats[f])) {
                  data.tileFormat = data.preferredFormats[f];
                  break;
                }
              }
            }
            return data;
          }
        },
        /**
         * Return the tileWidth for the given level.
         * @function
         * @param {Number} level
         */
        getTileWidth: function(level) {
          if (this.emulateLegacyImagePyramid) {
            return $2.TileSource.prototype.getTileWidth.call(this, level);
          }
          var scaleFactor = Math.pow(2, this.maxLevel - level);
          if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
            return this.tileSizePerScaleFactor[scaleFactor].width;
          }
          return this._tileWidth;
        },
        /**
         * Return the tileHeight for the given level.
         * @function
         * @param {Number} level
         */
        getTileHeight: function(level) {
          if (this.emulateLegacyImagePyramid) {
            return $2.TileSource.prototype.getTileHeight.call(this, level);
          }
          var scaleFactor = Math.pow(2, this.maxLevel - level);
          if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
            return this.tileSizePerScaleFactor[scaleFactor].height;
          }
          return this._tileHeight;
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(level) {
          if (this.emulateLegacyImagePyramid) {
            var levelScale = NaN;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            }
            return levelScale;
          }
          return $2.TileSource.prototype.getLevelScale.call(this, level);
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(level) {
          if (this.emulateLegacyImagePyramid) {
            var scale = this.getLevelScale(level);
            if (scale) {
              return new $2.Point(1, 1);
            } else {
              return new $2.Point(0, 0);
            }
          }
          if (this.levelSizes) {
            var levelSize = this.levelSizes[level];
            var x2 = Math.ceil(levelSize.width / this.getTileWidth(level)), y = Math.ceil(levelSize.height / this.getTileHeight(level));
            return new $2.Point(x2, y);
          } else {
            return $2.TileSource.prototype.getNumTiles.call(this, level);
          }
        },
        /**
         * @function
         * @param {Number} level
         * @param {OpenSeadragon.Point} point
         */
        getTileAtPoint: function(level, point) {
          if (this.emulateLegacyImagePyramid) {
            return new $2.Point(0, 0);
          }
          if (this.levelSizes) {
            var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
            $2.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
            var widthScaled = this.levelSizes[level].width;
            var pixelX = point.x * widthScaled;
            var pixelY = point.y * widthScaled;
            var x2 = Math.floor(pixelX / this.getTileWidth(level));
            var y = Math.floor(pixelY / this.getTileHeight(level));
            if (point.x >= 1) {
              x2 = this.getNumTiles(level).x - 1;
            }
            var EPSILON = 1e-15;
            if (point.y >= 1 / this.aspectRatio - EPSILON) {
              y = this.getNumTiles(level).y - 1;
            }
            return new $2.Point(x2, y);
          }
          return $2.TileSource.prototype.getTileAtPoint.call(this, level, point);
        },
        /**
         * Responsible for retrieving the url which will return an image for the
         * region specified by the given x, y, and level components.
         * @function
         * @param {Number} level - z index
         * @param {Number} x
         * @param {Number} y
         * @throws {Error}
         */
        getTileUrl: function(level, x2, y) {
          if (this.emulateLegacyImagePyramid) {
            var url = null;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              url = this.levels[level].url;
            }
            return url;
          }
          var IIIF_ROTATION = "0", scale = Math.pow(0.5, this.maxLevel - level), levelWidth, levelHeight, tileWidth, tileHeight, iiifTileSizeWidth, iiifTileSizeHeight, iiifRegion, iiifTileX, iiifTileY, iiifTileW, iiifTileH, iiifSize, iiifSizeW, iiifSizeH, iiifQuality, uri;
          if (this.levelSizes) {
            levelWidth = this.levelSizes[level].width;
            levelHeight = this.levelSizes[level].height;
          } else {
            levelWidth = Math.ceil(this.width * scale);
            levelHeight = Math.ceil(this.height * scale);
          }
          tileWidth = this.getTileWidth(level);
          tileHeight = this.getTileHeight(level);
          iiifTileSizeWidth = Math.round(tileWidth / scale);
          iiifTileSizeHeight = Math.round(tileHeight / scale);
          if (this.version === 1) {
            iiifQuality = "native." + this.tileFormat;
          } else {
            iiifQuality = "default." + this.tileFormat;
          }
          if (levelWidth < tileWidth && levelHeight < tileHeight) {
            if (this.version === 2 && levelWidth === this.width) {
              iiifSize = "full";
            } else if (this.version === 3 && levelWidth === this.width && levelHeight === this.height) {
              iiifSize = "max";
            } else if (this.version === 3) {
              iiifSize = levelWidth + "," + levelHeight;
            } else {
              iiifSize = levelWidth + ",";
            }
            iiifRegion = "full";
          } else {
            iiifTileX = x2 * iiifTileSizeWidth;
            iiifTileY = y * iiifTileSizeHeight;
            iiifTileW = Math.min(iiifTileSizeWidth, this.width - iiifTileX);
            iiifTileH = Math.min(iiifTileSizeHeight, this.height - iiifTileY);
            if (x2 === 0 && y === 0 && iiifTileW === this.width && iiifTileH === this.height) {
              iiifRegion = "full";
            } else {
              iiifRegion = [iiifTileX, iiifTileY, iiifTileW, iiifTileH].join(",");
            }
            iiifSizeW = Math.min(tileWidth, levelWidth - x2 * tileWidth);
            iiifSizeH = Math.min(tileHeight, levelHeight - y * tileHeight);
            if (this.version === 2 && iiifSizeW === this.width) {
              iiifSize = "full";
            } else if (this.version === 3 && iiifSizeW === this.width && iiifSizeH === this.height) {
              iiifSize = "max";
            } else if (this.version === 3) {
              iiifSize = iiifSizeW + "," + iiifSizeH;
            } else {
              iiifSize = iiifSizeW + ",";
            }
          }
          uri = [this._id, iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality].join("/");
          return uri;
        },
        __testonly__: {
          canBeTiled,
          constructLevels
        }
      }
    );
    function canBeTiled(options) {
      var level0Profiles = [
        "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
        "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
        "http://iiif.io/api/image/2/level0.json",
        "level0",
        "https://iiif.io/api/image/3/level0.json"
      ];
      var profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
      var isLevel0 = level0Profiles.indexOf(profileLevel) !== -1;
      var hasCanoncicalSizeFeature = false;
      if (options.version === 2 && options.profile.length > 1 && options.profile[1].supports) {
        hasCanoncicalSizeFeature = options.profile[1].supports.indexOf("sizeByW") !== -1;
      }
      if (options.version === 3 && options.extraFeatures) {
        hasCanoncicalSizeFeature = options.extraFeatures.indexOf("sizeByWh") !== -1;
      }
      return !isLevel0 || hasCanoncicalSizeFeature;
    }
    function constructLevels(options) {
      var levels = [];
      for (var i = 0; i < options.sizes.length; i++) {
        levels.push({
          url: options._id + "/full/" + options.sizes[i].width + "," + (options.version === 3 ? options.sizes[i].height : "") + "/0/default." + options.tileFormat,
          width: options.sizes[i].width,
          height: options.sizes[i].height
        });
      }
      return levels.sort(function(a, b) {
        return a.width - b.width;
      });
    }
    function configureFromXml10(xmlDoc) {
      if (!xmlDoc || !xmlDoc.documentElement) {
        throw new Error($2.getString("Errors.Xml"));
      }
      var root2 = xmlDoc.documentElement, rootName = root2.tagName, configuration = null;
      if (rootName === "info") {
        try {
          configuration = {};
          parseXML10(root2, configuration);
          return configuration;
        } catch (e) {
          throw e instanceof Error ? e : new Error($2.getString("Errors.IIIF"));
        }
      }
      throw new Error($2.getString("Errors.IIIF"));
    }
    function parseXML10(node, configuration, property2) {
      var i, value;
      if (node.nodeType === 3 && property2) {
        value = node.nodeValue.trim();
        if (value.match(/^\d*$/)) {
          value = Number(value);
        }
        if (!configuration[property2]) {
          configuration[property2] = value;
        } else {
          if (!$2.isArray(configuration[property2])) {
            configuration[property2] = [configuration[property2]];
          }
          configuration[property2].push(value);
        }
      } else if (node.nodeType === 1) {
        for (i = 0; i < node.childNodes.length; i++) {
          parseXML10(node.childNodes[i], configuration, node.nodeName);
        }
      }
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.OsmTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
      var options;
      if ($2.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        };
      }
      if (!options.width || !options.height) {
        options.width = 65572864;
        options.height = 65572864;
      }
      if (!options.tileSize) {
        options.tileSize = 256;
        options.tileOverlap = 0;
      }
      if (!options.tilesUrl) {
        options.tilesUrl = "http://tile.openstreetmap.org/";
      }
      options.minLevel = 8;
      $2.TileSource.apply(this, [options]);
    };
    $2.extend(
      $2.OsmTileSource.prototype,
      $2.TileSource.prototype,
      /** @lends OpenSeadragon.OsmTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(data, url) {
          return data.type && "openstreetmaps" === data.type;
        },
        /**
         *
         * @function
         * @param {Object} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(data, url, postData) {
          return data;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(level, x2, y) {
          return this.tilesUrl + (level - 8) + "/" + x2 + "/" + y + ".png";
        }
      }
    );
  })(OpenSeadragon2);
  (function($2) {
    $2.TmsTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
      var options;
      if ($2.isPlainObject(width)) {
        options = width;
      } else {
        options = {
          width: arguments[0],
          height: arguments[1],
          tileSize: arguments[2],
          tileOverlap: arguments[3],
          tilesUrl: arguments[4]
        };
      }
      var bufferedWidth = Math.ceil(options.width / 256) * 256, bufferedHeight = Math.ceil(options.height / 256) * 256, max;
      if (bufferedWidth > bufferedHeight) {
        max = bufferedWidth / 256;
      } else {
        max = bufferedHeight / 256;
      }
      options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
      options.tileSize = 256;
      options.width = bufferedWidth;
      options.height = bufferedHeight;
      $2.TileSource.apply(this, [options]);
    };
    $2.extend(
      $2.TmsTileSource.prototype,
      $2.TileSource.prototype,
      /** @lends OpenSeadragon.TmsTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(data, url) {
          return data.type && "tiledmapservice" === data.type;
        },
        /**
         *
         * @function
         * @param {Object} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(data, url, postData) {
          return data;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(level, x2, y) {
          var yTiles = this.getNumTiles(level).y - 1;
          return this.tilesUrl + level + "/" + x2 + "/" + (yTiles - y) + ".png";
        }
      }
    );
  })(OpenSeadragon2);
  (function($2) {
    $2.ZoomifyTileSource = function(options) {
      if (typeof options.tileSize === "undefined") {
        options.tileSize = 256;
      }
      if (typeof options.fileFormat === "undefined") {
        options.fileFormat = "jpg";
        this.fileFormat = options.fileFormat;
      }
      var currentImageSize = {
        x: options.width,
        y: options.height
      };
      options.imageSizes = [{
        x: options.width,
        y: options.height
      }];
      options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];
      while (parseInt(currentImageSize.x, 10) > options.tileSize || parseInt(currentImageSize.y, 10) > options.tileSize) {
        currentImageSize.x = Math.floor(currentImageSize.x / 2);
        currentImageSize.y = Math.floor(currentImageSize.y / 2);
        options.imageSizes.push({
          x: currentImageSize.x,
          y: currentImageSize.y
        });
        options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
      }
      options.imageSizes.reverse();
      options.gridSize.reverse();
      options.minLevel = 0;
      options.maxLevel = options.gridSize.length - 1;
      OpenSeadragon2.TileSource.apply(this, [options]);
    };
    $2.extend(
      $2.ZoomifyTileSource.prototype,
      $2.TileSource.prototype,
      /** @lends OpenSeadragon.ZoomifyTileSource.prototype */
      {
        //private
        _getGridSize: function(width, height, tileSize) {
          return {
            x: Math.ceil(width / tileSize),
            y: Math.ceil(height / tileSize)
          };
        },
        //private
        _calculateAbsoluteTileNumber: function(level, x2, y) {
          var num = 0;
          var size = {};
          for (var z2 = 0; z2 < level; z2++) {
            size = this.gridSize[z2];
            num += size.x * size.y;
          }
          size = this.gridSize[level];
          num += size.x * y + x2;
          return num;
        },
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(data, url) {
          return data.type && "zoomifytileservice" === data.type;
        },
        /**
         *
         * @function
         * @param {Object} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(data, url, postData) {
          return data;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(level, x2, y) {
          var result = 0;
          var num = this._calculateAbsoluteTileNumber(level, x2, y);
          result = Math.floor(num / 256);
          return this.tilesUrl + "TileGroup" + result + "/" + level + "-" + x2 + "-" + y + "." + this.fileFormat;
        }
      }
    );
  })(OpenSeadragon2);
  (function($2) {
    $2.LegacyTileSource = function(levels) {
      var options, width, height;
      if ($2.isArray(levels)) {
        options = {
          type: "legacy-image-pyramid",
          levels
        };
      }
      options.levels = filterFiles(options.levels);
      if (options.levels.length > 0) {
        width = options.levels[options.levels.length - 1].width;
        height = options.levels[options.levels.length - 1].height;
      } else {
        width = 0;
        height = 0;
        $2.console.error("No supported image formats found");
      }
      $2.extend(true, options, {
        width,
        height,
        tileSize: Math.max(height, width),
        tileOverlap: 0,
        minLevel: 0,
        maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
      });
      $2.TileSource.apply(this, [options]);
      this.levels = options.levels;
    };
    $2.extend(
      $2.LegacyTileSource.prototype,
      $2.TileSource.prototype,
      /** @lends OpenSeadragon.LegacyTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(data, url) {
          return data.type && "legacy-image-pyramid" === data.type || data.documentElement && "legacy-image-pyramid" === data.documentElement.getAttribute("type");
        },
        /**
         *
         * @function
         * @param {Object|XMLDocument} configuration - the raw configuration
         * @param {String} dataUrl - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(configuration, dataUrl, postData) {
          var options;
          if (!$2.isPlainObject(configuration)) {
            options = configureFromXML(this, configuration);
          } else {
            options = configureFromObject(this, configuration);
          }
          return options;
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(level) {
          var levelScale = NaN;
          if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
            levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
          }
          return levelScale;
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(level) {
          var scale = this.getLevelScale(level);
          if (scale) {
            return new $2.Point(1, 1);
          } else {
            return new $2.Point(0, 0);
          }
        },
        /**
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @throws {Error}
         */
        getTileUrl: function(level, x2, y) {
          var url = null;
          if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
            url = this.levels[level].url;
          }
          return url;
        }
      }
    );
    function filterFiles(files) {
      var filtered = [], file, i;
      for (i = 0; i < files.length; i++) {
        file = files[i];
        if (file.height && file.width && file.url) {
          filtered.push({
            url: file.url,
            width: Number(file.width),
            height: Number(file.height)
          });
        } else {
          $2.console.error("Unsupported image format: %s", file.url ? file.url : "<no URL>");
        }
      }
      return filtered.sort(function(a, b) {
        return a.height - b.height;
      });
    }
    function configureFromXML(tileSource, xmlDoc) {
      if (!xmlDoc || !xmlDoc.documentElement) {
        throw new Error($2.getString("Errors.Xml"));
      }
      var root2 = xmlDoc.documentElement, rootName = root2.tagName, conf = null, levels = [], level, i;
      if (rootName === "image") {
        try {
          conf = {
            type: root2.getAttribute("type"),
            levels: []
          };
          levels = root2.getElementsByTagName("level");
          for (i = 0; i < levels.length; i++) {
            level = levels[i];
            conf.levels.push({
              url: level.getAttribute("url"),
              width: parseInt(level.getAttribute("width"), 10),
              height: parseInt(level.getAttribute("height"), 10)
            });
          }
          return configureFromObject(tileSource, conf);
        } catch (e) {
          throw e instanceof Error ? e : new Error("Unknown error parsing Legacy Image Pyramid XML.");
        }
      } else if (rootName === "collection") {
        throw new Error("Legacy Image Pyramid Collections not yet supported.");
      } else if (rootName === "error") {
        throw new Error("Error: " + xmlDoc);
      }
      throw new Error("Unknown element " + rootName);
    }
    function configureFromObject(tileSource, configuration) {
      return configuration.levels;
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.ImageTileSource = function(options) {
      options = $2.extend({
        buildPyramid: true,
        crossOriginPolicy: false,
        ajaxWithCredentials: false,
        useCanvas: true
      }, options);
      $2.TileSource.apply(this, [options]);
    };
    $2.extend(
      $2.ImageTileSource.prototype,
      $2.TileSource.prototype,
      /** @lends OpenSeadragon.ImageTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(data, url) {
          return data.type && data.type === "image";
        },
        /**
         *
         * @function
         * @param {Object} options - the options
         * @param {String} dataUrl - the url the image was retrieved from, if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(options, dataUrl, postData) {
          return options;
        },
        /**
         * Responsible for retrieving, and caching the
         * image metadata pertinent to this TileSources implementation.
         * @function
         * @param {String} url
         * @throws {Error}
         */
        getImageInfo: function(url) {
          var image = this._image = new Image();
          var _this = this;
          if (this.crossOriginPolicy) {
            image.crossOrigin = this.crossOriginPolicy;
          }
          if (this.ajaxWithCredentials) {
            image.useCredentials = this.ajaxWithCredentials;
          }
          $2.addEvent(image, "load", function() {
            _this.width = image.naturalWidth;
            _this.height = image.naturalHeight;
            _this.aspectRatio = _this.width / _this.height;
            _this.dimensions = new $2.Point(_this.width, _this.height);
            _this._tileWidth = _this.width;
            _this._tileHeight = _this.height;
            _this.tileOverlap = 0;
            _this.minLevel = 0;
            _this.levels = _this._buildLevels();
            _this.maxLevel = _this.levels.length - 1;
            _this.ready = true;
            _this.raiseEvent("ready", { tileSource: _this });
          });
          $2.addEvent(image, "error", function() {
            _this.raiseEvent("open-failed", {
              message: "Error loading image at " + url,
              source: url
            });
          });
          image.src = url;
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(level) {
          var levelScale = NaN;
          if (level >= this.minLevel && level <= this.maxLevel) {
            levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
          }
          return levelScale;
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(level) {
          var scale = this.getLevelScale(level);
          if (scale) {
            return new $2.Point(1, 1);
          } else {
            return new $2.Point(0, 0);
          }
        },
        /**
         * Retrieves a tile url
         * @function
         * @param {Number} level Level of the tile
         * @param {Number} x x coordinate of the tile
         * @param {Number} y y coordinate of the tile
         */
        getTileUrl: function(level, x2, y) {
          var url = null;
          if (level >= this.minLevel && level <= this.maxLevel) {
            url = this.levels[level].url;
          }
          return url;
        },
        /**
         * Retrieves a tile context 2D
         * @function
         * @param {Number} level Level of the tile
         * @param {Number} x x coordinate of the tile
         * @param {Number} y y coordinate of the tile
         */
        getContext2D: function(level, x2, y) {
          var context = null;
          if (level >= this.minLevel && level <= this.maxLevel) {
            context = this.levels[level].context2D;
          }
          return context;
        },
        /**
         * Destroys ImageTileSource
         * @function
         */
        destroy: function() {
          this._freeupCanvasMemory();
        },
        // private
        //
        // Builds the different levels of the pyramid if possible
        // (i.e. if canvas API enabled and no canvas tainting issue).
        _buildLevels: function() {
          var levels = [{
            url: this._image.src,
            width: this._image.naturalWidth,
            height: this._image.naturalHeight
          }];
          if (!this.buildPyramid || !$2.supportsCanvas || !this.useCanvas) {
            delete this._image;
            return levels;
          }
          var currentWidth = this._image.naturalWidth;
          var currentHeight = this._image.naturalHeight;
          var bigCanvas = document.createElement("canvas");
          var bigContext = bigCanvas.getContext("2d");
          bigCanvas.width = currentWidth;
          bigCanvas.height = currentHeight;
          bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);
          levels[0].context2D = bigContext;
          delete this._image;
          if ($2.isCanvasTainted(bigCanvas)) {
            return levels;
          }
          while (currentWidth >= 2 && currentHeight >= 2) {
            currentWidth = Math.floor(currentWidth / 2);
            currentHeight = Math.floor(currentHeight / 2);
            var smallCanvas = document.createElement("canvas");
            var smallContext = smallCanvas.getContext("2d");
            smallCanvas.width = currentWidth;
            smallCanvas.height = currentHeight;
            smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);
            levels.splice(0, 0, {
              context2D: smallContext,
              width: currentWidth,
              height: currentHeight
            });
            bigCanvas = smallCanvas;
            bigContext = smallContext;
          }
          return levels;
        },
        /**
         * Free up canvas memory
         * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
         * and Safari keeps canvas until its height and width will be set to 0).
         * @function
         */
        _freeupCanvasMemory: function() {
          for (var i = 0; i < this.levels.length; i++) {
            if (this.levels[i].context2D) {
              this.levels[i].context2D.canvas.height = 0;
              this.levels[i].context2D.canvas.width = 0;
            }
          }
        }
      }
    );
  })(OpenSeadragon2);
  (function($2) {
    $2.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
      $2.console.error("TileSourceCollection is deprecated; use World instead");
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.ButtonState = {
      REST: 0,
      GROUP: 1,
      HOVER: 2,
      DOWN: 3
    };
    $2.Button = function(options) {
      var _this = this;
      $2.EventSource.call(this);
      $2.extend(true, this, {
        tooltip: null,
        srcRest: null,
        srcGroup: null,
        srcHover: null,
        srcDown: null,
        clickTimeThreshold: $2.DEFAULT_SETTINGS.clickTimeThreshold,
        clickDistThreshold: $2.DEFAULT_SETTINGS.clickDistThreshold,
        /**
         * How long to wait before fading.
         * @member {Number} fadeDelay
         * @memberof OpenSeadragon.Button#
         */
        fadeDelay: 0,
        /**
         * How long should it take to fade the button.
         * @member {Number} fadeLength
         * @memberof OpenSeadragon.Button#
         */
        fadeLength: 2e3,
        onPress: null,
        onRelease: null,
        onClick: null,
        onEnter: null,
        onExit: null,
        onFocus: null,
        onBlur: null,
        userData: null
      }, options);
      this.element = options.element || $2.makeNeutralElement("div");
      if (!options.element) {
        this.imgRest = $2.makeTransparentImage(this.srcRest);
        this.imgGroup = $2.makeTransparentImage(this.srcGroup);
        this.imgHover = $2.makeTransparentImage(this.srcHover);
        this.imgDown = $2.makeTransparentImage(this.srcDown);
        this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip;
        $2.setElementPointerEventsNone(this.imgRest);
        $2.setElementPointerEventsNone(this.imgGroup);
        $2.setElementPointerEventsNone(this.imgHover);
        $2.setElementPointerEventsNone(this.imgDown);
        this.element.style.position = "relative";
        $2.setElementTouchActionNone(this.element);
        this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute";
        this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px";
        this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px";
        this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden";
        if ($2.Browser.vendor === $2.BROWSERS.FIREFOX && $2.Browser.version < 3) {
          this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "";
        }
        this.element.appendChild(this.imgRest);
        this.element.appendChild(this.imgGroup);
        this.element.appendChild(this.imgHover);
        this.element.appendChild(this.imgDown);
      }
      this.addHandler("press", this.onPress);
      this.addHandler("release", this.onRelease);
      this.addHandler("click", this.onClick);
      this.addHandler("enter", this.onEnter);
      this.addHandler("exit", this.onExit);
      this.addHandler("focus", this.onFocus);
      this.addHandler("blur", this.onBlur);
      this.currentState = $2.ButtonState.GROUP;
      this.fadeBeginTime = null;
      this.shouldFade = false;
      this.element.style.display = "inline-block";
      this.element.style.position = "relative";
      this.element.title = this.tooltip;
      this.tracker = new $2.MouseTracker({
        userData: "Button.tracker",
        element: this.element,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        enterHandler: function(event) {
          if (event.insideElementPressed) {
            inTo(_this, $2.ButtonState.DOWN);
            _this.raiseEvent("enter", { originalEvent: event.originalEvent });
          } else if (!event.buttonDownAny) {
            inTo(_this, $2.ButtonState.HOVER);
          }
        },
        focusHandler: function(event) {
          _this.tracker.enterHandler(event);
          _this.raiseEvent("focus", { originalEvent: event.originalEvent });
        },
        leaveHandler: function(event) {
          outTo(_this, $2.ButtonState.GROUP);
          if (event.insideElementPressed) {
            _this.raiseEvent("exit", { originalEvent: event.originalEvent });
          }
        },
        blurHandler: function(event) {
          _this.tracker.leaveHandler(event);
          _this.raiseEvent("blur", { originalEvent: event.originalEvent });
        },
        pressHandler: function(event) {
          inTo(_this, $2.ButtonState.DOWN);
          _this.raiseEvent("press", { originalEvent: event.originalEvent });
        },
        releaseHandler: function(event) {
          if (event.insideElementPressed && event.insideElementReleased) {
            outTo(_this, $2.ButtonState.HOVER);
            _this.raiseEvent("release", { originalEvent: event.originalEvent });
          } else if (event.insideElementPressed) {
            outTo(_this, $2.ButtonState.GROUP);
          } else {
            inTo(_this, $2.ButtonState.HOVER);
          }
        },
        clickHandler: function(event) {
          if (event.quick) {
            _this.raiseEvent("click", { originalEvent: event.originalEvent });
          }
        },
        keyHandler: function(event) {
          if (13 === event.keyCode) {
            _this.raiseEvent("click", { originalEvent: event.originalEvent });
            _this.raiseEvent("release", { originalEvent: event.originalEvent });
            event.preventDefault = true;
          } else {
            event.preventDefault = false;
          }
        }
      });
      outTo(this, $2.ButtonState.REST);
    };
    $2.extend(
      $2.Button.prototype,
      $2.EventSource.prototype,
      /** @lends OpenSeadragon.Button.prototype */
      {
        /**
         * Used by a button container element (e.g. a ButtonGroup) to transition the button state
         * to ButtonState.GROUP.
         * @function
         */
        notifyGroupEnter: function() {
          inTo(this, $2.ButtonState.GROUP);
        },
        /**
         * Used by a button container element (e.g. a ButtonGroup) to transition the button state
         * to ButtonState.REST.
         * @function
         */
        notifyGroupExit: function() {
          outTo(this, $2.ButtonState.REST);
        },
        /**
         * @function
         */
        disable: function() {
          this.notifyGroupExit();
          this.element.disabled = true;
          this.tracker.setTracking(false);
          $2.setElementOpacity(this.element, 0.2, true);
        },
        /**
         * @function
         */
        enable: function() {
          this.element.disabled = false;
          this.tracker.setTracking(true);
          $2.setElementOpacity(this.element, 1, true);
          this.notifyGroupEnter();
        },
        destroy: function() {
          if (this.imgRest) {
            this.element.removeChild(this.imgRest);
            this.imgRest = null;
          }
          if (this.imgGroup) {
            this.element.removeChild(this.imgGroup);
            this.imgGroup = null;
          }
          if (this.imgHover) {
            this.element.removeChild(this.imgHover);
            this.imgHover = null;
          }
          if (this.imgDown) {
            this.element.removeChild(this.imgDown);
            this.imgDown = null;
          }
          this.removeAllHandlers();
          this.tracker.destroy();
          this.element = null;
        }
      }
    );
    function scheduleFade(button) {
      $2.requestAnimationFrame(function() {
        updateFade(button);
      });
    }
    function updateFade(button) {
      var currentTime, deltaTime, opacity;
      if (button.shouldFade) {
        currentTime = $2.now();
        deltaTime = currentTime - button.fadeBeginTime;
        opacity = 1 - deltaTime / button.fadeLength;
        opacity = Math.min(1, opacity);
        opacity = Math.max(0, opacity);
        if (button.imgGroup) {
          $2.setElementOpacity(button.imgGroup, opacity, true);
        }
        if (opacity > 0) {
          scheduleFade(button);
        }
      }
    }
    function beginFading(button) {
      button.shouldFade = true;
      button.fadeBeginTime = $2.now() + button.fadeDelay;
      window.setTimeout(function() {
        scheduleFade(button);
      }, button.fadeDelay);
    }
    function stopFading(button) {
      button.shouldFade = false;
      if (button.imgGroup) {
        $2.setElementOpacity(button.imgGroup, 1, true);
      }
    }
    function inTo(button, newState) {
      if (button.element.disabled) {
        return;
      }
      if (newState >= $2.ButtonState.GROUP && button.currentState === $2.ButtonState.REST) {
        stopFading(button);
        button.currentState = $2.ButtonState.GROUP;
      }
      if (newState >= $2.ButtonState.HOVER && button.currentState === $2.ButtonState.GROUP) {
        if (button.imgHover) {
          button.imgHover.style.visibility = "";
        }
        button.currentState = $2.ButtonState.HOVER;
      }
      if (newState >= $2.ButtonState.DOWN && button.currentState === $2.ButtonState.HOVER) {
        if (button.imgDown) {
          button.imgDown.style.visibility = "";
        }
        button.currentState = $2.ButtonState.DOWN;
      }
    }
    function outTo(button, newState) {
      if (button.element.disabled) {
        return;
      }
      if (newState <= $2.ButtonState.HOVER && button.currentState === $2.ButtonState.DOWN) {
        if (button.imgDown) {
          button.imgDown.style.visibility = "hidden";
        }
        button.currentState = $2.ButtonState.HOVER;
      }
      if (newState <= $2.ButtonState.GROUP && button.currentState === $2.ButtonState.HOVER) {
        if (button.imgHover) {
          button.imgHover.style.visibility = "hidden";
        }
        button.currentState = $2.ButtonState.GROUP;
      }
      if (newState <= $2.ButtonState.REST && button.currentState === $2.ButtonState.GROUP) {
        beginFading(button);
        button.currentState = $2.ButtonState.REST;
      }
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.ButtonGroup = function(options) {
      $2.extend(true, this, {
        /**
         * An array containing the buttons themselves.
         * @member {Array} buttons
         * @memberof OpenSeadragon.ButtonGroup#
         */
        buttons: [],
        clickTimeThreshold: $2.DEFAULT_SETTINGS.clickTimeThreshold,
        clickDistThreshold: $2.DEFAULT_SETTINGS.clickDistThreshold,
        labelText: ""
      }, options);
      var buttons = this.buttons.concat([]), _this = this, i;
      this.element = options.element || $2.makeNeutralElement("div");
      if (!options.group) {
        this.element.style.display = "inline-block";
        for (i = 0; i < buttons.length; i++) {
          this.element.appendChild(buttons[i].element);
        }
      }
      $2.setElementTouchActionNone(this.element);
      this.tracker = new $2.MouseTracker({
        userData: "ButtonGroup.tracker",
        element: this.element,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        enterHandler: function(event) {
          var i2;
          for (i2 = 0; i2 < _this.buttons.length; i2++) {
            _this.buttons[i2].notifyGroupEnter();
          }
        },
        leaveHandler: function(event) {
          var i2;
          if (!event.insideElementPressed) {
            for (i2 = 0; i2 < _this.buttons.length; i2++) {
              _this.buttons[i2].notifyGroupExit();
            }
          }
        }
      });
    };
    $2.ButtonGroup.prototype = {
      /**
       * Adds the given button to this button group.
       *
       * @function
       * @param {OpenSeadragon.Button} button
       */
      addButton: function(button) {
        this.buttons.push(button);
        this.element.appendChild(button.element);
      },
      /**
       * TODO: Figure out why this is used on the public API and if a more useful
       * api can be created.
       * @function
       * @private
       */
      emulateEnter: function() {
        this.tracker.enterHandler({ eventSource: this.tracker });
      },
      /**
       * TODO: Figure out why this is used on the public API and if a more useful
       * api can be created.
       * @function
       * @private
       */
      emulateLeave: function() {
        this.tracker.leaveHandler({ eventSource: this.tracker });
      },
      destroy: function() {
        while (this.buttons.length) {
          var button = this.buttons.pop();
          this.element.removeChild(button.element);
          button.destroy();
        }
        this.tracker.destroy();
        this.element = null;
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.Rect = function(x2, y, width, height, degrees) {
      this.x = typeof x2 === "number" ? x2 : 0;
      this.y = typeof y === "number" ? y : 0;
      this.width = typeof width === "number" ? width : 0;
      this.height = typeof height === "number" ? height : 0;
      this.degrees = typeof degrees === "number" ? degrees : 0;
      this.degrees = $2.positiveModulo(this.degrees, 360);
      var newTopLeft, newWidth;
      if (this.degrees >= 270) {
        newTopLeft = this.getTopRight();
        this.x = newTopLeft.x;
        this.y = newTopLeft.y;
        newWidth = this.height;
        this.height = this.width;
        this.width = newWidth;
        this.degrees -= 270;
      } else if (this.degrees >= 180) {
        newTopLeft = this.getBottomRight();
        this.x = newTopLeft.x;
        this.y = newTopLeft.y;
        this.degrees -= 180;
      } else if (this.degrees >= 90) {
        newTopLeft = this.getBottomLeft();
        this.x = newTopLeft.x;
        this.y = newTopLeft.y;
        newWidth = this.height;
        this.height = this.width;
        this.width = newWidth;
        this.degrees -= 90;
      }
    };
    $2.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
      var width = topLeft.distanceTo(topRight);
      var height = topLeft.distanceTo(bottomLeft);
      var diff = topRight.minus(topLeft);
      var radians = Math.atan(diff.y / diff.x);
      if (diff.x < 0) {
        radians += Math.PI;
      } else if (diff.y < 0) {
        radians += 2 * Math.PI;
      }
      return new $2.Rect(
        topLeft.x,
        topLeft.y,
        width,
        height,
        radians / Math.PI * 180
      );
    };
    $2.Rect.prototype = {
      /**
       * @function
       * @returns {OpenSeadragon.Rect} a duplicate of this Rect
       */
      clone: function() {
        return new $2.Rect(
          this.x,
          this.y,
          this.width,
          this.height,
          this.degrees
        );
      },
      /**
       * The aspect ratio is simply the ratio of width to height.
       * @function
       * @returns {Number} The ratio of width to height.
       */
      getAspectRatio: function() {
        return this.width / this.height;
      },
      /**
       * Provides the coordinates of the upper-left corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
       *  the rectangle.
       */
      getTopLeft: function() {
        return new $2.Point(
          this.x,
          this.y
        );
      },
      /**
       * Provides the coordinates of the bottom-right corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
       *  the rectangle.
       */
      getBottomRight: function() {
        return new $2.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Provides the coordinates of the top-right corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
       *  the rectangle.
       */
      getTopRight: function() {
        return new $2.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Provides the coordinates of the bottom-left corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
       *  the rectangle.
       */
      getBottomLeft: function() {
        return new $2.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Computes the center of the rectangle.
       * @function
       * @returns {OpenSeadragon.Point} The center of the rectangle as represented
       *  as represented by a 2-dimensional vector (x,y)
       */
      getCenter: function() {
        return new $2.Point(
          this.x + this.width / 2,
          this.y + this.height / 2
        ).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Returns the width and height component as a vector OpenSeadragon.Point
       * @function
       * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
       *  width and height of the rectangle.
       */
      getSize: function() {
        return new $2.Point(this.width, this.height);
      },
      /**
       * Determines if two Rectangles have equivalent components.
       * @function
       * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
       * @returns {Boolean} 'true' if all components are equal, otherwise 'false'.
       */
      equals: function(other) {
        return other instanceof $2.Rect && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height && this.degrees === other.degrees;
      },
      /**
      * Multiply all dimensions (except degrees) in this Rect by a factor and
      * return a new Rect.
      * @function
      * @param {Number} factor The factor to multiply vector components.
      * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
      *  of the vector components by the factor
      */
      times: function(factor) {
        return new $2.Rect(
          this.x * factor,
          this.y * factor,
          this.width * factor,
          this.height * factor,
          this.degrees
        );
      },
      /**
      * Translate/move this Rect by a vector and return new Rect.
      * @function
      * @param {OpenSeadragon.Point} delta The translation vector.
      * @returns {OpenSeadragon.Rect} A new rect with altered position
      */
      translate: function(delta) {
        return new $2.Rect(
          this.x + delta.x,
          this.y + delta.y,
          this.width,
          this.height,
          this.degrees
        );
      },
      /**
       * Returns the smallest rectangle that will contain this and the given
       * rectangle bounding boxes.
       * @param {OpenSeadragon.Rect} rect
       * @returns {OpenSeadragon.Rect} The new rectangle.
       */
      union: function(rect) {
        var thisBoundingBox = this.getBoundingBox();
        var otherBoundingBox = rect.getBoundingBox();
        var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
        var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
        var right = Math.max(
          thisBoundingBox.x + thisBoundingBox.width,
          otherBoundingBox.x + otherBoundingBox.width
        );
        var bottom = Math.max(
          thisBoundingBox.y + thisBoundingBox.height,
          otherBoundingBox.y + otherBoundingBox.height
        );
        return new $2.Rect(
          left,
          top,
          right - left,
          bottom - top
        );
      },
      /**
       * Returns the bounding box of the intersection of this rectangle with the
       * given rectangle.
       * @param {OpenSeadragon.Rect} rect
       * @returns {OpenSeadragon.Rect} the bounding box of the intersection
       * or null if the rectangles don't intersect.
       */
      intersection: function(rect) {
        var EPSILON = 1e-10;
        var intersectionPoints = [];
        var thisTopLeft = this.getTopLeft();
        if (rect.containsPoint(thisTopLeft, EPSILON)) {
          intersectionPoints.push(thisTopLeft);
        }
        var thisTopRight = this.getTopRight();
        if (rect.containsPoint(thisTopRight, EPSILON)) {
          intersectionPoints.push(thisTopRight);
        }
        var thisBottomLeft = this.getBottomLeft();
        if (rect.containsPoint(thisBottomLeft, EPSILON)) {
          intersectionPoints.push(thisBottomLeft);
        }
        var thisBottomRight = this.getBottomRight();
        if (rect.containsPoint(thisBottomRight, EPSILON)) {
          intersectionPoints.push(thisBottomRight);
        }
        var rectTopLeft = rect.getTopLeft();
        if (this.containsPoint(rectTopLeft, EPSILON)) {
          intersectionPoints.push(rectTopLeft);
        }
        var rectTopRight = rect.getTopRight();
        if (this.containsPoint(rectTopRight, EPSILON)) {
          intersectionPoints.push(rectTopRight);
        }
        var rectBottomLeft = rect.getBottomLeft();
        if (this.containsPoint(rectBottomLeft, EPSILON)) {
          intersectionPoints.push(rectBottomLeft);
        }
        var rectBottomRight = rect.getBottomRight();
        if (this.containsPoint(rectBottomRight, EPSILON)) {
          intersectionPoints.push(rectBottomRight);
        }
        var thisSegments = this._getSegments();
        var rectSegments = rect._getSegments();
        for (var i = 0; i < thisSegments.length; i++) {
          var thisSegment = thisSegments[i];
          for (var j = 0; j < rectSegments.length; j++) {
            var rectSegment = rectSegments[j];
            var intersect = getIntersection(
              thisSegment[0],
              thisSegment[1],
              rectSegment[0],
              rectSegment[1]
            );
            if (intersect) {
              intersectionPoints.push(intersect);
            }
          }
        }
        function getIntersection(a, b, c, d) {
          var abVector = b.minus(a);
          var cdVector = d.minus(c);
          var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
          if (denom === 0) {
            return null;
          }
          var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;
          var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;
          if (-EPSILON <= s && s <= 1 - EPSILON && -EPSILON <= t && t <= 1 - EPSILON) {
            return new $2.Point(a.x + t * abVector.x, a.y + t * abVector.y);
          }
          return null;
        }
        if (intersectionPoints.length === 0) {
          return null;
        }
        var minX = intersectionPoints[0].x;
        var maxX = intersectionPoints[0].x;
        var minY = intersectionPoints[0].y;
        var maxY = intersectionPoints[0].y;
        for (var k2 = 1; k2 < intersectionPoints.length; k2++) {
          var point = intersectionPoints[k2];
          if (point.x < minX) {
            minX = point.x;
          }
          if (point.x > maxX) {
            maxX = point.x;
          }
          if (point.y < minY) {
            minY = point.y;
          }
          if (point.y > maxY) {
            maxY = point.y;
          }
        }
        return new $2.Rect(minX, minY, maxX - minX, maxY - minY);
      },
      // private
      _getSegments: function() {
        var topLeft = this.getTopLeft();
        var topRight = this.getTopRight();
        var bottomLeft = this.getBottomLeft();
        var bottomRight = this.getBottomRight();
        return [
          [topLeft, topRight],
          [topRight, bottomRight],
          [bottomRight, bottomLeft],
          [bottomLeft, topLeft]
        ];
      },
      /**
       * Rotates a rectangle around a point.
       * @function
       * @param {Number} degrees The angle in degrees to rotate.
       * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
       * Defaults to the center of the rectangle.
       * @returns {OpenSeadragon.Rect}
       */
      rotate: function(degrees, pivot) {
        degrees = $2.positiveModulo(degrees, 360);
        if (degrees === 0) {
          return this.clone();
        }
        pivot = pivot || this.getCenter();
        var newTopLeft = this.getTopLeft().rotate(degrees, pivot);
        var newTopRight = this.getTopRight().rotate(degrees, pivot);
        var diff = newTopRight.minus(newTopLeft);
        diff = diff.apply(function(x2) {
          var EPSILON = 1e-15;
          return Math.abs(x2) < EPSILON ? 0 : x2;
        });
        var radians = Math.atan(diff.y / diff.x);
        if (diff.x < 0) {
          radians += Math.PI;
        } else if (diff.y < 0) {
          radians += 2 * Math.PI;
        }
        return new $2.Rect(
          newTopLeft.x,
          newTopLeft.y,
          this.width,
          this.height,
          radians / Math.PI * 180
        );
      },
      /**
       * Retrieves the smallest horizontal (degrees=0) rectangle which contains
       * this rectangle.
       * @returns {OpenSeadragon.Rect}
       */
      getBoundingBox: function() {
        if (this.degrees === 0) {
          return this.clone();
        }
        var topLeft = this.getTopLeft();
        var topRight = this.getTopRight();
        var bottomLeft = this.getBottomLeft();
        var bottomRight = this.getBottomRight();
        var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
        var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
        var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
        var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
        return new $2.Rect(
          minX,
          minY,
          maxX - minX,
          maxY - minY
        );
      },
      /**
       * Retrieves the smallest horizontal (degrees=0) rectangle which contains
       * this rectangle and has integers x, y, width and height
       * @returns {OpenSeadragon.Rect}
       */
      getIntegerBoundingBox: function() {
        var boundingBox = this.getBoundingBox();
        var x2 = Math.floor(boundingBox.x);
        var y = Math.floor(boundingBox.y);
        var width = Math.ceil(boundingBox.width + boundingBox.x - x2);
        var height = Math.ceil(boundingBox.height + boundingBox.y - y);
        return new $2.Rect(x2, y, width, height);
      },
      /**
       * Determines whether a point is inside this rectangle (edge included).
       * @function
       * @param {OpenSeadragon.Point} point
       * @param {Number} [epsilon=0] the margin of error allowed
       * @returns {Boolean} true if the point is inside this rectangle, false
       * otherwise.
       */
      containsPoint: function(point, epsilon) {
        epsilon = epsilon || 0;
        var topLeft = this.getTopLeft();
        var topRight = this.getTopRight();
        var bottomLeft = this.getBottomLeft();
        var topDiff = topRight.minus(topLeft);
        var leftDiff = bottomLeft.minus(topLeft);
        return (point.x - topLeft.x) * topDiff.x + (point.y - topLeft.y) * topDiff.y >= -epsilon && (point.x - topRight.x) * topDiff.x + (point.y - topRight.y) * topDiff.y <= epsilon && (point.x - topLeft.x) * leftDiff.x + (point.y - topLeft.y) * leftDiff.y >= -epsilon && (point.x - bottomLeft.x) * leftDiff.x + (point.y - bottomLeft.y) * leftDiff.y <= epsilon;
      },
      /**
       * Provides a string representation of the rectangle which is useful for
       * debugging.
       * @function
       * @returns {String} A string representation of the rectangle.
       */
      toString: function() {
        return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg]";
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    var THIS = {};
    $2.ReferenceStrip = function(options) {
      var _this = this, viewer = options.viewer, viewerSize = $2.getElementSize(viewer.element), element, style2, i;
      if (!options.id) {
        options.id = "referencestrip-" + $2.now();
        this.element = $2.makeNeutralElement("div");
        this.element.id = options.id;
        this.element.className = "referencestrip";
      }
      options = $2.extend(true, {
        sizeRatio: $2.DEFAULT_SETTINGS.referenceStripSizeRatio,
        position: $2.DEFAULT_SETTINGS.referenceStripPosition,
        scroll: $2.DEFAULT_SETTINGS.referenceStripScroll,
        clickTimeThreshold: $2.DEFAULT_SETTINGS.clickTimeThreshold
      }, options, {
        element: this.element
      });
      $2.extend(this, options);
      THIS[this.id] = {
        animating: false
      };
      this.minPixelRatio = this.viewer.minPixelRatio;
      this.element.tabIndex = 0;
      style2 = this.element.style;
      style2.marginTop = "0px";
      style2.marginRight = "0px";
      style2.marginBottom = "0px";
      style2.marginLeft = "0px";
      style2.left = "0px";
      style2.bottom = "0px";
      style2.border = "0px";
      style2.background = "#000";
      style2.position = "relative";
      $2.setElementTouchActionNone(this.element);
      $2.setElementOpacity(this.element, 0.8);
      this.viewer = viewer;
      this.tracker = new $2.MouseTracker({
        userData: "ReferenceStrip.tracker",
        element: this.element,
        clickHandler: $2.delegate(this, onStripClick),
        dragHandler: $2.delegate(this, onStripDrag),
        scrollHandler: $2.delegate(this, onStripScroll),
        enterHandler: $2.delegate(this, onStripEnter),
        leaveHandler: $2.delegate(this, onStripLeave),
        keyDownHandler: $2.delegate(this, onKeyDown),
        keyHandler: $2.delegate(this, onKeyPress),
        preProcessEventHandler: function(eventInfo) {
          if (eventInfo.eventType === "wheel") {
            eventInfo.preventDefault = true;
          }
        }
      });
      if (options.width && options.height) {
        this.element.style.width = options.width + "px";
        this.element.style.height = options.height + "px";
        viewer.addControl(
          this.element,
          { anchor: $2.ControlAnchor.BOTTOM_LEFT }
        );
      } else {
        if ("horizontal" === options.scroll) {
          this.element.style.width = viewerSize.x * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
          this.element.style.height = viewerSize.y * options.sizeRatio + "px";
          viewer.addControl(
            this.element,
            { anchor: $2.ControlAnchor.BOTTOM_LEFT }
          );
        } else {
          this.element.style.height = viewerSize.y * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
          this.element.style.width = viewerSize.x * options.sizeRatio + "px";
          viewer.addControl(
            this.element,
            { anchor: $2.ControlAnchor.TOP_LEFT }
          );
        }
      }
      this.panelWidth = viewerSize.x * this.sizeRatio + 8;
      this.panelHeight = viewerSize.y * this.sizeRatio + 8;
      this.panels = [];
      this.miniViewers = {};
      for (i = 0; i < viewer.tileSources.length; i++) {
        element = $2.makeNeutralElement("div");
        element.id = this.element.id + "-" + i;
        element.style.width = _this.panelWidth + "px";
        element.style.height = _this.panelHeight + "px";
        element.style.display = "inline";
        element.style["float"] = "left";
        element.style.cssFloat = "left";
        element.style.styleFloat = "left";
        element.style.padding = "2px";
        $2.setElementTouchActionNone(element);
        $2.setElementPointerEventsNone(element);
        this.element.appendChild(element);
        element.activePanel = false;
        this.panels.push(element);
      }
      loadPanels(this, this.scroll === "vertical" ? viewerSize.y : viewerSize.x, 0);
      this.setFocus(0);
    };
    $2.ReferenceStrip.prototype = {
      /**
       * @function
       */
      setFocus: function(page) {
        var element = this.element.querySelector("#" + this.element.id + "-" + page), viewerSize = $2.getElementSize(this.viewer.canvas), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), offsetLeft = -Number(this.element.style.marginLeft.replace("px", "")), offsetTop = -Number(this.element.style.marginTop.replace("px", "")), offset;
        if (this.currentSelected !== element) {
          if (this.currentSelected) {
            this.currentSelected.style.background = "#000";
          }
          this.currentSelected = element;
          this.currentSelected.style.background = "#999";
          if ("horizontal" === this.scroll) {
            offset = Number(page) * (this.panelWidth + 3);
            if (offset > offsetLeft + viewerSize.x - this.panelWidth) {
              offset = Math.min(offset, scrollWidth - viewerSize.x);
              this.element.style.marginLeft = -offset + "px";
              loadPanels(this, viewerSize.x, -offset);
            } else if (offset < offsetLeft) {
              offset = Math.max(0, offset - viewerSize.x / 2);
              this.element.style.marginLeft = -offset + "px";
              loadPanels(this, viewerSize.x, -offset);
            }
          } else {
            offset = Number(page) * (this.panelHeight + 3);
            if (offset > offsetTop + viewerSize.y - this.panelHeight) {
              offset = Math.min(offset, scrollHeight - viewerSize.y);
              this.element.style.marginTop = -offset + "px";
              loadPanels(this, viewerSize.y, -offset);
            } else if (offset < offsetTop) {
              offset = Math.max(0, offset - viewerSize.y / 2);
              this.element.style.marginTop = -offset + "px";
              loadPanels(this, viewerSize.y, -offset);
            }
          }
          this.currentPage = page;
          onStripEnter.call(this, { eventSource: this.tracker });
        }
      },
      /**
       * @function
       */
      update: function() {
        if (THIS[this.id].animating) {
          return true;
        }
        return false;
      },
      destroy: function() {
        if (this.miniViewers) {
          for (var key in this.miniViewers) {
            this.miniViewers[key].destroy();
          }
        }
        this.tracker.destroy();
        if (this.element) {
          this.viewer.removeControl(this.element);
        }
      }
    };
    function onStripClick(event) {
      if (event.quick) {
        var page;
        if ("horizontal" === this.scroll) {
          page = Math.floor(event.position.x / (this.panelWidth + 4));
        } else {
          page = Math.floor(event.position.y / this.panelHeight);
        }
        this.viewer.goToPage(page);
      }
      this.element.focus();
    }
    function onStripDrag(event) {
      this.dragging = true;
      if (this.element) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $2.getElementSize(this.viewer.canvas);
        if ("horizontal" === this.scroll) {
          if (-event.delta.x > 0) {
            if (offsetLeft > -(scrollWidth - viewerSize.x)) {
              this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
              loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
            }
          } else if (-event.delta.x < 0) {
            if (offsetLeft < 0) {
              this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
              loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
            }
          }
        } else {
          if (-event.delta.y > 0) {
            if (offsetTop > -(scrollHeight - viewerSize.y)) {
              this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
            }
          } else if (-event.delta.y < 0) {
            if (offsetTop < 0) {
              this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
            }
          }
        }
      }
    }
    function onStripScroll(event) {
      if (this.element) {
        var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $2.getElementSize(this.viewer.canvas);
        if ("horizontal" === this.scroll) {
          if (event.scroll > 0) {
            if (offsetLeft > -(scrollWidth - viewerSize.x)) {
              this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
              loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
            }
          } else if (event.scroll < 0) {
            if (offsetLeft < 0) {
              this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
              loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
            }
          }
        } else {
          if (event.scroll < 0) {
            if (offsetTop > viewerSize.y - scrollHeight) {
              this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
            }
          } else if (event.scroll > 0) {
            if (offsetTop < 0) {
              this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
              loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
            }
          }
        }
        event.preventDefault = true;
      }
    }
    function loadPanels(strip, viewerSize, scroll) {
      var panelSize, activePanelsStart, activePanelsEnd, miniViewer, i, element;
      if ("horizontal" === strip.scroll) {
        panelSize = strip.panelWidth;
      } else {
        panelSize = strip.panelHeight;
      }
      activePanelsStart = Math.ceil(viewerSize / panelSize) + 5;
      activePanelsEnd = Math.ceil((Math.abs(scroll) + viewerSize) / panelSize) + 1;
      activePanelsStart = activePanelsEnd - activePanelsStart;
      activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;
      for (i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++) {
        element = strip.panels[i];
        if (!element.activePanel) {
          var miniTileSource;
          var originalTileSource = strip.viewer.tileSources[i];
          if (originalTileSource.referenceStripThumbnailUrl) {
            miniTileSource = {
              type: "image",
              url: originalTileSource.referenceStripThumbnailUrl
            };
          } else {
            miniTileSource = originalTileSource;
          }
          miniViewer = new $2.Viewer({
            id: element.id,
            tileSources: [miniTileSource],
            element,
            navigatorSizeRatio: strip.sizeRatio,
            showNavigator: false,
            mouseNavEnabled: false,
            showNavigationControl: false,
            showSequenceControl: false,
            immediateRender: true,
            blendTime: 0,
            animationTime: 0,
            loadTilesWithAjax: strip.viewer.loadTilesWithAjax,
            ajaxHeaders: strip.viewer.ajaxHeaders,
            useCanvas: strip.useCanvas
          });
          $2.setElementPointerEventsNone(miniViewer.canvas);
          $2.setElementPointerEventsNone(miniViewer.container);
          miniViewer.innerTracker.setTracking(false);
          miniViewer.outerTracker.setTracking(false);
          strip.miniViewers[element.id] = miniViewer;
          element.activePanel = true;
        }
      }
    }
    function onStripEnter(event) {
      var element = event.eventSource.element;
      if ("horizontal" === this.scroll) {
        element.style.marginBottom = "0px";
      } else {
        element.style.marginLeft = "0px";
      }
    }
    function onStripLeave(event) {
      var element = event.eventSource.element;
      if ("horizontal" === this.scroll) {
        element.style.marginBottom = "-" + $2.getElementSize(element).y / 2 + "px";
      } else {
        element.style.marginLeft = "-" + $2.getElementSize(element).x / 2 + "px";
      }
    }
    function onKeyDown(event) {
      if (!event.ctrl && !event.alt && !event.meta) {
        switch (event.keyCode) {
          case 38:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          case 40:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 37:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 39:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          default:
            event.preventDefault = false;
            break;
        }
      } else {
        event.preventDefault = false;
      }
    }
    function onKeyPress(event) {
      if (!event.ctrl && !event.alt && !event.meta) {
        switch (event.keyCode) {
          case 61:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          case 45:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 48:
          case 119:
          case 87:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          case 115:
          case 83:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 97:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
            event.preventDefault = true;
            break;
          case 100:
            onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
            event.preventDefault = true;
            break;
          default:
            event.preventDefault = false;
            break;
        }
      } else {
        event.preventDefault = false;
      }
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.DisplayRect = function(x2, y, width, height, minLevel, maxLevel) {
      $2.Rect.apply(this, [x2, y, width, height]);
      this.minLevel = minLevel;
      this.maxLevel = maxLevel;
    };
    $2.extend($2.DisplayRect.prototype, $2.Rect.prototype);
  })(OpenSeadragon2);
  (function($2) {
    $2.Spring = function(options) {
      var args = arguments;
      if (typeof options !== "object") {
        options = {
          initial: args.length && typeof args[0] === "number" ? args[0] : void 0,
          /**
           * Spring stiffness.
           * @member {Number} springStiffness
           * @memberof OpenSeadragon.Spring#
           */
          springStiffness: args.length > 1 ? args[1].springStiffness : 5,
          /**
           * Animation duration per spring.
           * @member {Number} animationTime
           * @memberof OpenSeadragon.Spring#
           */
          animationTime: args.length > 1 ? args[1].animationTime : 1.5
        };
      }
      $2.console.assert(
        typeof options.springStiffness === "number" && options.springStiffness !== 0,
        "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"
      );
      $2.console.assert(
        typeof options.animationTime === "number" && options.animationTime >= 0,
        "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"
      );
      if (options.exponential) {
        this._exponential = true;
        delete options.exponential;
      }
      $2.extend(true, this, options);
      this.current = {
        value: typeof this.initial === "number" ? this.initial : this._exponential ? 0 : 1,
        time: $2.now()
        // always work in milliseconds
      };
      $2.console.assert(
        !this._exponential || this.current.value !== 0,
        "[OpenSeadragon.Spring] value must be non-zero for exponential springs"
      );
      this.start = {
        value: this.current.value,
        time: this.current.time
      };
      this.target = {
        value: this.current.value,
        time: this.current.time
      };
      if (this._exponential) {
        this.start._logValue = Math.log(this.start.value);
        this.target._logValue = Math.log(this.target.value);
        this.current._logValue = Math.log(this.current.value);
      }
    };
    $2.Spring.prototype = {
      /**
       * @function
       * @param {Number} target
       */
      resetTo: function(target) {
        $2.console.assert(
          !this._exponential || target !== 0,
          "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"
        );
        this.start.value = this.target.value = this.current.value = target;
        this.start.time = this.target.time = this.current.time = $2.now();
        if (this._exponential) {
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
          this.current._logValue = Math.log(this.current.value);
        }
      },
      /**
       * @function
       * @param {Number} target
       */
      springTo: function(target) {
        $2.console.assert(
          !this._exponential || target !== 0,
          "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"
        );
        this.start.value = this.current.value;
        this.start.time = this.current.time;
        this.target.value = target;
        this.target.time = this.start.time + 1e3 * this.animationTime;
        if (this._exponential) {
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
        }
      },
      /**
       * @function
       * @param {Number} delta
       */
      shiftBy: function(delta) {
        this.start.value += delta;
        this.target.value += delta;
        if (this._exponential) {
          $2.console.assert(
            this.target.value !== 0 && this.start.value !== 0,
            "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"
          );
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
        }
      },
      setExponential: function(value) {
        this._exponential = value;
        if (this._exponential) {
          $2.console.assert(
            this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
            "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"
          );
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
          this.current._logValue = Math.log(this.current.value);
        }
      },
      /**
       * @function
       * @returns true if the value got updated, false otherwise
       */
      update: function() {
        this.current.time = $2.now();
        var startValue, targetValue;
        if (this._exponential) {
          startValue = this.start._logValue;
          targetValue = this.target._logValue;
        } else {
          startValue = this.start.value;
          targetValue = this.target.value;
        }
        var currentValue = this.current.time >= this.target.time ? targetValue : startValue + (targetValue - startValue) * transform(
          this.springStiffness,
          (this.current.time - this.start.time) / (this.target.time - this.start.time)
        );
        var oldValue = this.current.value;
        if (this._exponential) {
          this.current.value = Math.exp(currentValue);
        } else {
          this.current.value = currentValue;
        }
        return oldValue !== this.current.value;
      },
      /**
       * Returns whether the spring is at the target value
       * @function
       * @returns {Boolean} True if at target value, false otherwise
       */
      isAtTargetValue: function() {
        return this.current.value === this.target.value;
      }
    };
    function transform(stiffness, x2) {
      return (1 - Math.exp(stiffness * -x2)) / (1 - Math.exp(-stiffness));
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.ImageJob = function(options) {
      $2.extend(true, this, {
        timeout: $2.DEFAULT_SETTINGS.timeout,
        jobId: null,
        tries: 0
      }, options);
      this.data = null;
      this.userData = {};
      this.errorMsg = null;
    };
    $2.ImageJob.prototype = {
      /**
       * Starts the image job.
       * @method
       */
      start: function() {
        this.tries++;
        var self2 = this;
        var selfAbort = this.abort;
        this.jobId = window.setTimeout(function() {
          self2.finish(null, null, "Image load exceeded timeout (" + self2.timeout + " ms)");
        }, this.timeout);
        this.abort = function() {
          self2.source.downloadTileAbort(self2);
          if (typeof selfAbort === "function") {
            selfAbort();
          }
        };
        this.source.downloadTileStart(this);
      },
      /**
       * Finish this job.
       * @param {*} data data that has been downloaded
       * @param {XMLHttpRequest} request reference to the request if used
       * @param {string} errorMessage description upon failure
       */
      finish: function(data, request, errorMessage) {
        this.data = data;
        this.request = request;
        this.errorMsg = errorMessage;
        if (this.jobId) {
          window.clearTimeout(this.jobId);
        }
        this.callback(this);
      }
    };
    $2.ImageLoader = function(options) {
      $2.extend(true, this, {
        jobLimit: $2.DEFAULT_SETTINGS.imageLoaderLimit,
        timeout: $2.DEFAULT_SETTINGS.timeout,
        jobQueue: [],
        failedTiles: [],
        jobsInProgress: 0
      }, options);
    };
    $2.ImageLoader.prototype = {
      /**
       * Add an unloaded image to the loader queue.
       * @method
       * @param {Object} options - Options for this job.
       * @param {String} [options.src] - URL of image to download.
       * @param {Tile} [options.tile] - Tile that belongs the data to. The tile instance
       *      is not internally used and serves for custom TileSources implementations.
       * @param {TileSource} [options.source] - Image loading strategy
       * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
       * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
       * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
       * @param {String} [options.postData] - POST parameters (usually but not necessarily in k=v&k2=v2... form,
       *      see TileSource::getPostData) or null
       * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
       *      requests.
       * @param {Function} [options.callback] - Called once image has been downloaded.
       * @param {Function} [options.abort] - Called when this image job is aborted.
       */
      addJob: function(options) {
        if (!options.source) {
          $2.console.error("ImageLoader.prototype.addJob() requires [options.source]. TileSource since new API defines how images are fetched. Creating a dummy TileSource.");
          var implementation = $2.TileSource.prototype;
          options.source = {
            downloadTileStart: implementation.downloadTileStart,
            downloadTileAbort: implementation.downloadTileAbort
          };
        }
        var _this = this, complete = function(job) {
          completeJob(_this, job, options.callback);
        }, jobOptions = {
          src: options.src,
          tile: options.tile || {},
          source: options.source,
          loadWithAjax: options.loadWithAjax,
          ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
          crossOriginPolicy: options.crossOriginPolicy,
          ajaxWithCredentials: options.ajaxWithCredentials,
          postData: options.postData,
          callback: complete,
          abort: options.abort,
          timeout: this.timeout
        }, newJob = new $2.ImageJob(jobOptions);
        if (!this.jobLimit || this.jobsInProgress < this.jobLimit) {
          newJob.start();
          this.jobsInProgress++;
        } else {
          this.jobQueue.push(newJob);
        }
      },
      /**
       * Clear any unstarted image loading jobs from the queue.
       * @method
       */
      clear: function() {
        for (var i = 0; i < this.jobQueue.length; i++) {
          var job = this.jobQueue[i];
          if (typeof job.abort === "function") {
            job.abort();
          }
        }
        this.jobQueue = [];
      }
    };
    function completeJob(loader, job, callback) {
      if (job.errorMsg !== "" && (job.data === null || job.data === void 0) && job.tries < 1 + loader.tileRetryMax) {
        loader.failedTiles.push(job);
      }
      var nextJob;
      loader.jobsInProgress--;
      if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
        nextJob = loader.jobQueue.shift();
        nextJob.start();
        loader.jobsInProgress++;
      }
      if (loader.tileRetryMax > 0 && loader.jobQueue.length === 0) {
        if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.failedTiles.length > 0) {
          nextJob = loader.failedTiles.shift();
          setTimeout(function() {
            nextJob.start();
          }, loader.tileRetryDelay);
          loader.jobsInProgress++;
        }
      }
      callback(job.data, job.errorMsg, job.request);
    }
  })(OpenSeadragon2);
  (function($2) {
    $2.Tile = function(level, x2, y, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds, postData, cacheKey) {
      this.level = level;
      this.x = x2;
      this.y = y;
      this.bounds = bounds;
      this.sourceBounds = sourceBounds;
      this.exists = exists;
      this._url = url;
      this.postData = postData;
      this.context2D = context2D;
      this.loadWithAjax = loadWithAjax;
      this.ajaxHeaders = ajaxHeaders;
      if (cacheKey === void 0) {
        $2.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used.");
        cacheKey = $2.TileSource.prototype.getTileHashKey(level, x2, y, url, ajaxHeaders, postData);
      }
      this.cacheKey = cacheKey;
      this.loaded = false;
      this.loading = false;
      this.element = null;
      this.imgElement = null;
      this.style = null;
      this.position = null;
      this.size = null;
      this.flipped = false;
      this.blendStart = null;
      this.opacity = null;
      this.squaredDistance = null;
      this.visibility = null;
      this.hasTransparency = false;
      this.beingDrawn = false;
      this.lastTouchTime = 0;
      this.isRightMost = false;
      this.isBottomMost = false;
    };
    $2.Tile.prototype = {
      /**
       * Provides a string representation of this tiles level and (x,y)
       * components.
       * @function
       * @returns {String}
       */
      toString: function() {
        return this.level + "/" + this.x + "_" + this.y;
      },
      // private
      _hasTransparencyChannel: function() {
        console.warn("Tile.prototype._hasTransparencyChannel() has been deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead.");
        return !!this.context2D || this.getUrl().match(".png");
      },
      /**
       * Renders the tile in an html container.
       * @function
       * @param {Element} container
       */
      drawHTML: function(container) {
        if (!this.cacheImageRecord) {
          $2.console.warn(
            "[Tile.drawHTML] attempting to draw tile %s when it's not cached",
            this.toString()
          );
          return;
        }
        if (!this.loaded) {
          $2.console.warn(
            "Attempting to draw tile %s when it's not yet loaded.",
            this.toString()
          );
          return;
        }
        if (!this.element) {
          var image = this.getImage();
          if (!image) {
            return;
          }
          this.element = $2.makeNeutralElement("div");
          this.imgElement = image.cloneNode();
          this.imgElement.style.msInterpolationMode = "nearest-neighbor";
          this.imgElement.style.width = "100%";
          this.imgElement.style.height = "100%";
          this.style = this.element.style;
          this.style.position = "absolute";
        }
        if (this.element.parentNode !== container) {
          container.appendChild(this.element);
        }
        if (this.imgElement.parentNode !== this.element) {
          this.element.appendChild(this.imgElement);
        }
        this.style.top = this.position.y + "px";
        this.style.left = this.position.x + "px";
        this.style.height = this.size.y + "px";
        this.style.width = this.size.x + "px";
        if (this.flipped) {
          this.style.transform = "scaleX(-1)";
        }
        $2.setElementOpacity(this.element, this.opacity);
      },
      /**
       * The Image object for this tile.
       * @member {Object} image
       * @memberof OpenSeadragon.Tile#
       * @deprecated
       * @returns {Image}
       */
      get image() {
        $2.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead.");
        return this.getImage();
      },
      /**
       * The URL of this tile's image.
       * @member {String} url
       * @memberof OpenSeadragon.Tile#
       * @deprecated
       * @returns {String}
       */
      get url() {
        $2.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead.");
        return this.getUrl();
      },
      /**
       * Get the Image object for this tile.
       * @returns {Image}
       */
      getImage: function() {
        return this.cacheImageRecord.getImage();
      },
      /**
       * Get the url string for this tile.
       * @returns {String}
       */
      getUrl: function() {
        if (typeof this._url === "function") {
          return this._url();
        }
        return this._url;
      },
      /**
       * Get the CanvasRenderingContext2D instance for tile image data drawn
       * onto Canvas if enabled and available
       * @returns {CanvasRenderingContext2D}
       */
      getCanvasContext: function() {
        return this.context2D || this.cacheImageRecord.getRenderedContext();
      },
      /**
       * Renders the tile in a canvas-based context.
       * @function
       * @param {Canvas} context
       * @param {Function} drawingHandler - Method for firing the drawing event.
       * drawingHandler({context, tile, rendered})
       * where <code>rendered</code> is the context with the pre-drawn image.
       * @param {Number} [scale=1] - Apply a scale to position and size
       * @param {OpenSeadragon.Point} [translate] - A translation vector
       * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
       * position and size of tiles supporting alpha channel in non-transparency
       * context.
       * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
       */
      drawCanvas: function(context, drawingHandler, scale, translate, shouldRoundPositionAndSize, source) {
        var position = this.position.times($2.pixelDensityRatio), size = this.size.times($2.pixelDensityRatio), rendered;
        if (!this.context2D && !this.cacheImageRecord) {
          $2.console.warn(
            "[Tile.drawCanvas] attempting to draw tile %s when it's not cached",
            this.toString()
          );
          return;
        }
        rendered = this.getCanvasContext();
        if (!this.loaded || !rendered) {
          $2.console.warn(
            "Attempting to draw tile %s when it's not yet loaded.",
            this.toString()
          );
          return;
        }
        context.save();
        context.globalAlpha = this.opacity;
        if (typeof scale === "number" && scale !== 1) {
          position = position.times(scale);
          size = size.times(scale);
        }
        if (translate instanceof $2.Point) {
          position = position.plus(translate);
        }
        if (context.globalAlpha === 1 && this.hasTransparency) {
          if (shouldRoundPositionAndSize) {
            position.x = Math.round(position.x);
            position.y = Math.round(position.y);
            size.x = Math.round(size.x);
            size.y = Math.round(size.y);
          }
          context.clearRect(
            position.x,
            position.y,
            size.x,
            size.y
          );
        }
        drawingHandler({ context, tile: this, rendered });
        var sourceWidth, sourceHeight;
        if (this.sourceBounds) {
          sourceWidth = Math.min(this.sourceBounds.width, rendered.canvas.width);
          sourceHeight = Math.min(this.sourceBounds.height, rendered.canvas.height);
        } else {
          sourceWidth = rendered.canvas.width;
          sourceHeight = rendered.canvas.height;
        }
        context.translate(position.x + size.x / 2, 0);
        if (this.flipped) {
          context.scale(-1, 1);
        }
        context.drawImage(
          rendered.canvas,
          0,
          0,
          sourceWidth,
          sourceHeight,
          -size.x / 2,
          position.y,
          size.x,
          size.y
        );
        context.restore();
      },
      /**
       * Get the ratio between current and original size.
       * @function
       * @returns {Float}
       */
      getScaleForEdgeSmoothing: function() {
        var context;
        if (this.cacheImageRecord) {
          context = this.cacheImageRecord.getRenderedContext();
        } else if (this.context2D) {
          context = this.context2D;
        } else {
          $2.console.warn(
            "[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached",
            this.toString()
          );
          return 1;
        }
        return context.canvas.width / (this.size.x * $2.pixelDensityRatio);
      },
      /**
       * Get a translation vector that when applied to the tile position produces integer coordinates.
       * Needed to avoid swimming and twitching.
       * @function
       * @param {Number} [scale=1] - Scale to be applied to position.
       * @returns {OpenSeadragon.Point}
       */
      getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
        var x2 = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
        var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
        return new $2.Point(x2, y).minus(
          this.position.times($2.pixelDensityRatio).times(scale || 1).apply(function(x3) {
            return x3 % 1;
          })
        );
      },
      /**
       * Removes tile from its container.
       * @function
       */
      unload: function() {
        if (this.imgElement && this.imgElement.parentNode) {
          this.imgElement.parentNode.removeChild(this.imgElement);
        }
        if (this.element && this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
        this.element = null;
        this.imgElement = null;
        this.loaded = false;
        this.loading = false;
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.OverlayPlacement = $2.Placement;
    $2.OverlayRotationMode = $2.freezeObject({
      NO_ROTATION: 1,
      EXACT: 2,
      BOUNDING_BOX: 3
    });
    $2.Overlay = function(element, location, placement) {
      var options;
      if ($2.isPlainObject(element)) {
        options = element;
      } else {
        options = {
          element,
          location,
          placement
        };
      }
      this.element = options.element;
      this.style = options.element.style;
      this._init(options);
    };
    $2.Overlay.prototype = {
      // private
      _init: function(options) {
        this.location = options.location;
        this.placement = options.placement === void 0 ? $2.Placement.TOP_LEFT : options.placement;
        this.onDraw = options.onDraw;
        this.checkResize = options.checkResize === void 0 ? true : options.checkResize;
        this.width = options.width === void 0 ? null : options.width;
        this.height = options.height === void 0 ? null : options.height;
        this.rotationMode = options.rotationMode || $2.OverlayRotationMode.EXACT;
        if (this.location instanceof $2.Rect) {
          this.width = this.location.width;
          this.height = this.location.height;
          this.location = this.location.getTopLeft();
          this.placement = $2.Placement.TOP_LEFT;
        }
        this.scales = this.width !== null && this.height !== null;
        this.bounds = new $2.Rect(
          this.location.x,
          this.location.y,
          this.width,
          this.height
        );
        this.position = this.location;
      },
      /**
       * Internal function to adjust the position of an overlay
       * depending on it size and placement.
       * @function
       * @param {OpenSeadragon.Point} position
       * @param {OpenSeadragon.Point} size
       */
      adjust: function(position, size) {
        var properties = $2.Placement.properties[this.placement];
        if (!properties) {
          return;
        }
        if (properties.isHorizontallyCentered) {
          position.x -= size.x / 2;
        } else if (properties.isRight) {
          position.x -= size.x;
        }
        if (properties.isVerticallyCentered) {
          position.y -= size.y / 2;
        } else if (properties.isBottom) {
          position.y -= size.y;
        }
      },
      /**
       * @function
       */
      destroy: function() {
        var element = this.element;
        var style2 = this.style;
        if (element.parentNode) {
          element.parentNode.removeChild(element);
          if (element.prevElementParent) {
            style2.display = "none";
            document.body.appendChild(element);
          }
        }
        this.onDraw = null;
        style2.top = "";
        style2.left = "";
        style2.position = "";
        if (this.width !== null) {
          style2.width = "";
        }
        if (this.height !== null) {
          style2.height = "";
        }
        var transformOriginProp = $2.getCssPropertyWithVendorPrefix(
          "transformOrigin"
        );
        var transformProp = $2.getCssPropertyWithVendorPrefix(
          "transform"
        );
        if (transformOriginProp && transformProp) {
          style2[transformOriginProp] = "";
          style2[transformProp] = "";
        }
      },
      /**
       * @function
       * @param {Element} container
       */
      drawHTML: function(container, viewport) {
        var element = this.element;
        if (element.parentNode !== container) {
          element.prevElementParent = element.parentNode;
          element.prevNextSibling = element.nextSibling;
          container.appendChild(element);
          this.style.position = "absolute";
          this.size = $2.getElementSize(element);
        }
        var positionAndSize = this._getOverlayPositionAndSize(viewport);
        var position = positionAndSize.position;
        var size = this.size = positionAndSize.size;
        var rotate = positionAndSize.rotate;
        if (this.onDraw) {
          this.onDraw(position, size, this.element);
        } else {
          var style2 = this.style;
          style2.left = position.x + "px";
          style2.top = position.y + "px";
          if (this.width !== null) {
            style2.width = size.x + "px";
          }
          if (this.height !== null) {
            style2.height = size.y + "px";
          }
          var transformOriginProp = $2.getCssPropertyWithVendorPrefix(
            "transformOrigin"
          );
          var transformProp = $2.getCssPropertyWithVendorPrefix(
            "transform"
          );
          if (transformOriginProp && transformProp) {
            if (rotate) {
              style2[transformOriginProp] = this._getTransformOrigin();
              style2[transformProp] = "rotate(" + rotate + "deg)";
            } else {
              style2[transformOriginProp] = "";
              style2[transformProp] = "";
            }
          }
          style2.display = "block";
        }
      },
      // private
      _getOverlayPositionAndSize: function(viewport) {
        var position = viewport.pixelFromPoint(this.location, true);
        var size = this._getSizeInPixels(viewport);
        this.adjust(position, size);
        var rotate = 0;
        if (viewport.getRotation(true) && this.rotationMode !== $2.OverlayRotationMode.NO_ROTATION) {
          if (this.rotationMode === $2.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
            var rect = new $2.Rect(position.x, position.y, size.x, size.y);
            var boundingBox = this._getBoundingBox(rect, viewport.getRotation(true));
            position = boundingBox.getTopLeft();
            size = boundingBox.getSize();
          } else {
            rotate = viewport.getRotation(true);
          }
        }
        return {
          position,
          size,
          rotate
        };
      },
      // private
      _getSizeInPixels: function(viewport) {
        var width = this.size.x;
        var height = this.size.y;
        if (this.width !== null || this.height !== null) {
          var scaledSize = viewport.deltaPixelsFromPointsNoRotate(
            new $2.Point(this.width || 0, this.height || 0),
            true
          );
          if (this.width !== null) {
            width = scaledSize.x;
          }
          if (this.height !== null) {
            height = scaledSize.y;
          }
        }
        if (this.checkResize && (this.width === null || this.height === null)) {
          var eltSize = this.size = $2.getElementSize(this.element);
          if (this.width === null) {
            width = eltSize.x;
          }
          if (this.height === null) {
            height = eltSize.y;
          }
        }
        return new $2.Point(width, height);
      },
      // private
      _getBoundingBox: function(rect, degrees) {
        var refPoint = this._getPlacementPoint(rect);
        return rect.rotate(degrees, refPoint).getBoundingBox();
      },
      // private
      _getPlacementPoint: function(rect) {
        var result = new $2.Point(rect.x, rect.y);
        var properties = $2.Placement.properties[this.placement];
        if (properties) {
          if (properties.isHorizontallyCentered) {
            result.x += rect.width / 2;
          } else if (properties.isRight) {
            result.x += rect.width;
          }
          if (properties.isVerticallyCentered) {
            result.y += rect.height / 2;
          } else if (properties.isBottom) {
            result.y += rect.height;
          }
        }
        return result;
      },
      // private
      _getTransformOrigin: function() {
        var result = "";
        var properties = $2.Placement.properties[this.placement];
        if (!properties) {
          return result;
        }
        if (properties.isLeft) {
          result = "left";
        } else if (properties.isRight) {
          result = "right";
        }
        if (properties.isTop) {
          result += " top";
        } else if (properties.isBottom) {
          result += " bottom";
        }
        return result;
      },
      /**
       * Changes the overlay settings.
       * @function
       * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
       * If an object is specified, the options are the same than the constructor
       * except for the element which can not be changed.
       * @param {OpenSeadragon.Placement} placement
       */
      update: function(location, placement) {
        var options = $2.isPlainObject(location) ? location : {
          location,
          placement
        };
        this._init({
          location: options.location || this.location,
          placement: options.placement !== void 0 ? options.placement : this.placement,
          onDraw: options.onDraw || this.onDraw,
          checkResize: options.checkResize || this.checkResize,
          width: options.width !== void 0 ? options.width : this.width,
          height: options.height !== void 0 ? options.height : this.height,
          rotationMode: options.rotationMode || this.rotationMode
        });
      },
      /**
       * Returns the current bounds of the overlay in viewport coordinates
       * @function
       * @param {OpenSeadragon.Viewport} viewport the viewport
       * @returns {OpenSeadragon.Rect} overlay bounds
       */
      getBounds: function(viewport) {
        $2.console.assert(
          viewport,
          "A viewport must now be passed to Overlay.getBounds."
        );
        var width = this.width;
        var height = this.height;
        if (width === null || height === null) {
          var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
          if (width === null) {
            width = size.x;
          }
          if (height === null) {
            height = size.y;
          }
        }
        var location = this.location.clone();
        this.adjust(location, new $2.Point(width, height));
        return this._adjustBoundsForRotation(
          viewport,
          new $2.Rect(location.x, location.y, width, height)
        );
      },
      // private
      _adjustBoundsForRotation: function(viewport, bounds) {
        if (!viewport || viewport.getRotation(true) === 0 || this.rotationMode === $2.OverlayRotationMode.EXACT) {
          return bounds;
        }
        if (this.rotationMode === $2.OverlayRotationMode.BOUNDING_BOX) {
          if (this.width === null || this.height === null) {
            return bounds;
          }
          var positionAndSize = this._getOverlayPositionAndSize(viewport);
          return viewport.viewerElementToViewportRectangle(new $2.Rect(
            positionAndSize.position.x,
            positionAndSize.position.y,
            positionAndSize.size.x,
            positionAndSize.size.y
          ));
        }
        return bounds.rotate(
          -viewport.getRotation(true),
          this._getPlacementPoint(bounds)
        );
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.Drawer = function(options) {
      $2.console.assert(options.viewer, "[Drawer] options.viewer is required");
      var args = arguments;
      if (!$2.isPlainObject(options)) {
        options = {
          source: args[0],
          // Reference to Viewer tile source.
          viewport: args[1],
          // Reference to Viewer viewport.
          element: args[2]
          // Parent element.
        };
      }
      $2.console.assert(options.viewport, "[Drawer] options.viewport is required");
      $2.console.assert(options.element, "[Drawer] options.element is required");
      if (options.source) {
        $2.console.error("[Drawer] options.source is no longer accepted; use TiledImage instead");
      }
      this.viewer = options.viewer;
      this.viewport = options.viewport;
      this.debugGridColor = typeof options.debugGridColor === "string" ? [options.debugGridColor] : options.debugGridColor || $2.DEFAULT_SETTINGS.debugGridColor;
      if (options.opacity) {
        $2.console.error("[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead");
      }
      this.useCanvas = $2.supportsCanvas && (this.viewer ? this.viewer.useCanvas : true);
      this.container = $2.getElement(options.element);
      this.canvas = $2.makeNeutralElement(this.useCanvas ? "canvas" : "div");
      this.context = this.useCanvas ? this.canvas.getContext("2d") : null;
      this.sketchCanvas = null;
      this.sketchContext = null;
      this.element = this.container;
      this.container.dir = "ltr";
      if (this.useCanvas) {
        var viewportSize = this._calculateCanvasSize();
        this.canvas.width = viewportSize.x;
        this.canvas.height = viewportSize.y;
      }
      this.canvas.style.width = "100%";
      this.canvas.style.height = "100%";
      this.canvas.style.position = "absolute";
      $2.setElementOpacity(this.canvas, this.opacity, true);
      $2.setElementPointerEventsNone(this.canvas);
      $2.setElementTouchActionNone(this.canvas);
      this.container.style.textAlign = "left";
      this.container.appendChild(this.canvas);
      this._imageSmoothingEnabled = true;
    };
    $2.Drawer.prototype = {
      // deprecated
      addOverlay: function(element, location, placement, onDraw) {
        $2.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");
        this.viewer.addOverlay(element, location, placement, onDraw);
        return this;
      },
      // deprecated
      updateOverlay: function(element, location, placement) {
        $2.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");
        this.viewer.updateOverlay(element, location, placement);
        return this;
      },
      // deprecated
      removeOverlay: function(element) {
        $2.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");
        this.viewer.removeOverlay(element);
        return this;
      },
      // deprecated
      clearOverlays: function() {
        $2.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");
        this.viewer.clearOverlays();
        return this;
      },
      /**
       * This function converts the given point from to the drawer coordinate by
       * multiplying it with the pixel density.
       * This function does not take rotation into account, thus assuming provided
       * point is at 0 degree.
       * @param {OpenSeadragon.Point} point - the pixel point to convert
       * @returns {OpenSeadragon.Point} Point in drawer coordinate system.
       */
      viewportCoordToDrawerCoord: function(point) {
        var vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
        return new $2.Point(
          vpPoint.x * $2.pixelDensityRatio,
          vpPoint.y * $2.pixelDensityRatio
        );
      },
      /**
       * This function will create multiple polygon paths on the drawing context by provided polygons,
       * then clip the context to the paths.
       * @param {OpenSeadragon.Point[][]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
       * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
       */
      clipWithPolygons: function(polygons, useSketch) {
        if (!this.useCanvas) {
          return;
        }
        var context = this._getContext(useSketch);
        context.beginPath();
        polygons.forEach(function(polygon) {
          polygon.forEach(function(coord, i) {
            context[i === 0 ? "moveTo" : "lineTo"](coord.x, coord.y);
          });
        });
        context.clip();
      },
      /**
       * Set the opacity of the drawer.
       * @param {Number} opacity
       * @returns {OpenSeadragon.Drawer} Chainable.
       */
      setOpacity: function(opacity) {
        $2.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
        var world = this.viewer.world;
        for (var i = 0; i < world.getItemCount(); i++) {
          world.getItemAt(i).setOpacity(opacity);
        }
        return this;
      },
      /**
       * Get the opacity of the drawer.
       * @returns {Number}
       */
      getOpacity: function() {
        $2.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
        var world = this.viewer.world;
        var maxOpacity = 0;
        for (var i = 0; i < world.getItemCount(); i++) {
          var opacity = world.getItemAt(i).getOpacity();
          if (opacity > maxOpacity) {
            maxOpacity = opacity;
          }
        }
        return maxOpacity;
      },
      // deprecated
      needsUpdate: function() {
        $2.console.error("[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead.");
        return this.viewer.world.needsDraw();
      },
      // deprecated
      numTilesLoaded: function() {
        $2.console.error("[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead.");
        return this.viewer.tileCache.numTilesLoaded();
      },
      // deprecated
      reset: function() {
        $2.console.error("[Drawer.reset] this function is deprecated. Use World.resetItems instead.");
        this.viewer.world.resetItems();
        return this;
      },
      // deprecated
      update: function() {
        $2.console.error("[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead.");
        this.clear();
        this.viewer.world.draw();
        return this;
      },
      /**
       * @returns {Boolean} True if rotation is supported.
       */
      canRotate: function() {
        return this.useCanvas;
      },
      /**
       * Destroy the drawer (unload current loaded tiles)
       */
      destroy: function() {
        this.canvas.width = 1;
        this.canvas.height = 1;
        this.sketchCanvas = null;
        this.sketchContext = null;
      },
      /**
       * Clears the Drawer so it's ready to draw another frame.
       */
      clear: function() {
        this.canvas.innerHTML = "";
        if (this.useCanvas) {
          var viewportSize = this._calculateCanvasSize();
          if (this.canvas.width !== viewportSize.x || this.canvas.height !== viewportSize.y) {
            this.canvas.width = viewportSize.x;
            this.canvas.height = viewportSize.y;
            this._updateImageSmoothingEnabled(this.context);
            if (this.sketchCanvas !== null) {
              var sketchCanvasSize = this._calculateSketchCanvasSize();
              this.sketchCanvas.width = sketchCanvasSize.x;
              this.sketchCanvas.height = sketchCanvasSize.y;
              this._updateImageSmoothingEnabled(this.sketchContext);
            }
          }
          this._clear();
        }
      },
      _clear: function(useSketch, bounds) {
        if (!this.useCanvas) {
          return;
        }
        var context = this._getContext(useSketch);
        if (bounds) {
          context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
        } else {
          var canvas = context.canvas;
          context.clearRect(0, 0, canvas.width, canvas.height);
        }
      },
      /**
       * Scale from OpenSeadragon viewer rectangle to drawer rectangle
       * (ignoring rotation)
       * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
       * @returns {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
       */
      viewportToDrawerRectangle: function(rectangle) {
        var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
        var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);
        return new $2.Rect(
          topLeft.x * $2.pixelDensityRatio,
          topLeft.y * $2.pixelDensityRatio,
          size.x * $2.pixelDensityRatio,
          size.y * $2.pixelDensityRatio
        );
      },
      /**
       * Draws the given tile.
       * @param {OpenSeadragon.Tile} tile - The tile to draw.
       * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
       * drawingHandler({context, tile, rendered})
       * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
       * where <code>rendered</code> is the context with the pre-drawn image.
       * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
       * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
       * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
       * position and size of tiles supporting alpha channel in non-transparency
       * context.
       * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
       */
      drawTile: function(tile, drawingHandler, useSketch, scale, translate, shouldRoundPositionAndSize, source) {
        $2.console.assert(tile, "[Drawer.drawTile] tile is required");
        $2.console.assert(drawingHandler, "[Drawer.drawTile] drawingHandler is required");
        if (this.useCanvas) {
          var context = this._getContext(useSketch);
          scale = scale || 1;
          tile.drawCanvas(context, drawingHandler, scale, translate, shouldRoundPositionAndSize, source);
        } else {
          tile.drawHTML(this.canvas);
        }
      },
      _getContext: function(useSketch) {
        var context = this.context;
        if (useSketch) {
          if (this.sketchCanvas === null) {
            this.sketchCanvas = document.createElement("canvas");
            var sketchCanvasSize = this._calculateSketchCanvasSize();
            this.sketchCanvas.width = sketchCanvasSize.x;
            this.sketchCanvas.height = sketchCanvasSize.y;
            this.sketchContext = this.sketchCanvas.getContext("2d");
            if (this.viewport.getRotation() === 0) {
              var self2 = this;
              this.viewer.addHandler("rotate", function resizeSketchCanvas() {
                if (self2.viewport.getRotation() === 0) {
                  return;
                }
                self2.viewer.removeHandler("rotate", resizeSketchCanvas);
                var sketchCanvasSize2 = self2._calculateSketchCanvasSize();
                self2.sketchCanvas.width = sketchCanvasSize2.x;
                self2.sketchCanvas.height = sketchCanvasSize2.y;
              });
            }
            this._updateImageSmoothingEnabled(this.sketchContext);
          }
          context = this.sketchContext;
        }
        return context;
      },
      // private
      saveContext: function(useSketch) {
        if (!this.useCanvas) {
          return;
        }
        this._getContext(useSketch).save();
      },
      // private
      restoreContext: function(useSketch) {
        if (!this.useCanvas) {
          return;
        }
        this._getContext(useSketch).restore();
      },
      // private
      setClip: function(rect, useSketch) {
        if (!this.useCanvas) {
          return;
        }
        var context = this._getContext(useSketch);
        context.beginPath();
        context.rect(rect.x, rect.y, rect.width, rect.height);
        context.clip();
      },
      // private
      drawRectangle: function(rect, fillStyle, useSketch) {
        if (!this.useCanvas) {
          return;
        }
        var context = this._getContext(useSketch);
        context.save();
        context.fillStyle = fillStyle;
        context.fillRect(rect.x, rect.y, rect.width, rect.height);
        context.restore();
      },
      /**
       * Blends the sketch canvas in the main canvas.
       * @param {Object} options The options
       * @param {Float} options.opacity The opacity of the blending.
       * @param {Float} [options.scale=1] The scale at which tiles were drawn on
       * the sketch. Default is 1.
       * Use scale to draw at a lower scale and then enlarge onto the main canvas.
       * @param {OpenSeadragon.Point} [options.translate] A translation vector
       * that was used to draw the tiles
       * @param {String} [options.compositeOperation] - How the image is
       * composited onto other images; see compositeOperation in
       * {@link OpenSeadragon.Options} for possible values.
       * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
       * canvas to blend in the main canvas. If specified, options.scale and
       * options.translate get ignored.
       */
      blendSketch: function(opacity, scale, translate, compositeOperation) {
        var options = opacity;
        if (!$2.isPlainObject(options)) {
          options = {
            opacity,
            scale,
            translate,
            compositeOperation
          };
        }
        if (!this.useCanvas || !this.sketchCanvas) {
          return;
        }
        opacity = options.opacity;
        compositeOperation = options.compositeOperation;
        var bounds = options.bounds;
        this.context.save();
        this.context.globalAlpha = opacity;
        if (compositeOperation) {
          this.context.globalCompositeOperation = compositeOperation;
        }
        if (bounds) {
          if (bounds.x < 0) {
            bounds.width += bounds.x;
            bounds.x = 0;
          }
          if (bounds.x + bounds.width > this.canvas.width) {
            bounds.width = this.canvas.width - bounds.x;
          }
          if (bounds.y < 0) {
            bounds.height += bounds.y;
            bounds.y = 0;
          }
          if (bounds.y + bounds.height > this.canvas.height) {
            bounds.height = this.canvas.height - bounds.y;
          }
          this.context.drawImage(
            this.sketchCanvas,
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height,
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height
          );
        } else {
          scale = options.scale || 1;
          translate = options.translate;
          var position = translate instanceof $2.Point ? translate : new $2.Point(0, 0);
          var widthExt = 0;
          var heightExt = 0;
          if (translate) {
            var widthDiff = this.sketchCanvas.width - this.canvas.width;
            var heightDiff = this.sketchCanvas.height - this.canvas.height;
            widthExt = Math.round(widthDiff / 2);
            heightExt = Math.round(heightDiff / 2);
          }
          this.context.drawImage(
            this.sketchCanvas,
            position.x - widthExt * scale,
            position.y - heightExt * scale,
            (this.canvas.width + 2 * widthExt) * scale,
            (this.canvas.height + 2 * heightExt) * scale,
            -widthExt,
            -heightExt,
            this.canvas.width + 2 * widthExt,
            this.canvas.height + 2 * heightExt
          );
        }
        this.context.restore();
      },
      // private
      drawDebugInfo: function(tile, count, i, tiledImage) {
        if (!this.useCanvas) {
          return;
        }
        var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
        var context = this.context;
        context.save();
        context.lineWidth = 2 * $2.pixelDensityRatio;
        context.font = "small-caps bold " + 13 * $2.pixelDensityRatio + "px arial";
        context.strokeStyle = this.debugGridColor[colorIndex];
        context.fillStyle = this.debugGridColor[colorIndex];
        if (this.viewport.getRotation(true) % 360 !== 0) {
          this._offsetForRotation({ degrees: this.viewport.getRotation(true) });
        }
        if (tiledImage.getRotation(true) % 360 !== 0) {
          this._offsetForRotation({
            degrees: tiledImage.getRotation(true),
            point: tiledImage.viewport.pixelFromPointNoRotate(
              tiledImage._getRotationPoint(true),
              true
            )
          });
        }
        if (tiledImage.viewport.getRotation(true) % 360 === 0 && tiledImage.getRotation(true) % 360 === 0) {
          if (tiledImage._drawer.viewer.viewport.getFlip()) {
            tiledImage._drawer._flip();
          }
        }
        context.strokeRect(
          tile.position.x * $2.pixelDensityRatio,
          tile.position.y * $2.pixelDensityRatio,
          tile.size.x * $2.pixelDensityRatio,
          tile.size.y * $2.pixelDensityRatio
        );
        var tileCenterX = (tile.position.x + tile.size.x / 2) * $2.pixelDensityRatio;
        var tileCenterY = (tile.position.y + tile.size.y / 2) * $2.pixelDensityRatio;
        context.translate(tileCenterX, tileCenterY);
        context.rotate(Math.PI / 180 * -this.viewport.getRotation(true));
        context.translate(-tileCenterX, -tileCenterY);
        if (tile.x === 0 && tile.y === 0) {
          context.fillText(
            "Zoom: " + this.viewport.getZoom(),
            tile.position.x * $2.pixelDensityRatio,
            (tile.position.y - 30) * $2.pixelDensityRatio
          );
          context.fillText(
            "Pan: " + this.viewport.getBounds().toString(),
            tile.position.x * $2.pixelDensityRatio,
            (tile.position.y - 20) * $2.pixelDensityRatio
          );
        }
        context.fillText(
          "Level: " + tile.level,
          (tile.position.x + 10) * $2.pixelDensityRatio,
          (tile.position.y + 20) * $2.pixelDensityRatio
        );
        context.fillText(
          "Column: " + tile.x,
          (tile.position.x + 10) * $2.pixelDensityRatio,
          (tile.position.y + 30) * $2.pixelDensityRatio
        );
        context.fillText(
          "Row: " + tile.y,
          (tile.position.x + 10) * $2.pixelDensityRatio,
          (tile.position.y + 40) * $2.pixelDensityRatio
        );
        context.fillText(
          "Order: " + i + " of " + count,
          (tile.position.x + 10) * $2.pixelDensityRatio,
          (tile.position.y + 50) * $2.pixelDensityRatio
        );
        context.fillText(
          "Size: " + tile.size.toString(),
          (tile.position.x + 10) * $2.pixelDensityRatio,
          (tile.position.y + 60) * $2.pixelDensityRatio
        );
        context.fillText(
          "Position: " + tile.position.toString(),
          (tile.position.x + 10) * $2.pixelDensityRatio,
          (tile.position.y + 70) * $2.pixelDensityRatio
        );
        if (this.viewport.getRotation(true) % 360 !== 0) {
          this._restoreRotationChanges();
        }
        if (tiledImage.getRotation(true) % 360 !== 0) {
          this._restoreRotationChanges();
        }
        if (tiledImage.viewport.getRotation(true) % 360 === 0 && tiledImage.getRotation(true) % 360 === 0) {
          if (tiledImage._drawer.viewer.viewport.getFlip()) {
            tiledImage._drawer._flip();
          }
        }
        context.restore();
      },
      // private
      debugRect: function(rect) {
        if (this.useCanvas) {
          var context = this.context;
          context.save();
          context.lineWidth = 2 * $2.pixelDensityRatio;
          context.strokeStyle = this.debugGridColor[0];
          context.fillStyle = this.debugGridColor[0];
          context.strokeRect(
            rect.x * $2.pixelDensityRatio,
            rect.y * $2.pixelDensityRatio,
            rect.width * $2.pixelDensityRatio,
            rect.height * $2.pixelDensityRatio
          );
          context.restore();
        }
      },
      /**
       * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
       *
       * @function
       * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
       * drawn smoothly on the canvas; see imageSmoothingEnabled in
       * {@link OpenSeadragon.Options} for more explanation.
       */
      setImageSmoothingEnabled: function(imageSmoothingEnabled) {
        if (this.useCanvas) {
          this._imageSmoothingEnabled = imageSmoothingEnabled;
          this._updateImageSmoothingEnabled(this.context);
          this.viewer.forceRedraw();
        }
      },
      // private
      _updateImageSmoothingEnabled: function(context) {
        context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
        context.imageSmoothingEnabled = this._imageSmoothingEnabled;
      },
      /**
       * Get the canvas size
       * @param {Boolean} sketch If set to true return the size of the sketch canvas
       * @returns {OpenSeadragon.Point} The size of the canvas
       */
      getCanvasSize: function(sketch) {
        var canvas = this._getContext(sketch).canvas;
        return new $2.Point(canvas.width, canvas.height);
      },
      getCanvasCenter: function() {
        return new $2.Point(this.canvas.width / 2, this.canvas.height / 2);
      },
      // private
      _offsetForRotation: function(options) {
        var point = options.point ? options.point.times($2.pixelDensityRatio) : this.getCanvasCenter();
        var context = this._getContext(options.useSketch);
        context.save();
        context.translate(point.x, point.y);
        if (this.viewer.viewport.flipped) {
          context.rotate(Math.PI / 180 * -options.degrees);
          context.scale(-1, 1);
        } else {
          context.rotate(Math.PI / 180 * options.degrees);
        }
        context.translate(-point.x, -point.y);
      },
      // private
      _flip: function(options) {
        options = options || {};
        var point = options.point ? options.point.times($2.pixelDensityRatio) : this.getCanvasCenter();
        var context = this._getContext(options.useSketch);
        context.translate(point.x, 0);
        context.scale(-1, 1);
        context.translate(-point.x, 0);
      },
      // private
      _restoreRotationChanges: function(useSketch) {
        var context = this._getContext(useSketch);
        context.restore();
      },
      // private
      _calculateCanvasSize: function() {
        var pixelDensityRatio = $2.pixelDensityRatio;
        var viewportSize = this.viewport.getContainerSize();
        return {
          // canvas width and height are integers
          x: Math.round(viewportSize.x * pixelDensityRatio),
          y: Math.round(viewportSize.y * pixelDensityRatio)
        };
      },
      // private
      _calculateSketchCanvasSize: function() {
        var canvasSize = this._calculateCanvasSize();
        if (this.viewport.getRotation() === 0) {
          return canvasSize;
        }
        var sketchCanvasSize = Math.ceil(Math.sqrt(
          canvasSize.x * canvasSize.x + canvasSize.y * canvasSize.y
        ));
        return {
          x: sketchCanvasSize,
          y: sketchCanvasSize
        };
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.Viewport = function(options) {
      var args = arguments;
      if (args.length && args[0] instanceof $2.Point) {
        options = {
          containerSize: args[0],
          contentSize: args[1],
          config: args[2]
        };
      }
      if (options.config) {
        $2.extend(true, options, options.config);
        delete options.config;
      }
      this._margins = $2.extend({
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }, options.margins || {});
      delete options.margins;
      options.initialDegrees = options.degrees;
      delete options.degrees;
      $2.extend(true, this, {
        //required settings
        containerSize: null,
        contentSize: null,
        //internal state properties
        zoomPoint: null,
        rotationPivot: null,
        viewer: null,
        //configurable options
        springStiffness: $2.DEFAULT_SETTINGS.springStiffness,
        animationTime: $2.DEFAULT_SETTINGS.animationTime,
        minZoomImageRatio: $2.DEFAULT_SETTINGS.minZoomImageRatio,
        maxZoomPixelRatio: $2.DEFAULT_SETTINGS.maxZoomPixelRatio,
        visibilityRatio: $2.DEFAULT_SETTINGS.visibilityRatio,
        wrapHorizontal: $2.DEFAULT_SETTINGS.wrapHorizontal,
        wrapVertical: $2.DEFAULT_SETTINGS.wrapVertical,
        defaultZoomLevel: $2.DEFAULT_SETTINGS.defaultZoomLevel,
        minZoomLevel: $2.DEFAULT_SETTINGS.minZoomLevel,
        maxZoomLevel: $2.DEFAULT_SETTINGS.maxZoomLevel,
        initialDegrees: $2.DEFAULT_SETTINGS.degrees,
        flipped: $2.DEFAULT_SETTINGS.flipped,
        homeFillsViewer: $2.DEFAULT_SETTINGS.homeFillsViewer,
        silenceMultiImageWarnings: $2.DEFAULT_SETTINGS.silenceMultiImageWarnings
      }, options);
      this._updateContainerInnerSize();
      this.centerSpringX = new $2.Spring({
        initial: 0,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this.centerSpringY = new $2.Spring({
        initial: 0,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this.zoomSpring = new $2.Spring({
        exponential: true,
        initial: 1,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this.degreesSpring = new $2.Spring({
        initial: options.initialDegrees,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._oldCenterX = this.centerSpringX.current.value;
      this._oldCenterY = this.centerSpringY.current.value;
      this._oldZoom = this.zoomSpring.current.value;
      this._oldDegrees = this.degreesSpring.current.value;
      this._setContentBounds(new $2.Rect(0, 0, 1, 1), 1);
      this.goHome(true);
      this.update();
    };
    $2.Viewport.prototype = {
      // deprecated
      get degrees() {
        $2.console.warn("Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead.");
        return this.getRotation();
      },
      // deprecated
      set degrees(degrees) {
        $2.console.warn("Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead.");
        this.rotateTo(degrees);
      },
      /**
       * Updates the viewport's home bounds and constraints for the given content size.
       * @function
       * @param {OpenSeadragon.Point} contentSize - size of the content in content units
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:reset-size
       */
      resetContentSize: function(contentSize) {
        $2.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
        $2.console.assert(contentSize instanceof $2.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
        $2.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
        $2.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
        this._setContentBounds(new $2.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
        return this;
      },
      // deprecated
      setHomeBounds: function(bounds, contentFactor) {
        $2.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
        this._setContentBounds(bounds, contentFactor);
      },
      // Set the viewport's content bounds
      // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
      // without rotation
      // @param {Number} contentFactor - how many content units per viewport unit
      // @fires OpenSeadragon.Viewer.event:reset-size
      // @private
      _setContentBounds: function(bounds, contentFactor) {
        $2.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
        $2.console.assert(bounds instanceof $2.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
        $2.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
        $2.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");
        this._contentBoundsNoRotate = bounds.clone();
        this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
          contentFactor
        );
        this._contentBounds = bounds.rotate(this.getRotation()).getBoundingBox();
        this._contentSize = this._contentBounds.getSize().times(contentFactor);
        this._contentAspectRatio = this._contentSize.x / this._contentSize.y;
        if (this.viewer) {
          this.viewer.raiseEvent("reset-size", {
            contentSize: this._contentSizeNoRotate.clone(),
            contentFactor,
            homeBounds: this._contentBoundsNoRotate.clone(),
            contentBounds: this._contentBounds.clone()
          });
        }
      },
      /**
       * Returns the home zoom in "viewport zoom" value.
       * @function
       * @returns {Number} The home zoom in "viewport zoom".
       */
      getHomeZoom: function() {
        if (this.defaultZoomLevel) {
          return this.defaultZoomLevel;
        }
        var aspectFactor = this._contentAspectRatio / this.getAspectRatio();
        var output;
        if (this.homeFillsViewer) {
          output = aspectFactor >= 1 ? aspectFactor : 1;
        } else {
          output = aspectFactor >= 1 ? 1 : aspectFactor;
        }
        return output / this._contentBounds.width;
      },
      /**
       * Returns the home bounds in viewport coordinates.
       * @function
       * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
       */
      getHomeBounds: function() {
        return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
      },
      /**
       * Returns the home bounds in viewport coordinates.
       * This method ignores the viewport rotation. Use
       * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
       * @function
       * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
       */
      getHomeBoundsNoRotate: function() {
        var center = this._contentBounds.getCenter();
        var width = 1 / this.getHomeZoom();
        var height = width / this.getAspectRatio();
        return new $2.Rect(
          center.x - width / 2,
          center.y - height / 2,
          width,
          height
        );
      },
      /**
       * @function
       * @param {Boolean} immediately
       * @fires OpenSeadragon.Viewer.event:home
       */
      goHome: function(immediately) {
        if (this.viewer) {
          this.viewer.raiseEvent("home", {
            immediately
          });
        }
        return this.fitBounds(this.getHomeBounds(), immediately);
      },
      /**
       * @function
       */
      getMinZoom: function() {
        var homeZoom = this.getHomeZoom(), zoom = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * homeZoom;
        return zoom;
      },
      /**
       * @function
       */
      getMaxZoom: function() {
        var zoom = this.maxZoomLevel;
        if (!zoom) {
          zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
          zoom /= this._contentBounds.width;
        }
        return Math.max(zoom, this.getHomeZoom());
      },
      /**
       * @function
       */
      getAspectRatio: function() {
        return this._containerInnerSize.x / this._containerInnerSize.y;
      },
      /**
       * @function
       * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
       */
      getContainerSize: function() {
        return new $2.Point(
          this.containerSize.x,
          this.containerSize.y
        );
      },
      /**
       * The margins push the "home" region in from the sides by the specified amounts.
       * @function
       * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
       */
      getMargins: function() {
        return $2.extend({}, this._margins);
      },
      /**
       * The margins push the "home" region in from the sides by the specified amounts.
       * @function
       * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
       */
      setMargins: function(margins) {
        $2.console.assert($2.type(margins) === "object", "[Viewport.setMargins] margins must be an object");
        this._margins = $2.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, margins);
        this._updateContainerInnerSize();
        if (this.viewer) {
          this.viewer.forceRedraw();
        }
      },
      /**
       * Returns the bounds of the visible area in viewport coordinates.
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
       */
      getBounds: function(current) {
        return this.getBoundsNoRotate(current).rotate(-this.getRotation(current));
      },
      /**
       * Returns the bounds of the visible area in viewport coordinates.
       * This method ignores the viewport rotation. Use
       * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
       */
      getBoundsNoRotate: function(current) {
        var center = this.getCenter(current);
        var width = 1 / this.getZoom(current);
        var height = width / this.getAspectRatio();
        return new $2.Rect(
          center.x - width / 2,
          center.y - height / 2,
          width,
          height
        );
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
       * including the space taken by margins, in viewport coordinates.
       */
      getBoundsWithMargins: function(current) {
        return this.getBoundsNoRotateWithMargins(current).rotate(
          -this.getRotation(current),
          this.getCenter(current)
        );
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
       * including the space taken by margins, in viewport coordinates.
       */
      getBoundsNoRotateWithMargins: function(current) {
        var bounds = this.getBoundsNoRotate(current);
        var factor = this._containerInnerSize.x * this.getZoom(current);
        bounds.x -= this._margins.left / factor;
        bounds.y -= this._margins.top / factor;
        bounds.width += (this._margins.left + this._margins.right) / factor;
        bounds.height += (this._margins.top + this._margins.bottom) / factor;
        return bounds;
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       */
      getCenter: function(current) {
        var centerCurrent = new $2.Point(
          this.centerSpringX.current.value,
          this.centerSpringY.current.value
        ), centerTarget = new $2.Point(
          this.centerSpringX.target.value,
          this.centerSpringY.target.value
        ), oldZoomPixel, zoom, width, height, bounds, newZoomPixel, deltaZoomPixels, deltaZoomPoints;
        if (current) {
          return centerCurrent;
        } else if (!this.zoomPoint) {
          return centerTarget;
        }
        oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
        zoom = this.getZoom();
        width = 1 / zoom;
        height = width / this.getAspectRatio();
        bounds = new $2.Rect(
          centerCurrent.x - width / 2,
          centerCurrent.y - height / 2,
          width,
          height
        );
        newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
        deltaZoomPixels = newZoomPixel.minus(oldZoomPixel).rotate(-this.getRotation(true));
        deltaZoomPoints = deltaZoomPixels.divide(this._containerInnerSize.x * zoom);
        return centerTarget.plus(deltaZoomPoints);
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       */
      getZoom: function(current) {
        if (current) {
          return this.zoomSpring.current.value;
        } else {
          return this.zoomSpring.target.value;
        }
      },
      // private
      _applyZoomConstraints: function(zoom) {
        return Math.max(
          Math.min(zoom, this.getMaxZoom()),
          this.getMinZoom()
        );
      },
      /**
       * @function
       * @private
       * @param {OpenSeadragon.Rect} bounds
       * @returns {OpenSeadragon.Rect} constrained bounds.
       */
      _applyBoundaryConstraints: function(bounds) {
        var newBounds = this.viewportToViewerElementRectangle(bounds).getBoundingBox();
        var cb = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox();
        var xConstrained = false;
        var yConstrained = false;
        if (this.wrapHorizontal) ;
        else {
          var boundsRight = newBounds.x + newBounds.width;
          var contentRight = cb.x + cb.width;
          var horizontalThreshold, leftDx, rightDx;
          if (newBounds.width > cb.width) {
            horizontalThreshold = this.visibilityRatio * cb.width;
          } else {
            horizontalThreshold = this.visibilityRatio * newBounds.width;
          }
          leftDx = cb.x - boundsRight + horizontalThreshold;
          rightDx = contentRight - newBounds.x - horizontalThreshold;
          if (horizontalThreshold > cb.width) {
            newBounds.x += (leftDx + rightDx) / 2;
            xConstrained = true;
          } else if (rightDx < 0) {
            newBounds.x += rightDx;
            xConstrained = true;
          } else if (leftDx > 0) {
            newBounds.x += leftDx;
            xConstrained = true;
          }
        }
        if (this.wrapVertical) ;
        else {
          var boundsBottom = newBounds.y + newBounds.height;
          var contentBottom = cb.y + cb.height;
          var verticalThreshold, topDy, bottomDy;
          if (newBounds.height > cb.height) {
            verticalThreshold = this.visibilityRatio * cb.height;
          } else {
            verticalThreshold = this.visibilityRatio * newBounds.height;
          }
          topDy = cb.y - boundsBottom + verticalThreshold;
          bottomDy = contentBottom - newBounds.y - verticalThreshold;
          if (verticalThreshold > cb.height) {
            newBounds.y += (topDy + bottomDy) / 2;
            yConstrained = true;
          } else if (bottomDy < 0) {
            newBounds.y += bottomDy;
            yConstrained = true;
          } else if (topDy > 0) {
            newBounds.y += topDy;
            yConstrained = true;
          }
        }
        var constraintApplied = xConstrained || yConstrained;
        var newViewportBounds = constraintApplied ? this.viewerElementToViewportRectangle(newBounds) : bounds.clone();
        newViewportBounds.xConstrained = xConstrained;
        newViewportBounds.yConstrained = yConstrained;
        newViewportBounds.constraintApplied = constraintApplied;
        return newViewportBounds;
      },
      /**
       * @function
       * @private
       * @param {Boolean} [immediately=false] - whether the function that triggered this event was
       * called with the "immediately" flag
       */
      _raiseConstraintsEvent: function(immediately) {
        if (this.viewer) {
          this.viewer.raiseEvent("constrain", {
            immediately
          });
        }
      },
      /**
       * Enforces the minZoom, maxZoom and visibilityRatio constraints by
       * zooming and panning to the closest acceptable zoom and location.
       * @function
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:constrain if constraints were applied
       */
      applyConstraints: function(immediately) {
        var actualZoom = this.getZoom();
        var constrainedZoom = this._applyZoomConstraints(actualZoom);
        if (actualZoom !== constrainedZoom) {
          this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
        }
        var constrainedBounds = this.getConstrainedBounds(false);
        if (constrainedBounds.constraintApplied) {
          this.fitBounds(constrainedBounds, immediately);
          this._raiseConstraintsEvent(immediately);
        }
        return this;
      },
      /**
       * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
       * @function
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:constrain
       */
      ensureVisible: function(immediately) {
        return this.applyConstraints(immediately);
      },
      /**
       * @function
       * @private
       * @param {OpenSeadragon.Rect} bounds
       * @param {Object} options (immediately=false, constraints=false)
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      _fitBounds: function(bounds, options) {
        options = options || {};
        var immediately = options.immediately || false;
        var constraints = options.constraints || false;
        var aspect = this.getAspectRatio();
        var center = bounds.getCenter();
        var newBounds = new $2.Rect(
          bounds.x,
          bounds.y,
          bounds.width,
          bounds.height,
          bounds.degrees + this.getRotation()
        ).getBoundingBox();
        if (newBounds.getAspectRatio() >= aspect) {
          newBounds.height = newBounds.width / aspect;
        } else {
          newBounds.width = newBounds.height * aspect;
        }
        newBounds.x = center.x - newBounds.width / 2;
        newBounds.y = center.y - newBounds.height / 2;
        var newZoom = 1 / newBounds.width;
        if (immediately) {
          this.panTo(center, true);
          this.zoomTo(newZoom, null, true);
          if (constraints) {
            this.applyConstraints(true);
          }
          return this;
        }
        var currentCenter = this.getCenter(true);
        var currentZoom = this.getZoom(true);
        this.panTo(currentCenter, true);
        this.zoomTo(currentZoom, null, true);
        var oldBounds = this.getBounds();
        var oldZoom = this.getZoom();
        if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 1e-8) {
          this.zoomTo(newZoom, null, true);
          this.panTo(center, immediately);
          if (constraints) {
            this.applyConstraints(false);
          }
          return this;
        }
        if (constraints) {
          this.panTo(center, false);
          newZoom = this._applyZoomConstraints(newZoom);
          this.zoomTo(newZoom, null, false);
          var constrainedBounds = this.getConstrainedBounds();
          this.panTo(currentCenter, true);
          this.zoomTo(currentZoom, null, true);
          this.fitBounds(constrainedBounds);
        } else {
          var rotatedNewBounds = newBounds.rotate(-this.getRotation());
          var referencePoint = rotatedNewBounds.getTopLeft().times(newZoom).minus(oldBounds.getTopLeft().times(oldZoom)).divide(newZoom - oldZoom);
          this.zoomTo(newZoom, referencePoint, immediately);
        }
        return this;
      },
      /**
       * Makes the viewport zoom and pan so that the specified bounds take
       * as much space as possible in the viewport.
       * Note: this method ignores the constraints (minZoom, maxZoom and
       * visibilityRatio).
       * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
       * them.
       * @function
       * @param {OpenSeadragon.Rect} bounds
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitBounds: function(bounds, immediately) {
        return this._fitBounds(bounds, {
          immediately,
          constraints: false
        });
      },
      /**
       * Makes the viewport zoom and pan so that the specified bounds take
       * as much space as possible in the viewport while enforcing the constraints
       * (minZoom, maxZoom and visibilityRatio).
       * Note: because this method enforces the constraints, part of the
       * provided bounds may end up outside of the viewport.
       * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
       * @function
       * @param {OpenSeadragon.Rect} bounds
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitBoundsWithConstraints: function(bounds, immediately) {
        return this._fitBounds(bounds, {
          immediately,
          constraints: true
        });
      },
      /**
       * Zooms so the image just fills the viewer vertically.
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitVertically: function(immediately) {
        var box = new $2.Rect(
          this._contentBounds.x + this._contentBounds.width / 2,
          this._contentBounds.y,
          0,
          this._contentBounds.height
        );
        return this.fitBounds(box, immediately);
      },
      /**
       * Zooms so the image just fills the viewer horizontally.
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitHorizontally: function(immediately) {
        var box = new $2.Rect(
          this._contentBounds.x,
          this._contentBounds.y + this._contentBounds.height / 2,
          this._contentBounds.width,
          0
        );
        return this.fitBounds(box, immediately);
      },
      /**
       * Returns bounds taking constraints into account
       * Added to improve constrained panning
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The bounds in viewport coordinates after applying constraints. The returned $.Rect
       *                               contains additional properties constraintsApplied, xConstrained and yConstrained.
       *                               These flags indicate whether the viewport bounds were modified by the constraints
       *                               of the viewer rectangle, and in which dimension(s).
       */
      getConstrainedBounds: function(current) {
        var bounds, constrainedBounds;
        bounds = this.getBounds(current);
        constrainedBounds = this._applyBoundaryConstraints(bounds);
        return constrainedBounds;
      },
      /**
       * @function
       * @param {OpenSeadragon.Point} delta
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:pan
       */
      panBy: function(delta, immediately) {
        var center = new $2.Point(
          this.centerSpringX.target.value,
          this.centerSpringY.target.value
        );
        return this.panTo(center.plus(delta), immediately);
      },
      /**
       * @function
       * @param {OpenSeadragon.Point} center
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:pan
       */
      panTo: function(center, immediately) {
        if (immediately) {
          this.centerSpringX.resetTo(center.x);
          this.centerSpringY.resetTo(center.y);
        } else {
          this.centerSpringX.springTo(center.x);
          this.centerSpringY.springTo(center.y);
        }
        if (this.viewer) {
          this.viewer.raiseEvent("pan", {
            center,
            immediately
          });
        }
        return this;
      },
      /**
       * @function
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:zoom
       */
      zoomBy: function(factor, refPoint, immediately) {
        return this.zoomTo(
          this.zoomSpring.target.value * factor,
          refPoint,
          immediately
        );
      },
      /**
       * Zooms to the specified zoom level
       * @function
       * @param {Number} zoom The zoom level to zoom to.
       * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
       * the same screen location. Defaults to the viewport center.
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:zoom
       */
      zoomTo: function(zoom, refPoint, immediately) {
        var _this = this;
        this.zoomPoint = refPoint instanceof $2.Point && !isNaN(refPoint.x) && !isNaN(refPoint.y) ? refPoint : null;
        if (immediately) {
          this._adjustCenterSpringsForZoomPoint(function() {
            _this.zoomSpring.resetTo(zoom);
          });
        } else {
          this.zoomSpring.springTo(zoom);
        }
        if (this.viewer) {
          this.viewer.raiseEvent("zoom", {
            zoom,
            refPoint,
            immediately
          });
        }
        return this;
      },
      /**
       * Rotates this viewport to the angle specified.
       * @function
       * @param {Number} degrees The degrees to set the rotation to.
       * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * * @returns {OpenSeadragon.Viewport} Chainable.
       */
      setRotation: function(degrees, immediately) {
        return this.rotateTo(degrees, null, immediately);
      },
      /**
       * Gets the current rotation in degrees.
       * @function
       * @param {Boolean} [current=false] True for current rotation, false for target.
       * @returns {Number} The current rotation in degrees.
       */
      getRotation: function(current) {
        return current ? this.degreesSpring.current.value : this.degreesSpring.target.value;
      },
      /**
       * Rotates this viewport to the angle specified around a pivot point. Alias for rotateTo.
       * @function
       * @param {Number} degrees The degrees to set the rotation to.
       * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
       * around which the rotation should be performed. Defaults to the center of the viewport.
       * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * * @returns {OpenSeadragon.Viewport} Chainable.
       */
      setRotationWithPivot: function(degrees, pivot, immediately) {
        return this.rotateTo(degrees, pivot, immediately);
      },
      /**
       * Rotates this viewport to the angle specified.
       * @function
       * @param {Number} degrees The degrees to set the rotation to.
       * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
       * around which the rotation should be performed. Defaults to the center of the viewport.
       * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      rotateTo: function(degrees, pivot, immediately) {
        if (!this.viewer || !this.viewer.drawer.canRotate()) {
          return this;
        }
        if (this.degreesSpring.target.value === degrees && this.degreesSpring.isAtTargetValue()) {
          return this;
        }
        this.rotationPivot = pivot instanceof $2.Point && !isNaN(pivot.x) && !isNaN(pivot.y) ? pivot : null;
        if (immediately) {
          if (this.rotationPivot) {
            var changeInDegrees = degrees - this._oldDegrees;
            if (!changeInDegrees) {
              this.rotationPivot = null;
              return this;
            }
            this._rotateAboutPivot(degrees);
          } else {
            this.degreesSpring.resetTo(degrees);
          }
        } else {
          var normalizedFrom = $2.positiveModulo(this.degreesSpring.current.value, 360);
          var normalizedTo = $2.positiveModulo(degrees, 360);
          var diff = normalizedTo - normalizedFrom;
          if (diff > 180) {
            normalizedTo -= 360;
          } else if (diff < -180) {
            normalizedTo += 360;
          }
          var reverseDiff = normalizedFrom - normalizedTo;
          this.degreesSpring.resetTo(degrees + reverseDiff);
          this.degreesSpring.springTo(degrees);
        }
        this._setContentBounds(
          this.viewer.world.getHomeBounds(),
          this.viewer.world.getContentFactor()
        );
        this.viewer.forceRedraw();
        this.viewer.raiseEvent("rotate", { degrees, immediately: !!immediately, pivot: this.rotationPivot || this.getCenter() });
        return this;
      },
      /**
       * Rotates this viewport by the angle specified.
       * @function
       * @param {Number} degrees The degrees by which to rotate the viewport.
       * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
       * around which the rotation should be performed. Defaults to the center of the viewport.
       * * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      rotateBy: function(degrees, pivot, immediately) {
        return this.rotateTo(this.degreesSpring.target.value + degrees, pivot, immediately);
      },
      /**
       * @function
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:resize
       */
      resize: function(newContainerSize, maintain) {
        var oldBounds = this.getBoundsNoRotate(), newBounds = oldBounds, widthDeltaFactor;
        this.containerSize.x = newContainerSize.x;
        this.containerSize.y = newContainerSize.y;
        this._updateContainerInnerSize();
        if (maintain) {
          widthDeltaFactor = newContainerSize.x / this.containerSize.x;
          newBounds.width = oldBounds.width * widthDeltaFactor;
          newBounds.height = newBounds.width / this.getAspectRatio();
        }
        if (this.viewer) {
          this.viewer.raiseEvent("resize", {
            newContainerSize,
            maintain
          });
        }
        var output = this.fitBounds(newBounds, true);
        if (this.viewer) {
          this.viewer.raiseEvent("after-resize", {
            newContainerSize,
            maintain
          });
        }
        return output;
      },
      // private
      _updateContainerInnerSize: function() {
        this._containerInnerSize = new $2.Point(
          Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
          Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
        );
      },
      /**
       * Update the zoom, degrees, and center (X and Y) springs.
       * @function
       * @returns {Boolean} True if any change has been made, false otherwise.
       */
      update: function() {
        var _this = this;
        this._adjustCenterSpringsForZoomPoint(function() {
          _this.zoomSpring.update();
        });
        if (this.degreesSpring.isAtTargetValue()) {
          this.rotationPivot = null;
        }
        this.centerSpringX.update();
        this.centerSpringY.update();
        if (this.rotationPivot) {
          this._rotateAboutPivot(true);
        } else {
          this.degreesSpring.update();
        }
        var changed = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom || this.degreesSpring.current.value !== this._oldDegrees;
        this._oldCenterX = this.centerSpringX.current.value;
        this._oldCenterY = this.centerSpringY.current.value;
        this._oldZoom = this.zoomSpring.current.value;
        this._oldDegrees = this.degreesSpring.current.value;
        return changed;
      },
      // private - pass true to use spring, or a number for degrees for immediate rotation
      _rotateAboutPivot: function(degreesOrUseSpring) {
        var useSpring = degreesOrUseSpring === true;
        var delta = this.rotationPivot.minus(this.getCenter());
        this.centerSpringX.shiftBy(delta.x);
        this.centerSpringY.shiftBy(delta.y);
        if (useSpring) {
          this.degreesSpring.update();
        } else {
          this.degreesSpring.resetTo(degreesOrUseSpring);
        }
        var changeInDegrees = this.degreesSpring.current.value - this._oldDegrees;
        var rdelta = delta.rotate(changeInDegrees * -1).times(-1);
        this.centerSpringX.shiftBy(rdelta.x);
        this.centerSpringY.shiftBy(rdelta.y);
      },
      // private
      _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
        if (this.zoomPoint) {
          var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
          zoomSpringHandler();
          var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
          var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
          var deltaZoomPoints = this.deltaPointsFromPixels(
            deltaZoomPixels,
            true
          );
          this.centerSpringX.shiftBy(deltaZoomPoints.x);
          this.centerSpringY.shiftBy(deltaZoomPoints.y);
          if (this.zoomSpring.isAtTargetValue()) {
            this.zoomPoint = null;
          }
        } else {
          zoomSpringHandler();
        }
      },
      /**
       * Convert a delta (translation vector) from viewport coordinates to pixels
       * coordinates. This method does not take rotation into account.
       * Consider using deltaPixelsFromPoints if you need to account for rotation.
       * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
        return deltaPoints.times(
          this._containerInnerSize.x * this.getZoom(current)
        );
      },
      /**
       * Convert a delta (translation vector) from viewport coordinates to pixels
       * coordinates.
       * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPixelsFromPoints: function(deltaPoints, current) {
        return this.deltaPixelsFromPointsNoRotate(
          deltaPoints.rotate(this.getRotation(current)),
          current
        );
      },
      /**
       * Convert a delta (translation vector) from pixels coordinates to viewport
       * coordinates. This method does not take rotation into account.
       * Consider using deltaPointsFromPixels if you need to account for rotation.
       * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
        return deltaPixels.divide(
          this._containerInnerSize.x * this.getZoom(current)
        );
      },
      /**
       * Convert a delta (translation vector) from pixels coordinates to viewport
       * coordinates.
       * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPointsFromPixels: function(deltaPixels, current) {
        return this.deltaPointsFromPixelsNoRotate(deltaPixels, current).rotate(-this.getRotation(current));
      },
      /**
       * Convert viewport coordinates to pixels coordinates.
       * This method does not take rotation into account.
       * Consider using pixelFromPoint if you need to account for rotation.
       * @param {OpenSeadragon.Point} point the viewport coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pixelFromPointNoRotate: function(point, current) {
        return this._pixelFromPointNoRotate(
          point,
          this.getBoundsNoRotate(current)
        );
      },
      /**
       * Convert viewport coordinates to pixel coordinates.
       * @param {OpenSeadragon.Point} point the viewport coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pixelFromPoint: function(point, current) {
        return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
      },
      // private
      _pixelFromPointNoRotate: function(point, bounds) {
        return point.minus(
          bounds.getTopLeft()
        ).times(
          this._containerInnerSize.x / bounds.width
        ).plus(
          new $2.Point(this._margins.left, this._margins.top)
        );
      },
      // private
      _pixelFromPoint: function(point, bounds) {
        return this._pixelFromPointNoRotate(
          point.rotate(this.getRotation(true), this.getCenter(true)),
          bounds
        );
      },
      /**
       * Convert pixel coordinates to viewport coordinates.
       * This method does not take rotation into account.
       * Consider using pointFromPixel if you need to account for rotation.
       * @param {OpenSeadragon.Point} pixel Pixel coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pointFromPixelNoRotate: function(pixel, current) {
        var bounds = this.getBoundsNoRotate(current);
        return pixel.minus(
          new $2.Point(this._margins.left, this._margins.top)
        ).divide(
          this._containerInnerSize.x / bounds.width
        ).plus(
          bounds.getTopLeft()
        );
      },
      /**
       * Convert pixel coordinates to viewport coordinates.
       * @param {OpenSeadragon.Point} pixel Pixel coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pointFromPixel: function(pixel, current) {
        return this.pointFromPixelNoRotate(pixel, current).rotate(
          -this.getRotation(current),
          this.getCenter(current)
        );
      },
      // private
      _viewportToImageDelta: function(viewerX, viewerY) {
        var scale = this._contentBoundsNoRotate.width;
        return new $2.Point(
          viewerX * this._contentSizeNoRotate.x / scale,
          viewerY * this._contentSizeNoRotate.x / scale
        );
      },
      /**
       * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
       * This method can be called either by passing X,Y coordinates or an
       * OpenSeadragon.Point
       * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
       * @function
       * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
       * coordinate in viewport coordinate system.
       * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
       * @returns {OpenSeadragon.Point} a point representing the coordinates in the image.
       */
      viewportToImageCoordinates: function(viewerX, viewerY) {
        if (viewerX instanceof $2.Point) {
          return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $2.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.viewportToImageCoordinates(viewerX, viewerY, true);
          }
        }
        return this._viewportToImageDelta(
          viewerX - this._contentBoundsNoRotate.x,
          viewerY - this._contentBoundsNoRotate.y
        );
      },
      // private
      _imageToViewportDelta: function(imageX, imageY) {
        var scale = this._contentBoundsNoRotate.width;
        return new $2.Point(
          imageX / this._contentSizeNoRotate.x * scale,
          imageY / this._contentSizeNoRotate.x * scale
        );
      },
      /**
       * Translates from image coordinate system to OpenSeadragon viewer coordinate system
       * This method can be called either by passing X,Y coordinates or an
       * OpenSeadragon.Point
       * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
       * @function
       * @param {(OpenSeadragon.Point | Number)} imageX the point or the
       * X coordinate in image coordinate system.
       * @param {Number} [imageY] Y coordinate in image coordinate system.
       * @returns {OpenSeadragon.Point} a point representing the coordinates in the viewport.
       */
      imageToViewportCoordinates: function(imageX, imageY) {
        if (imageX instanceof $2.Point) {
          return this.imageToViewportCoordinates(imageX.x, imageX.y);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $2.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.imageToViewportCoordinates(imageX, imageY, true);
          }
        }
        var point = this._imageToViewportDelta(imageX, imageY);
        point.x += this._contentBoundsNoRotate.x;
        point.y += this._contentBoundsNoRotate.y;
        return point;
      },
      /**
       * Translates from a rectangle which describes a portion of the image in
       * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an
       * OpenSeadragon.Rect
       * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
       * @function
       * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
       * coordinate of the top left corner of the rectangle in image coordinate system.
       * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
       * in image coordinate system.
       * @param {Number} [pixelWidth] the width in pixel of the rectangle.
       * @param {Number} [pixelHeight] the height in pixel of the rectangle.
       * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
       */
      imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
        var rect = imageX;
        if (!(rect instanceof $2.Rect)) {
          rect = new $2.Rect(imageX, imageY, pixelWidth, pixelHeight);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $2.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.imageToViewportRectangle(
              imageX,
              imageY,
              pixelWidth,
              pixelHeight,
              true
            );
          }
        }
        var coordA = this.imageToViewportCoordinates(rect.x, rect.y);
        var coordB = this._imageToViewportDelta(rect.width, rect.height);
        return new $2.Rect(
          coordA.x,
          coordA.y,
          coordB.x,
          coordB.y,
          rect.degrees
        );
      },
      /**
       * Translates from a rectangle which describes a portion of
       * the viewport in point coordinates to image rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an
       * OpenSeadragon.Rect
       * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
       * @function
       * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
       * the X coordinate of the top left corner of the rectangle in viewport
       * coordinate system.
       * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
       * in viewport coordinate system.
       * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
       * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
       */
      viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
        var rect = viewerX;
        if (!(rect instanceof $2.Rect)) {
          rect = new $2.Rect(viewerX, viewerY, pointWidth, pointHeight);
        }
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $2.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.viewportToImageRectangle(
              viewerX,
              viewerY,
              pointWidth,
              pointHeight,
              true
            );
          }
        }
        var coordA = this.viewportToImageCoordinates(rect.x, rect.y);
        var coordB = this._viewportToImageDelta(rect.width, rect.height);
        return new $2.Rect(
          coordA.x,
          coordA.y,
          coordB.x,
          coordB.y,
          rect.degrees
        );
      },
      /**
       * Convert pixel coordinates relative to the viewer element to image
       * coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      viewerElementToImageCoordinates: function(pixel) {
        var point = this.pointFromPixel(pixel, true);
        return this.viewportToImageCoordinates(point);
      },
      /**
       * Convert pixel coordinates relative to the image to
       * viewer element coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToViewerElementCoordinates: function(pixel) {
        var point = this.imageToViewportCoordinates(pixel);
        return this.pixelFromPoint(point, true);
      },
      /**
       * Convert pixel coordinates relative to the window to image coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      windowToImageCoordinates: function(pixel) {
        $2.console.assert(
          this.viewer,
          "[Viewport.windowToImageCoordinates] the viewport must have a viewer."
        );
        var viewerCoordinates = pixel.minus(
          $2.getElementPosition(this.viewer.element)
        );
        return this.viewerElementToImageCoordinates(viewerCoordinates);
      },
      /**
       * Convert image coordinates to pixel coordinates relative to the window.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToWindowCoordinates: function(pixel) {
        $2.console.assert(
          this.viewer,
          "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."
        );
        var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
        return viewerCoordinates.plus(
          $2.getElementPosition(this.viewer.element)
        );
      },
      /**
       * Convert pixel coordinates relative to the viewer element to viewport
       * coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      viewerElementToViewportCoordinates: function(pixel) {
        return this.pointFromPixel(pixel, true);
      },
      /**
       * Convert viewport coordinates to pixel coordinates relative to the
       * viewer element.
       * @param {OpenSeadragon.Point} point
       * @returns {OpenSeadragon.Point}
       */
      viewportToViewerElementCoordinates: function(point) {
        return this.pixelFromPoint(point, true);
      },
      /**
       * Convert a rectangle in pixel coordinates relative to the viewer element
       * to viewport coordinates.
       * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
       * @returns {OpenSeadragon.Rect} the converted rectangle
       */
      viewerElementToViewportRectangle: function(rectangle) {
        return $2.Rect.fromSummits(
          this.pointFromPixel(rectangle.getTopLeft(), true),
          this.pointFromPixel(rectangle.getTopRight(), true),
          this.pointFromPixel(rectangle.getBottomLeft(), true)
        );
      },
      /**
       * Convert a rectangle in viewport coordinates to pixel coordinates relative
       * to the viewer element.
       * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
       * @returns {OpenSeadragon.Rect} the converted rectangle
       */
      viewportToViewerElementRectangle: function(rectangle) {
        return $2.Rect.fromSummits(
          this.pixelFromPoint(rectangle.getTopLeft(), true),
          this.pixelFromPoint(rectangle.getTopRight(), true),
          this.pixelFromPoint(rectangle.getBottomLeft(), true)
        );
      },
      /**
       * Convert pixel coordinates relative to the window to viewport coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      windowToViewportCoordinates: function(pixel) {
        $2.console.assert(
          this.viewer,
          "[Viewport.windowToViewportCoordinates] the viewport must have a viewer."
        );
        var viewerCoordinates = pixel.minus(
          $2.getElementPosition(this.viewer.element)
        );
        return this.viewerElementToViewportCoordinates(viewerCoordinates);
      },
      /**
       * Convert viewport coordinates to pixel coordinates relative to the window.
       * @param {OpenSeadragon.Point} point
       * @returns {OpenSeadragon.Point}
       */
      viewportToWindowCoordinates: function(point) {
        $2.console.assert(
          this.viewer,
          "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."
        );
        var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
        return viewerCoordinates.plus(
          $2.getElementPosition(this.viewer.element)
        );
      },
      /**
       * Convert a viewport zoom to an image zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * Note: not accurate with multi-image.
       * @function
       * @param {Number} viewportZoom The viewport zoom
       * target zoom.
       * @returns {Number} imageZoom The image zoom
       */
      viewportToImageZoom: function(viewportZoom) {
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $2.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.viewportToImageZoom(viewportZoom);
          }
        }
        var imageWidth = this._contentSizeNoRotate.x;
        var containerWidth = this._containerInnerSize.x;
        var scale = this._contentBoundsNoRotate.width;
        var viewportToImageZoomRatio = containerWidth / imageWidth * scale;
        return viewportZoom * viewportToImageZoomRatio;
      },
      /**
       * Convert an image zoom to a viewport zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * Note: not accurate with multi-image.
       * @function
       * @param {Number} imageZoom The image zoom
       * target zoom.
       * @returns {Number} viewportZoom The viewport zoom
       */
      imageToViewportZoom: function(imageZoom) {
        if (this.viewer) {
          var count = this.viewer.world.getItemCount();
          if (count > 1) {
            if (!this.silenceMultiImageWarnings) {
              $2.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image.");
            }
          } else if (count === 1) {
            var item = this.viewer.world.getItemAt(0);
            return item.imageToViewportZoom(imageZoom);
          }
        }
        var imageWidth = this._contentSizeNoRotate.x;
        var containerWidth = this._containerInnerSize.x;
        var scale = this._contentBoundsNoRotate.width;
        var viewportToImageZoomRatio = imageWidth / containerWidth / scale;
        return imageZoom * viewportToImageZoomRatio;
      },
      /**
       * Toggles flip state and demands a new drawing on navigator and viewer objects.
       * @function
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      toggleFlip: function() {
        this.setFlip(!this.getFlip());
        return this;
      },
      /**
       * Get flip state stored on viewport.
       * @function
       * @returns {Boolean} Flip state.
       */
      getFlip: function() {
        return this.flipped;
      },
      /**
       * Sets flip state according to the state input argument.
       * @function
       * @param {Boolean} state - Flip state to set.
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      setFlip: function(state) {
        if (this.flipped === state) {
          return this;
        }
        this.flipped = state;
        if (this.viewer.navigator) {
          this.viewer.navigator.setFlip(this.getFlip());
        }
        this.viewer.forceRedraw();
        this.viewer.raiseEvent("flip", { flipped: state });
        return this;
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.TiledImage = function(options) {
      var _this = this;
      $2.console.assert(options.tileCache, "[TiledImage] options.tileCache is required");
      $2.console.assert(options.drawer, "[TiledImage] options.drawer is required");
      $2.console.assert(options.viewer, "[TiledImage] options.viewer is required");
      $2.console.assert(options.imageLoader, "[TiledImage] options.imageLoader is required");
      $2.console.assert(options.source, "[TiledImage] options.source is required");
      $2.console.assert(
        !options.clip || options.clip instanceof $2.Rect,
        "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"
      );
      $2.EventSource.call(this);
      this._tileCache = options.tileCache;
      delete options.tileCache;
      this._drawer = options.drawer;
      delete options.drawer;
      this._imageLoader = options.imageLoader;
      delete options.imageLoader;
      if (options.clip instanceof $2.Rect) {
        this._clip = options.clip.clone();
      }
      delete options.clip;
      var x2 = options.x || 0;
      delete options.x;
      var y = options.y || 0;
      delete options.y;
      this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
      this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
      var scale = 1;
      if (options.width) {
        scale = options.width;
        delete options.width;
        if (options.height) {
          $2.console.error("specifying both width and height to a tiledImage is not supported");
          delete options.height;
        }
      } else if (options.height) {
        scale = options.height / this.normHeight;
        delete options.height;
      }
      var fitBounds = options.fitBounds;
      delete options.fitBounds;
      var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon2.Placement.CENTER;
      delete options.fitBoundsPlacement;
      var degrees = options.degrees || 0;
      delete options.degrees;
      var ajaxHeaders = options.ajaxHeaders;
      delete options.ajaxHeaders;
      $2.extend(true, this, {
        //internal state properties
        viewer: null,
        tilesMatrix: {},
        // A '3d' dictionary [level][x][y] --> Tile.
        coverage: {},
        // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
        loadingCoverage: {},
        // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
        lastDrawn: [],
        // An unordered list of Tiles drawn last frame.
        lastResetTime: 0,
        // Last time for which the tiledImage was reset.
        _midDraw: false,
        // Is the tiledImage currently updating the viewport?
        _needsDraw: true,
        // Does the tiledImage need to update the viewport again?
        _hasOpaqueTile: false,
        // Do we have even one fully opaque tile?
        _tilesLoading: 0,
        // The number of pending tile requests.
        //configurable settings
        springStiffness: $2.DEFAULT_SETTINGS.springStiffness,
        animationTime: $2.DEFAULT_SETTINGS.animationTime,
        minZoomImageRatio: $2.DEFAULT_SETTINGS.minZoomImageRatio,
        wrapHorizontal: $2.DEFAULT_SETTINGS.wrapHorizontal,
        wrapVertical: $2.DEFAULT_SETTINGS.wrapVertical,
        immediateRender: $2.DEFAULT_SETTINGS.immediateRender,
        blendTime: $2.DEFAULT_SETTINGS.blendTime,
        alwaysBlend: $2.DEFAULT_SETTINGS.alwaysBlend,
        minPixelRatio: $2.DEFAULT_SETTINGS.minPixelRatio,
        smoothTileEdgesMinZoom: $2.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
        iOSDevice: $2.DEFAULT_SETTINGS.iOSDevice,
        debugMode: $2.DEFAULT_SETTINGS.debugMode,
        crossOriginPolicy: $2.DEFAULT_SETTINGS.crossOriginPolicy,
        ajaxWithCredentials: $2.DEFAULT_SETTINGS.ajaxWithCredentials,
        placeholderFillStyle: $2.DEFAULT_SETTINGS.placeholderFillStyle,
        opacity: $2.DEFAULT_SETTINGS.opacity,
        preload: $2.DEFAULT_SETTINGS.preload,
        compositeOperation: $2.DEFAULT_SETTINGS.compositeOperation,
        subPixelRoundingForTransparency: $2.DEFAULT_SETTINGS.subPixelRoundingForTransparency
      }, options);
      this._preload = this.preload;
      delete this.preload;
      this._fullyLoaded = false;
      this._xSpring = new $2.Spring({
        initial: x2,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._ySpring = new $2.Spring({
        initial: y,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._scaleSpring = new $2.Spring({
        initial: scale,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._degreesSpring = new $2.Spring({
        initial: degrees,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      });
      this._updateForScale();
      if (fitBounds) {
        this.fitBounds(fitBounds, fitBoundsPlacement, true);
      }
      this._drawingHandler = function(args) {
        _this.viewer.raiseEvent("tile-drawing", $2.extend({
          tiledImage: _this
        }, args));
      };
      this._ownAjaxHeaders = {};
      this.setAjaxHeaders(ajaxHeaders, false);
    };
    $2.extend(
      $2.TiledImage.prototype,
      $2.EventSource.prototype,
      /** @lends OpenSeadragon.TiledImage.prototype */
      {
        /**
         * @returns {Boolean} Whether the TiledImage needs to be drawn.
         */
        needsDraw: function() {
          return this._needsDraw;
        },
        /**
         * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
         */
        getFullyLoaded: function() {
          return this._fullyLoaded;
        },
        // private
        _setFullyLoaded: function(flag) {
          if (flag === this._fullyLoaded) {
            return;
          }
          this._fullyLoaded = flag;
          this.raiseEvent("fully-loaded-change", {
            fullyLoaded: this._fullyLoaded
          });
        },
        /**
         * Clears all tiles and triggers an update on the next call to
         * {@link OpenSeadragon.TiledImage#update}.
         */
        reset: function() {
          this._tileCache.clearTilesFor(this);
          this.lastResetTime = $2.now();
          this._needsDraw = true;
        },
        /**
         * Updates the TiledImage's bounds, animating if needed.
         * @returns {Boolean} Whether the TiledImage animated.
         */
        update: function() {
          var xUpdated = this._xSpring.update();
          var yUpdated = this._ySpring.update();
          var scaleUpdated = this._scaleSpring.update();
          var degreesUpdated = this._degreesSpring.update();
          if (xUpdated || yUpdated || scaleUpdated || degreesUpdated) {
            this._updateForScale();
            this._needsDraw = true;
            return true;
          }
          return false;
        },
        /**
         * Draws the TiledImage to its Drawer.
         */
        draw: function() {
          if (this.opacity !== 0 || this._preload) {
            this._midDraw = true;
            this._updateViewport();
            this._midDraw = false;
          } else {
            this._needsDraw = false;
          }
        },
        /**
         * Destroy the TiledImage (unload current loaded tiles).
         */
        destroy: function() {
          this.reset();
          if (this.source.destroy) {
            this.source.destroy();
          }
        },
        /**
         * Get this TiledImage's bounds in viewport coordinates.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * false for target location.
         * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
         */
        getBounds: function(current) {
          return this.getBoundsNoRotate(current).rotate(this.getRotation(current), this._getRotationPoint(current));
        },
        /**
         * Get this TiledImage's bounds in viewport coordinates without taking
         * rotation into account.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * false for target location.
         * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
         */
        getBoundsNoRotate: function(current) {
          return current ? new $2.Rect(
            this._xSpring.current.value,
            this._ySpring.current.value,
            this._worldWidthCurrent,
            this._worldHeightCurrent
          ) : new $2.Rect(
            this._xSpring.target.value,
            this._ySpring.target.value,
            this._worldWidthTarget,
            this._worldHeightTarget
          );
        },
        // deprecated
        getWorldBounds: function() {
          $2.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead");
          return this.getBounds();
        },
        /**
         * Get the bounds of the displayed part of the tiled image.
         * @param {Boolean} [current=false] Pass true for the current location,
         * false for the target location.
         * @returns {$.Rect} The clipped bounds in viewport coordinates.
         */
        getClippedBounds: function(current) {
          var bounds = this.getBoundsNoRotate(current);
          if (this._clip) {
            var worldWidth = current ? this._worldWidthCurrent : this._worldWidthTarget;
            var ratio = worldWidth / this.source.dimensions.x;
            var clip = this._clip.times(ratio);
            bounds = new $2.Rect(
              bounds.x + clip.x,
              bounds.y + clip.y,
              clip.width,
              clip.height
            );
          }
          return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {OpenSeadragon.Rect} Where this tile fits (in normalized coordinates).
         */
        getTileBounds: function(level, x2, y) {
          var numTiles = this.source.getNumTiles(level);
          var xMod = (numTiles.x + x2 % numTiles.x) % numTiles.x;
          var yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
          var bounds = this.source.getTileBounds(level, xMod, yMod);
          if (this.getFlip()) {
            bounds.x = 1 - bounds.x - bounds.width;
          }
          bounds.x += (x2 - xMod) / numTiles.x;
          bounds.y += this._worldHeightCurrent / this._worldWidthCurrent * ((y - yMod) / numTiles.y);
          return bounds;
        },
        /**
         * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
         */
        getContentSize: function() {
          return new $2.Point(this.source.dimensions.x, this.source.dimensions.y);
        },
        /**
         * @returns {OpenSeadragon.Point} The TiledImage's content size, in window coordinates.
         */
        getSizeInWindowCoordinates: function() {
          var topLeft = this.imageToWindowCoordinates(new $2.Point(0, 0));
          var bottomRight = this.imageToWindowCoordinates(this.getContentSize());
          return new $2.Point(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
        },
        // private
        _viewportToImageDelta: function(viewerX, viewerY, current) {
          var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
          return new $2.Point(
            viewerX * (this.source.dimensions.x / scale),
            viewerY * (this.source.dimensions.y * this.contentAspectX / scale)
          );
        },
        /**
         * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
         * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
         * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
         * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Point} A point representing the coordinates in the image.
         */
        viewportToImageCoordinates: function(viewerX, viewerY, current) {
          var point;
          if (viewerX instanceof $2.Point) {
            current = viewerY;
            point = viewerX;
          } else {
            point = new $2.Point(viewerX, viewerY);
          }
          point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
          return current ? this._viewportToImageDelta(
            point.x - this._xSpring.current.value,
            point.y - this._ySpring.current.value
          ) : this._viewportToImageDelta(
            point.x - this._xSpring.target.value,
            point.y - this._ySpring.target.value
          );
        },
        // private
        _imageToViewportDelta: function(imageX, imageY, current) {
          var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
          return new $2.Point(
            imageX / this.source.dimensions.x * scale,
            imageY / this.source.dimensions.y / this.contentAspectX * scale
          );
        },
        /**
         * Translates from image coordinate system to OpenSeadragon viewer coordinate system
         * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
         * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
         * @param {Number} [imageY] - The Y coordinate in image coordinate system.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Point} A point representing the coordinates in the viewport.
         */
        imageToViewportCoordinates: function(imageX, imageY, current) {
          if (imageX instanceof $2.Point) {
            current = imageY;
            imageY = imageX.y;
            imageX = imageX.x;
          }
          var point = this._imageToViewportDelta(imageX, imageY);
          if (current) {
            point.x += this._xSpring.current.value;
            point.y += this._ySpring.current.value;
          } else {
            point.x += this._xSpring.target.value;
            point.y += this._ySpring.target.value;
          }
          return point.rotate(this.getRotation(current), this._getRotationPoint(current));
        },
        /**
         * Translates from a rectangle which describes a portion of the image in
         * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
         * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
         * @param {Number} [imageY] - The top coordinate in image coordinate system.
         * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
         * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
         */
        imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
          var rect = imageX;
          if (rect instanceof $2.Rect) {
            current = imageY;
          } else {
            rect = new $2.Rect(imageX, imageY, pixelWidth, pixelHeight);
          }
          var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
          var coordB = this._imageToViewportDelta(rect.width, rect.height, current);
          return new $2.Rect(
            coordA.x,
            coordA.y,
            coordB.x,
            coordB.y,
            rect.degrees + this.getRotation(current)
          );
        },
        /**
         * Translates from a rectangle which describes a portion of
         * the viewport in point coordinates to image rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
         * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
         * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
         * @param {Number} [pointWidth] - The width in viewport coordinate system.
         * @param {Number} [pointHeight] - The height in viewport coordinate system.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the image.
         */
        viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight, current) {
          var rect = viewerX;
          if (viewerX instanceof $2.Rect) {
            current = viewerY;
          } else {
            rect = new $2.Rect(viewerX, viewerY, pointWidth, pointHeight);
          }
          var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
          var coordB = this._viewportToImageDelta(rect.width, rect.height, current);
          return new $2.Rect(
            coordA.x,
            coordA.y,
            coordB.x,
            coordB.y,
            rect.degrees - this.getRotation(current)
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to image
         * coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToImageCoordinates: function(pixel) {
          var point = this.viewport.pointFromPixel(pixel, true);
          return this.viewportToImageCoordinates(point);
        },
        /**
         * Convert pixel coordinates relative to the image to
         * viewer element coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToViewerElementCoordinates: function(pixel) {
          var point = this.imageToViewportCoordinates(pixel);
          return this.viewport.pixelFromPoint(point, true);
        },
        /**
         * Convert pixel coordinates relative to the window to image coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToImageCoordinates: function(pixel) {
          var viewerCoordinates = pixel.minus(
            OpenSeadragon2.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToImageCoordinates(viewerCoordinates);
        },
        /**
         * Convert image coordinates to pixel coordinates relative to the window.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToWindowCoordinates: function(pixel) {
          var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
          return viewerCoordinates.plus(
            OpenSeadragon2.getElementPosition(this.viewer.element)
          );
        },
        // private
        // Convert rectangle in viewport coordinates to this tiled image point
        // coordinates (x in [0, 1] and y in [0, aspectRatio])
        _viewportToTiledImageRectangle: function(rect) {
          var scale = this._scaleSpring.current.value;
          rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
          return new $2.Rect(
            (rect.x - this._xSpring.current.value) / scale,
            (rect.y - this._ySpring.current.value) / scale,
            rect.width / scale,
            rect.height / scale,
            rect.degrees
          );
        },
        /**
         * Convert a viewport zoom to an image zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * @function
         * @param {Number} viewportZoom The viewport zoom
         * @returns {Number} imageZoom The image zoom
         */
        viewportToImageZoom: function(viewportZoom) {
          var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
          return ratio * viewportZoom;
        },
        /**
         * Convert an image zoom to a viewport zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} imageZoom The image zoom
         * @returns {Number} viewportZoom The viewport zoom
         */
        imageToViewportZoom: function(imageZoom) {
          var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
          return imageZoom / ratio;
        },
        /**
         * Sets the TiledImage's position in the world.
         * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
         * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setPosition: function(position, immediately) {
          var sameTarget = this._xSpring.target.value === position.x && this._ySpring.target.value === position.y;
          if (immediately) {
            if (sameTarget && this._xSpring.current.value === position.x && this._ySpring.current.value === position.y) {
              return;
            }
            this._xSpring.resetTo(position.x);
            this._ySpring.resetTo(position.y);
            this._needsDraw = true;
          } else {
            if (sameTarget) {
              return;
            }
            this._xSpring.springTo(position.x);
            this._ySpring.springTo(position.y);
            this._needsDraw = true;
          }
          if (!sameTarget) {
            this._raiseBoundsChange();
          }
        },
        /**
         * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
         * @param {Number} width - The new width, in viewport coordinates.
         * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setWidth: function(width, immediately) {
          this._setScale(width, immediately);
        },
        /**
         * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
         * @param {Number} height - The new height, in viewport coordinates.
         * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setHeight: function(height, immediately) {
          this._setScale(height / this.normHeight, immediately);
        },
        /**
         * Sets an array of polygons to crop the TiledImage during draw tiles.
         * The render function will use the default non-zero winding rule.
         * @param {OpenSeadragon.Point[][]} polygons - represented in an array of point object in image coordinates.
         * Example format: [
         *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
         *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
         *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
         * ]
         */
        setCroppingPolygons: function(polygons) {
          var isXYObject = function(obj) {
            return obj instanceof $2.Point || typeof obj.x === "number" && typeof obj.y === "number";
          };
          var objectToSimpleXYObject = function(objs) {
            return objs.map(function(obj) {
              try {
                if (isXYObject(obj)) {
                  return { x: obj.x, y: obj.y };
                } else {
                  throw new Error();
                }
              } catch (e) {
                throw new Error("A Provided cropping polygon point is not supported");
              }
            });
          };
          try {
            if (!$2.isArray(polygons)) {
              throw new Error("Provided cropping polygon is not an array");
            }
            this._croppingPolygons = polygons.map(function(polygon) {
              return objectToSimpleXYObject(polygon);
            });
          } catch (e) {
            $2.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported");
            $2.console.error(e);
            this._croppingPolygons = null;
          }
        },
        /**
         * Resets the cropping polygons, thus next render will remove all cropping
         * polygon effects.
         */
        resetCroppingPolygons: function() {
          this._croppingPolygons = null;
        },
        /**
         * Positions and scales the TiledImage to fit in the specified bounds.
         * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
         * twice
         * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
         * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
         * How to anchor the image in the bounds.
         * @param {Boolean} [immediately=false] Whether to animate to the new size
         * or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        fitBounds: function(bounds, anchor, immediately) {
          anchor = anchor || $2.Placement.CENTER;
          var anchorProperties = $2.Placement.properties[anchor];
          var aspectRatio = this.contentAspectX;
          var xOffset = 0;
          var yOffset = 0;
          var displayedWidthRatio = 1;
          var displayedHeightRatio = 1;
          if (this._clip) {
            aspectRatio = this._clip.getAspectRatio();
            displayedWidthRatio = this._clip.width / this.source.dimensions.x;
            displayedHeightRatio = this._clip.height / this.source.dimensions.y;
            if (bounds.getAspectRatio() > aspectRatio) {
              xOffset = this._clip.x / this._clip.height * bounds.height;
              yOffset = this._clip.y / this._clip.height * bounds.height;
            } else {
              xOffset = this._clip.x / this._clip.width * bounds.width;
              yOffset = this._clip.y / this._clip.width * bounds.width;
            }
          }
          if (bounds.getAspectRatio() > aspectRatio) {
            var height = bounds.height / displayedHeightRatio;
            var marginLeft = 0;
            if (anchorProperties.isHorizontallyCentered) {
              marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
            } else if (anchorProperties.isRight) {
              marginLeft = bounds.width - bounds.height * aspectRatio;
            }
            this.setPosition(
              new $2.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),
              immediately
            );
            this.setHeight(height, immediately);
          } else {
            var width = bounds.width / displayedWidthRatio;
            var marginTop = 0;
            if (anchorProperties.isVerticallyCentered) {
              marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
            } else if (anchorProperties.isBottom) {
              marginTop = bounds.height - bounds.width / aspectRatio;
            }
            this.setPosition(
              new $2.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),
              immediately
            );
            this.setWidth(width, immediately);
          }
        },
        /**
         * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
         * in image pixels, or null if none.
         */
        getClip: function() {
          if (this._clip) {
            return this._clip.clone();
          }
          return null;
        },
        /**
         * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
         * (portions of the image outside of this area will not be visible). Only works on
         * browsers that support the HTML5 canvas.
         * @fires OpenSeadragon.TiledImage.event:clip-change
         */
        setClip: function(newClip) {
          $2.console.assert(
            !newClip || newClip instanceof $2.Rect,
            "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"
          );
          if (newClip instanceof $2.Rect) {
            this._clip = newClip.clone();
          } else {
            this._clip = null;
          }
          this._needsDraw = true;
          this.raiseEvent("clip-change");
        },
        /**
         * @returns {Boolean} Whether the TiledImage should be flipped before rendering.
         */
        getFlip: function() {
          return !!this.flipped;
        },
        /**
         * @param {Boolean} flip Whether the TiledImage should be flipped before rendering.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setFlip: function(flip) {
          this.flipped = !!flip;
          this._needsDraw = true;
          this._raiseBoundsChange();
        },
        /**
         * @returns {Number} The TiledImage's current opacity.
         */
        getOpacity: function() {
          return this.opacity;
        },
        /**
         * @param {Number} opacity Opacity the tiled image should be drawn at.
         * @fires OpenSeadragon.TiledImage.event:opacity-change
         */
        setOpacity: function(opacity) {
          if (opacity === this.opacity) {
            return;
          }
          this.opacity = opacity;
          this._needsDraw = true;
          this.raiseEvent("opacity-change", {
            opacity: this.opacity
          });
        },
        /**
         * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
         */
        getPreload: function() {
          return this._preload;
        },
        /**
         * Set true to load even when hidden. Set false to block loading when hidden.
         */
        setPreload: function(preload2) {
          this._preload = !!preload2;
          this._needsDraw = true;
        },
        /**
         * Get the rotation of this tiled image in degrees.
         * @param {Boolean} [current=false] True for current rotation, false for target.
         * @returns {Number} the rotation of this tiled image in degrees.
         */
        getRotation: function(current) {
          return current ? this._degreesSpring.current.value : this._degreesSpring.target.value;
        },
        /**
         * Set the current rotation of this tiled image in degrees.
         * @param {Number} degrees the rotation in degrees.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setRotation: function(degrees, immediately) {
          if (this._degreesSpring.target.value === degrees && this._degreesSpring.isAtTargetValue()) {
            return;
          }
          if (immediately) {
            this._degreesSpring.resetTo(degrees);
          } else {
            this._degreesSpring.springTo(degrees);
          }
          this._needsDraw = true;
          this._raiseBoundsChange();
        },
        /**
         * Get the point around which this tiled image is rotated
         * @private
         * @param {Boolean} current True for current rotation point, false for target.
         * @returns {OpenSeadragon.Point}
         */
        _getRotationPoint: function(current) {
          return this.getBoundsNoRotate(current).getCenter();
        },
        /**
         * @returns {String} The TiledImage's current compositeOperation.
         */
        getCompositeOperation: function() {
          return this.compositeOperation;
        },
        /**
         * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
         * @fires OpenSeadragon.TiledImage.event:composite-operation-change
         */
        setCompositeOperation: function(compositeOperation) {
          if (compositeOperation === this.compositeOperation) {
            return;
          }
          this.compositeOperation = compositeOperation;
          this._needsDraw = true;
          this.raiseEvent("composite-operation-change", {
            compositeOperation: this.compositeOperation
          });
        },
        /**
         * Update headers to include when making AJAX requests.
         *
         * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
         * the updated headers are propagated to all tiles and queued image loader jobs.
         *
         * Note that the rules for merging headers still apply, i.e. headers returned by
         * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
         * the headers here in the tiled image (`TiledImage.ajaxHeaders`).
         *
         * @function
         * @param {Object} ajaxHeaders Updated AJAX headers, which will be merged over any headers specified in {@link OpenSeadragon.Options}.
         * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
         */
        setAjaxHeaders: function(ajaxHeaders, propagate) {
          if (ajaxHeaders === null) {
            ajaxHeaders = {};
          }
          if (!$2.isPlainObject(ajaxHeaders)) {
            console.error("[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
            return;
          }
          this._ownAjaxHeaders = ajaxHeaders;
          this._updateAjaxHeaders(propagate);
        },
        /**
         * Update headers to include when making AJAX requests.
         *
         * This function has the same effect as calling {@link OpenSeadragon.TiledImage#setAjaxHeaders},
         * except that the headers for this tiled image do not change. This is especially useful
         * for propagating updated headers from {@link OpenSeadragon.TileSource#getTileAjaxHeaders}
         * to existing tiles.
         *
         * @private
         * @function
         * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
         */
        _updateAjaxHeaders: function(propagate) {
          if (propagate === void 0) {
            propagate = true;
          }
          if ($2.isPlainObject(this.viewer.ajaxHeaders)) {
            this.ajaxHeaders = $2.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders);
          } else {
            this.ajaxHeaders = this._ownAjaxHeaders;
          }
          if (propagate) {
            var numTiles, xMod, yMod, tile;
            for (var level in this.tilesMatrix) {
              numTiles = this.source.getNumTiles(level);
              for (var x2 in this.tilesMatrix[level]) {
                xMod = (numTiles.x + x2 % numTiles.x) % numTiles.x;
                for (var y in this.tilesMatrix[level][x2]) {
                  yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
                  tile = this.tilesMatrix[level][x2][y];
                  tile.loadWithAjax = this.loadTilesWithAjax;
                  if (tile.loadWithAjax) {
                    var tileAjaxHeaders = this.source.getTileAjaxHeaders(level, xMod, yMod);
                    tile.ajaxHeaders = $2.extend({}, this.ajaxHeaders, tileAjaxHeaders);
                  } else {
                    tile.ajaxHeaders = null;
                  }
                }
              }
            }
            for (var i = 0; i < this._imageLoader.jobQueue.length; i++) {
              var job = this._imageLoader.jobQueue[i];
              job.loadWithAjax = job.tile.loadWithAjax;
              job.ajaxHeaders = job.tile.loadWithAjax ? job.tile.ajaxHeaders : null;
            }
          }
        },
        // private
        _setScale: function(scale, immediately) {
          var sameTarget = this._scaleSpring.target.value === scale;
          if (immediately) {
            if (sameTarget && this._scaleSpring.current.value === scale) {
              return;
            }
            this._scaleSpring.resetTo(scale);
            this._updateForScale();
            this._needsDraw = true;
          } else {
            if (sameTarget) {
              return;
            }
            this._scaleSpring.springTo(scale);
            this._updateForScale();
            this._needsDraw = true;
          }
          if (!sameTarget) {
            this._raiseBoundsChange();
          }
        },
        // private
        _updateForScale: function() {
          this._worldWidthTarget = this._scaleSpring.target.value;
          this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
          this._worldWidthCurrent = this._scaleSpring.current.value;
          this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
        },
        // private
        _raiseBoundsChange: function() {
          this.raiseEvent("bounds-change");
        },
        // private
        _isBottomItem: function() {
          return this.viewer.world.getItemAt(0) === this;
        },
        // private
        _getLevelsInterval: function() {
          var lowestLevel = Math.max(
            this.source.minLevel,
            Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
          );
          var currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
            this.source.getPixelRatio(0),
            true
          ).x * this._scaleSpring.current.value;
          var highestLevel = Math.min(
            Math.abs(this.source.maxLevel),
            Math.abs(Math.floor(
              Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2)
            ))
          );
          highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
          lowestLevel = Math.min(lowestLevel, highestLevel);
          return {
            lowestLevel,
            highestLevel
          };
        },
        /**
         * @private
         * @inner
         * Pretty much every other line in this needs to be documented so it's clear
         * how each piece of this routine contributes to the drawing process.  That's
         * why there are so many TODO's inside this function.
         */
        _updateViewport: function() {
          this._needsDraw = false;
          this._tilesLoading = 0;
          this.loadingCoverage = {};
          while (this.lastDrawn.length > 0) {
            var tile = this.lastDrawn.pop();
            tile.beingDrawn = false;
          }
          var viewport = this.viewport;
          var drawArea = this._viewportToTiledImageRectangle(
            viewport.getBoundsWithMargins(true)
          );
          if (!this.wrapHorizontal && !this.wrapVertical) {
            var tiledImageBounds = this._viewportToTiledImageRectangle(
              this.getClippedBounds(true)
            );
            drawArea = drawArea.intersection(tiledImageBounds);
            if (drawArea === null) {
              return;
            }
          }
          var levelsInterval = this._getLevelsInterval();
          var lowestLevel = levelsInterval.lowestLevel;
          var highestLevel = levelsInterval.highestLevel;
          var bestTile = null;
          var haveDrawn = false;
          var currentTime = $2.now();
          for (var level = highestLevel; level >= lowestLevel; level--) {
            var drawLevel = false;
            var currentRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(level),
              true
            ).x * this._scaleSpring.current.value;
            if (level === lowestLevel || !haveDrawn && currentRenderPixelRatio >= this.minPixelRatio) {
              drawLevel = true;
              haveDrawn = true;
            } else if (!haveDrawn) {
              continue;
            }
            var targetRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(level),
              false
            ).x * this._scaleSpring.current.value;
            var targetZeroRatio = viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(
                Math.max(
                  this.source.getClosestLevel(),
                  0
                )
              ),
              false
            ).x * this._scaleSpring.current.value;
            var optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
            var levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
            var levelVisibility = optimalRatio / Math.abs(
              optimalRatio - targetRenderPixelRatio
            );
            bestTile = this._updateLevel(
              haveDrawn,
              drawLevel,
              level,
              levelOpacity,
              levelVisibility,
              drawArea,
              currentTime,
              bestTile
            );
            if (this._providesCoverage(this.coverage, level)) {
              break;
            }
          }
          this._drawTiles(this.lastDrawn);
          if (bestTile && !bestTile.context2D) {
            this._loadTile(bestTile, currentTime);
            this._needsDraw = true;
            this._setFullyLoaded(false);
          } else {
            this._setFullyLoaded(this._tilesLoading === 0);
          }
        },
        // private
        _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
          var leftX;
          var rightX;
          if (this.wrapHorizontal) {
            leftX = $2.positiveModulo(topLeftBound.x, 1);
            rightX = $2.positiveModulo(bottomRightBound.x, 1);
          } else {
            leftX = Math.max(0, topLeftBound.x);
            rightX = Math.min(1, bottomRightBound.x);
          }
          var topY;
          var bottomY;
          var aspectRatio = 1 / this.source.aspectRatio;
          if (this.wrapVertical) {
            topY = $2.positiveModulo(topLeftBound.y, aspectRatio);
            bottomY = $2.positiveModulo(bottomRightBound.y, aspectRatio);
          } else {
            topY = Math.max(0, topLeftBound.y);
            bottomY = Math.min(aspectRatio, bottomRightBound.y);
          }
          var topLeftTile = this.source.getTileAtPoint(level, new $2.Point(leftX, topY));
          var bottomRightTile = this.source.getTileAtPoint(level, new $2.Point(rightX, bottomY));
          var numTiles = this.source.getNumTiles(level);
          if (this.wrapHorizontal) {
            topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
            bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
          }
          if (this.wrapVertical) {
            topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
            bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
          }
          return {
            topLeft: topLeftTile,
            bottomRight: bottomRightTile
          };
        },
        /**
         * Updates all tiles at a given resolution level.
         * @private
         * @param {Boolean} haveDrawn
         * @param {Boolean} drawLevel
         * @param {Number} level
         * @param {Number} levelOpacity
         * @param {Number} levelVisibility
         * @param {OpenSeadragon.Rect} drawArea
         * @param {Number} currentTime
         * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
         */
        _updateLevel: function(haveDrawn, drawLevel, level, levelOpacity, levelVisibility, drawArea, currentTime, best) {
          var topLeftBound = drawArea.getBoundingBox().getTopLeft();
          var bottomRightBound = drawArea.getBoundingBox().getBottomRight();
          if (this.viewer) {
            this.viewer.raiseEvent("update-level", {
              tiledImage: this,
              havedrawn: haveDrawn,
              level,
              opacity: levelOpacity,
              visibility: levelVisibility,
              drawArea,
              topleft: topLeftBound,
              bottomright: bottomRightBound,
              currenttime: currentTime,
              best
            });
          }
          this._resetCoverage(this.coverage, level);
          this._resetCoverage(this.loadingCoverage, level);
          var cornerTiles = this._getCornerTiles(level, topLeftBound, bottomRightBound);
          var topLeftTile = cornerTiles.topLeft;
          var bottomRightTile = cornerTiles.bottomRight;
          var numberOfTiles = this.source.getNumTiles(level);
          var viewportCenter = this.viewport.pixelFromPoint(this.viewport.getCenter());
          if (this.getFlip()) {
            bottomRightTile.x += 1;
            if (!this.wrapHorizontal) {
              bottomRightTile.x = Math.min(bottomRightTile.x, numberOfTiles.x - 1);
            }
          }
          for (var x2 = topLeftTile.x; x2 <= bottomRightTile.x; x2++) {
            for (var y = topLeftTile.y; y <= bottomRightTile.y; y++) {
              var flippedX;
              if (this.getFlip()) {
                var xMod = (numberOfTiles.x + x2 % numberOfTiles.x) % numberOfTiles.x;
                flippedX = x2 + numberOfTiles.x - xMod - xMod - 1;
              } else {
                flippedX = x2;
              }
              if (drawArea.intersection(this.getTileBounds(level, flippedX, y)) === null) {
                continue;
              }
              best = this._updateTile(
                drawLevel,
                haveDrawn,
                flippedX,
                y,
                level,
                levelOpacity,
                levelVisibility,
                viewportCenter,
                numberOfTiles,
                currentTime,
                best
              );
            }
          }
          return best;
        },
        /**
         * @private
         * @inner
         * Update a single tile at a particular resolution level.
         * @param {Boolean} haveDrawn
         * @param {Boolean} drawLevel
         * @param {Number} x
         * @param {Number} y
         * @param {Number} level
         * @param {Number} levelOpacity
         * @param {Number} levelVisibility
         * @param {OpenSeadragon.Point} viewportCenter
         * @param {Number} numberOfTiles
         * @param {Number} currentTime
         * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
         */
        _updateTile: function(haveDrawn, drawLevel, x2, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best) {
          var tile = this._getTile(
            x2,
            y,
            level,
            currentTime,
            numberOfTiles,
            this._worldWidthCurrent,
            this._worldHeightCurrent
          ), drawTile = drawLevel;
          if (this.viewer) {
            this.viewer.raiseEvent("update-tile", {
              tiledImage: this,
              tile
            });
          }
          this._setCoverage(this.coverage, level, x2, y, false);
          var loadingCoverage = tile.loaded || tile.loading || this._isCovered(this.loadingCoverage, level, x2, y);
          this._setCoverage(this.loadingCoverage, level, x2, y, loadingCoverage);
          if (!tile.exists) {
            return best;
          }
          if (haveDrawn && !drawTile) {
            if (this._isCovered(this.coverage, level, x2, y)) {
              this._setCoverage(this.coverage, level, x2, y, true);
            } else {
              drawTile = true;
            }
          }
          if (!drawTile) {
            return best;
          }
          this._positionTile(
            tile,
            this.source.tileOverlap,
            this.viewport,
            viewportCenter,
            levelVisibility
          );
          if (!tile.loaded) {
            if (tile.context2D) {
              this._setTileLoaded(tile);
            } else {
              var imageRecord = this._tileCache.getImageRecord(tile.cacheKey);
              if (imageRecord) {
                this._setTileLoaded(tile, imageRecord.getData());
              }
            }
          }
          if (tile.loaded) {
            var needsDraw = this._blendTile(
              tile,
              x2,
              y,
              level,
              levelOpacity,
              currentTime
            );
            if (needsDraw) {
              this._needsDraw = true;
            }
          } else if (tile.loading) {
            this._tilesLoading++;
          } else if (!loadingCoverage) {
            best = this._compareTiles(best, tile);
          }
          return best;
        },
        /**
         * @private
         * @inner
         * Obtains a tile at the given location.
         * @param {Number} x
         * @param {Number} y
         * @param {Number} level
         * @param {Number} time
         * @param {Number} numTiles
         * @param {Number} worldWidth
         * @param {Number} worldHeight
         * @returns {OpenSeadragon.Tile}
         */
        _getTile: function(x2, y, level, time, numTiles, worldWidth, worldHeight) {
          var xMod, yMod, bounds, sourceBounds, exists, urlOrGetter, post, ajaxHeaders, context2D, tile, tilesMatrix = this.tilesMatrix, tileSource = this.source;
          if (!tilesMatrix[level]) {
            tilesMatrix[level] = {};
          }
          if (!tilesMatrix[level][x2]) {
            tilesMatrix[level][x2] = {};
          }
          if (!tilesMatrix[level][x2][y] || !tilesMatrix[level][x2][y].flipped !== !this.flipped) {
            xMod = (numTiles.x + x2 % numTiles.x) % numTiles.x;
            yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
            bounds = this.getTileBounds(level, x2, y);
            sourceBounds = tileSource.getTileBounds(level, xMod, yMod, true);
            exists = tileSource.tileExists(level, xMod, yMod);
            urlOrGetter = tileSource.getTileUrl(level, xMod, yMod);
            post = tileSource.getTilePostData(level, xMod, yMod);
            if (this.loadTilesWithAjax) {
              ajaxHeaders = tileSource.getTileAjaxHeaders(level, xMod, yMod);
              if ($2.isPlainObject(this.ajaxHeaders)) {
                ajaxHeaders = $2.extend({}, this.ajaxHeaders, ajaxHeaders);
              }
            } else {
              ajaxHeaders = null;
            }
            context2D = tileSource.getContext2D ? tileSource.getContext2D(level, xMod, yMod) : void 0;
            tile = new $2.Tile(
              level,
              x2,
              y,
              bounds,
              exists,
              urlOrGetter,
              context2D,
              this.loadTilesWithAjax,
              ajaxHeaders,
              sourceBounds,
              post,
              tileSource.getTileHashKey(level, xMod, yMod, urlOrGetter, ajaxHeaders, post)
            );
            if (this.getFlip()) {
              if (xMod === 0) {
                tile.isRightMost = true;
              }
            } else {
              if (xMod === numTiles.x - 1) {
                tile.isRightMost = true;
              }
            }
            if (yMod === numTiles.y - 1) {
              tile.isBottomMost = true;
            }
            tile.flipped = this.flipped;
            tilesMatrix[level][x2][y] = tile;
          }
          tile = tilesMatrix[level][x2][y];
          tile.lastTouchTime = time;
          return tile;
        },
        /**
         * @private
         * @inner
         * Dispatch a job to the ImageLoader to load the Image for a Tile.
         * @param {OpenSeadragon.Tile} tile
         * @param {Number} time
         */
        _loadTile: function(tile, time) {
          var _this = this;
          tile.loading = true;
          this._imageLoader.addJob({
            src: tile.getUrl(),
            tile,
            source: this.source,
            postData: tile.postData,
            loadWithAjax: tile.loadWithAjax,
            ajaxHeaders: tile.ajaxHeaders,
            crossOriginPolicy: this.crossOriginPolicy,
            ajaxWithCredentials: this.ajaxWithCredentials,
            callback: function(data, errorMsg, tileRequest) {
              _this._onTileLoad(tile, time, data, errorMsg, tileRequest);
            },
            abort: function() {
              tile.loading = false;
            }
          });
        },
        /**
         * @private
         * @inner
         * Callback fired when a Tile's Image finished downloading.
         * @param {OpenSeadragon.Tile} tile
         * @param {Number} time
         * @param {*} data image data
         * @param {String} errorMsg
         * @param {XMLHttpRequest} tileRequest
         */
        _onTileLoad: function(tile, time, data, errorMsg, tileRequest) {
          if (!data) {
            $2.console.error("Tile %s failed to load: %s - error: %s", tile, tile.getUrl(), errorMsg);
            this.viewer.raiseEvent("tile-load-failed", {
              tile,
              tiledImage: this,
              time,
              message: errorMsg,
              tileRequest
            });
            tile.loading = false;
            tile.exists = false;
            return;
          } else {
            tile.exists = true;
          }
          if (time < this.lastResetTime) {
            $2.console.warn("Ignoring tile %s loaded before reset: %s", tile, tile.getUrl());
            tile.loading = false;
            return;
          }
          var _this = this, finish = function() {
            var ccc = _this.source;
            var cutoff = ccc.getClosestLevel();
            _this._setTileLoaded(tile, data, cutoff, tileRequest);
          };
          if (!this._midDraw) {
            finish();
          } else {
            window.setTimeout(finish, 1);
          }
        },
        /**
         * @private
         * @inner
         * @param {OpenSeadragon.Tile} tile
         * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
         * @param {Number|undefined} cutoff
         * @param {XMLHttpRequest|undefined} tileRequest
         */
        _setTileLoaded: function(tile, data, cutoff, tileRequest) {
          var increment = 0, eventFinished = false, _this = this;
          function getCompletionCallback() {
            if (eventFinished) {
              $2.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. Its return value should be called asynchronously.");
            }
            increment++;
            return completionCallback;
          }
          function completionCallback() {
            increment--;
            if (increment === 0) {
              tile.loading = false;
              tile.loaded = true;
              tile.hasTransparency = _this.source.hasTransparency(
                tile.context2D,
                tile.getUrl(),
                tile.ajaxHeaders,
                tile.postData
              );
              if (!tile.context2D) {
                _this._tileCache.cacheTile({
                  data,
                  tile,
                  cutoff,
                  tiledImage: _this
                });
              }
              _this._needsDraw = true;
            }
          }
          var fallbackCompletion = getCompletionCallback();
          this.viewer.raiseEvent("tile-loaded", {
            tile,
            tiledImage: this,
            tileRequest,
            get image() {
              $2.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead.");
              return data;
            },
            data,
            getCompletionCallback
          });
          eventFinished = true;
          fallbackCompletion();
        },
        /**
         * @private
         * @inner
         * @param {OpenSeadragon.Tile} tile
         * @param {Boolean} overlap
         * @param {OpenSeadragon.Viewport} viewport
         * @param {OpenSeadragon.Point} viewportCenter
         * @param {Number} levelVisibility
         */
        _positionTile: function(tile, overlap, viewport, viewportCenter, levelVisibility) {
          var boundsTL = tile.bounds.getTopLeft();
          boundsTL.x *= this._scaleSpring.current.value;
          boundsTL.y *= this._scaleSpring.current.value;
          boundsTL.x += this._xSpring.current.value;
          boundsTL.y += this._ySpring.current.value;
          var boundsSize = tile.bounds.getSize();
          boundsSize.x *= this._scaleSpring.current.value;
          boundsSize.y *= this._scaleSpring.current.value;
          var positionC = viewport.pixelFromPointNoRotate(boundsTL, true), positionT = viewport.pixelFromPointNoRotate(boundsTL, false), sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true), sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false), tileCenter = positionT.plus(sizeT.divide(2)), tileSquaredDistance = viewportCenter.squaredDistanceTo(tileCenter);
          if (!overlap) {
            sizeC = sizeC.plus(new $2.Point(1, 1));
          }
          if (tile.isRightMost && this.wrapHorizontal) {
            sizeC.x += 0.75;
          }
          if (tile.isBottomMost && this.wrapVertical) {
            sizeC.y += 0.75;
          }
          tile.position = positionC;
          tile.size = sizeC;
          tile.squaredDistance = tileSquaredDistance;
          tile.visibility = levelVisibility;
        },
        /**
         * @private
         * @inner
         * Updates the opacity of a tile according to the time it has been on screen
         * to perform a fade-in.
         * Updates coverage once a tile is fully opaque.
         * Returns whether the fade-in has completed.
         *
         * @param {OpenSeadragon.Tile} tile
         * @param {Number} x
         * @param {Number} y
         * @param {Number} level
         * @param {Number} levelOpacity
         * @param {Number} currentTime
         * @returns {Boolean}
         */
        _blendTile: function(tile, x2, y, level, levelOpacity, currentTime) {
          var blendTimeMillis = 1e3 * this.blendTime, deltaTime, opacity;
          if (!tile.blendStart) {
            tile.blendStart = currentTime;
          }
          deltaTime = currentTime - tile.blendStart;
          opacity = blendTimeMillis ? Math.min(1, deltaTime / blendTimeMillis) : 1;
          if (this.alwaysBlend) {
            opacity *= levelOpacity;
          }
          tile.opacity = opacity;
          this.lastDrawn.push(tile);
          if (opacity === 1) {
            this._setCoverage(this.coverage, level, x2, y, true);
            this._hasOpaqueTile = true;
          } else if (deltaTime < blendTimeMillis) {
            return true;
          }
          return false;
        },
        /**
         * @private
         * @inner
         * Determines whether the 'last best' tile for the area is better than the
         * tile in question.
         *
         * @param {OpenSeadragon.Tile} previousBest
         * @param {OpenSeadragon.Tile} tile
         * @returns {OpenSeadragon.Tile} The new best tile.
         */
        _compareTiles: function(previousBest, tile) {
          if (!previousBest) {
            return tile;
          }
          if (tile.visibility > previousBest.visibility) {
            return tile;
          } else if (tile.visibility === previousBest.visibility) {
            if (tile.squaredDistance < previousBest.squaredDistance) {
              return tile;
            }
          }
          return previousBest;
        },
        /**
         * @private
         * @inner
         * Draws a TiledImage.
         * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
         */
        _drawTiles: function(lastDrawn) {
          if (this.opacity === 0 || lastDrawn.length === 0 && !this.placeholderFillStyle) {
            return;
          }
          var tile = lastDrawn[0];
          var useSketch;
          if (tile) {
            useSketch = this.opacity < 1 || this.compositeOperation && this.compositeOperation !== "source-over" || !this._isBottomItem() && this.source.hasTransparency(tile.context2D, tile.getUrl(), tile.ajaxHeaders, tile.postData);
          }
          var sketchScale;
          var sketchTranslate;
          var zoom = this.viewport.getZoom(true);
          var imageZoom = this.viewportToImageZoom(zoom);
          if (lastDrawn.length > 1 && imageZoom > this.smoothTileEdgesMinZoom && !this.iOSDevice && this.getRotation(true) % 360 === 0 && // TODO: support tile edge smoothing with tiled image rotation.
          $2.supportsCanvas && this.viewer.useCanvas) {
            useSketch = true;
            sketchScale = tile.getScaleForEdgeSmoothing();
            sketchTranslate = tile.getTranslationForEdgeSmoothing(
              sketchScale,
              this._drawer.getCanvasSize(false),
              this._drawer.getCanvasSize(true)
            );
          }
          var bounds;
          if (useSketch) {
            if (!sketchScale) {
              bounds = this.viewport.viewportToViewerElementRectangle(
                this.getClippedBounds(true)
              ).getIntegerBoundingBox();
              if (this._drawer.viewer.viewport.getFlip()) {
                if (this.viewport.getRotation(true) % 360 !== 0 || this.getRotation(true) % 360 !== 0) {
                  bounds.x = this._drawer.viewer.container.clientWidth - (bounds.x + bounds.width);
                }
              }
              bounds = bounds.times($2.pixelDensityRatio);
            }
            this._drawer._clear(true, bounds);
          }
          if (!sketchScale) {
            if (this.viewport.getRotation(true) % 360 !== 0) {
              this._drawer._offsetForRotation({
                degrees: this.viewport.getRotation(true),
                useSketch
              });
            }
            if (this.getRotation(true) % 360 !== 0) {
              this._drawer._offsetForRotation({
                degrees: this.getRotation(true),
                point: this.viewport.pixelFromPointNoRotate(
                  this._getRotationPoint(true),
                  true
                ),
                useSketch
              });
            }
            if (this.viewport.getRotation(true) % 360 === 0 && this.getRotation(true) % 360 === 0) {
              if (this._drawer.viewer.viewport.getFlip()) {
                this._drawer._flip();
              }
            }
          }
          var usedClip = false;
          if (this._clip) {
            this._drawer.saveContext(useSketch);
            var box = this.imageToViewportRectangle(this._clip, true);
            box = box.rotate(-this.getRotation(true), this._getRotationPoint(true));
            var clipRect = this._drawer.viewportToDrawerRectangle(box);
            if (sketchScale) {
              clipRect = clipRect.times(sketchScale);
            }
            if (sketchTranslate) {
              clipRect = clipRect.translate(sketchTranslate);
            }
            this._drawer.setClip(clipRect, useSketch);
            usedClip = true;
          }
          if (this._croppingPolygons) {
            var self2 = this;
            this._drawer.saveContext(useSketch);
            try {
              var polygons = this._croppingPolygons.map(function(polygon) {
                return polygon.map(function(coord) {
                  var point = self2.imageToViewportCoordinates(coord.x, coord.y, true).rotate(-self2.getRotation(true), self2._getRotationPoint(true));
                  var clipPoint = self2._drawer.viewportCoordToDrawerCoord(point);
                  if (sketchScale) {
                    clipPoint = clipPoint.times(sketchScale);
                  }
                  if (sketchTranslate) {
                    clipPoint = clipPoint.plus(sketchTranslate);
                  }
                  return clipPoint;
                });
              });
              this._drawer.clipWithPolygons(polygons, useSketch);
            } catch (e) {
              $2.console.error(e);
            }
            usedClip = true;
          }
          if (this.placeholderFillStyle && this._hasOpaqueTile === false) {
            var placeholderRect = this._drawer.viewportToDrawerRectangle(this.getBounds(true));
            if (sketchScale) {
              placeholderRect = placeholderRect.times(sketchScale);
            }
            if (sketchTranslate) {
              placeholderRect = placeholderRect.translate(sketchTranslate);
            }
            var fillStyle = null;
            if (typeof this.placeholderFillStyle === "function") {
              fillStyle = this.placeholderFillStyle(this, this._drawer.context);
            } else {
              fillStyle = this.placeholderFillStyle;
            }
            this._drawer.drawRectangle(placeholderRect, fillStyle, useSketch);
          }
          var subPixelRoundingRule = determineSubPixelRoundingRule(this.subPixelRoundingForTransparency);
          var shouldRoundPositionAndSize = false;
          if (subPixelRoundingRule === $2.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS) {
            shouldRoundPositionAndSize = true;
          } else if (subPixelRoundingRule === $2.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
            var isAnimating = this.viewer && this.viewer.isAnimating();
            shouldRoundPositionAndSize = !isAnimating;
          }
          for (var i = lastDrawn.length - 1; i >= 0; i--) {
            tile = lastDrawn[i];
            this._drawer.drawTile(
              tile,
              this._drawingHandler,
              useSketch,
              sketchScale,
              sketchTranslate,
              shouldRoundPositionAndSize,
              this.source
            );
            tile.beingDrawn = true;
            if (this.viewer) {
              this.viewer.raiseEvent("tile-drawn", {
                tiledImage: this,
                tile
              });
            }
          }
          if (usedClip) {
            this._drawer.restoreContext(useSketch);
          }
          if (!sketchScale) {
            if (this.getRotation(true) % 360 !== 0) {
              this._drawer._restoreRotationChanges(useSketch);
            }
            if (this.viewport.getRotation(true) % 360 !== 0) {
              this._drawer._restoreRotationChanges(useSketch);
            }
          }
          if (useSketch) {
            if (sketchScale) {
              if (this.viewport.getRotation(true) % 360 !== 0) {
                this._drawer._offsetForRotation({
                  degrees: this.viewport.getRotation(true),
                  useSketch: false
                });
              }
              if (this.getRotation(true) % 360 !== 0) {
                this._drawer._offsetForRotation({
                  degrees: this.getRotation(true),
                  point: this.viewport.pixelFromPointNoRotate(
                    this._getRotationPoint(true),
                    true
                  ),
                  useSketch: false
                });
              }
            }
            this._drawer.blendSketch({
              opacity: this.opacity,
              scale: sketchScale,
              translate: sketchTranslate,
              compositeOperation: this.compositeOperation,
              bounds
            });
            if (sketchScale) {
              if (this.getRotation(true) % 360 !== 0) {
                this._drawer._restoreRotationChanges(false);
              }
              if (this.viewport.getRotation(true) % 360 !== 0) {
                this._drawer._restoreRotationChanges(false);
              }
            }
          }
          if (!sketchScale) {
            if (this.viewport.getRotation(true) % 360 === 0 && this.getRotation(true) % 360 === 0) {
              if (this._drawer.viewer.viewport.getFlip()) {
                this._drawer._flip();
              }
            }
          }
          this._drawDebugInfo(lastDrawn);
        },
        /**
         * @private
         * @inner
         * Draws special debug information for a TiledImage if in debug mode.
         * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
         */
        _drawDebugInfo: function(lastDrawn) {
          if (this.debugMode) {
            for (var i = lastDrawn.length - 1; i >= 0; i--) {
              var tile = lastDrawn[i];
              try {
                this._drawer.drawDebugInfo(tile, lastDrawn.length, i, this);
              } catch (e) {
                $2.console.error(e);
              }
            }
          }
        },
        /**
         * @private
         * @inner
         * Returns true if the given tile provides coverage to lower-level tiles of
         * lower resolution representing the same content. If neither x nor y is
         * given, returns true if the entire visible level provides coverage.
         *
         * Note that out-of-bounds tiles provide coverage in this sense, since
         * there's no content that they would need to cover. Tiles at non-existent
         * levels that are within the image bounds, however, do not.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of the tile.
         * @param {Number} x - The X position of the tile.
         * @param {Number} y - The Y position of the tile.
         * @returns {Boolean}
         */
        _providesCoverage: function(coverage, level, x2, y) {
          var rows, cols, i, j;
          if (!coverage[level]) {
            return false;
          }
          if (x2 === void 0 || y === void 0) {
            rows = coverage[level];
            for (i in rows) {
              if (Object.prototype.hasOwnProperty.call(rows, i)) {
                cols = rows[i];
                for (j in cols) {
                  if (Object.prototype.hasOwnProperty.call(cols, j) && !cols[j]) {
                    return false;
                  }
                }
              }
            }
            return true;
          }
          return coverage[level][x2] === void 0 || coverage[level][x2][y] === void 0 || coverage[level][x2][y] === true;
        },
        /**
         * @private
         * @inner
         * Returns true if the given tile is completely covered by higher-level
         * tiles of higher resolution representing the same content. If neither x
         * nor y is given, returns true if the entire visible level is covered.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of the tile.
         * @param {Number} x - The X position of the tile.
         * @param {Number} y - The Y position of the tile.
         * @returns {Boolean}
         */
        _isCovered: function(coverage, level, x2, y) {
          if (x2 === void 0 || y === void 0) {
            return this._providesCoverage(coverage, level + 1);
          } else {
            return this._providesCoverage(coverage, level + 1, 2 * x2, 2 * y) && this._providesCoverage(coverage, level + 1, 2 * x2, 2 * y + 1) && this._providesCoverage(coverage, level + 1, 2 * x2 + 1, 2 * y) && this._providesCoverage(coverage, level + 1, 2 * x2 + 1, 2 * y + 1);
          }
        },
        /**
         * @private
         * @inner
         * Sets whether the given tile provides coverage or not.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of the tile.
         * @param {Number} x - The X position of the tile.
         * @param {Number} y - The Y position of the tile.
         * @param {Boolean} covers - Whether the tile provides coverage.
         */
        _setCoverage: function(coverage, level, x2, y, covers) {
          if (!coverage[level]) {
            $2.console.warn(
              "Setting coverage for a tile before its level's coverage has been reset: %s",
              level
            );
            return;
          }
          if (!coverage[level][x2]) {
            coverage[level][x2] = {};
          }
          coverage[level][x2][y] = covers;
        },
        /**
         * @private
         * @inner
         * Resets coverage information for the given level. This should be called
         * after every draw routine. Note that at the beginning of the next draw
         * routine, coverage for every visible tile should be explicitly set.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of tiles to completely reset.
         */
        _resetCoverage: function(coverage, level) {
          coverage[level] = {};
        }
      }
    );
    var DEFAULT_SUBPIXEL_ROUNDING_RULE = $2.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    function isSubPixelRoundingRuleUnknown(value) {
      return value !== $2.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS && value !== $2.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST && value !== $2.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    }
    function normalizeSubPixelRoundingRule(value) {
      if (isSubPixelRoundingRuleUnknown(value)) {
        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
      }
      return value;
    }
    function determineSubPixelRoundingRule(subPixelRoundingRules) {
      if (typeof subPixelRoundingRules === "number") {
        return normalizeSubPixelRoundingRule(subPixelRoundingRules);
      }
      if (!subPixelRoundingRules || !$2.Browser) {
        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
      }
      var subPixelRoundingRule = subPixelRoundingRules[$2.Browser.vendor];
      if (isSubPixelRoundingRuleUnknown(subPixelRoundingRule)) {
        subPixelRoundingRule = subPixelRoundingRules["*"];
      }
      return normalizeSubPixelRoundingRule(subPixelRoundingRule);
    }
  })(OpenSeadragon2);
  (function($2) {
    var TileRecord = function(options) {
      $2.console.assert(options, "[TileCache.cacheTile] options is required");
      $2.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
      $2.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
      this.tile = options.tile;
      this.tiledImage = options.tiledImage;
    };
    var ImageRecord = function(options) {
      $2.console.assert(options, "[ImageRecord] options is required");
      $2.console.assert(options.data, "[ImageRecord] options.data is required");
      this._tiles = [];
      options.create.apply(null, [this, options.data, options.ownerTile]);
      this._destroyImplementation = options.destroy.bind(null, this);
      this.getImage = options.getImage.bind(null, this);
      this.getData = options.getData.bind(null, this);
      this.getRenderedContext = options.getRenderedContext.bind(null, this);
    };
    ImageRecord.prototype = {
      destroy: function() {
        this._destroyImplementation();
        this._tiles = null;
      },
      addTile: function(tile) {
        $2.console.assert(tile, "[ImageRecord.addTile] tile is required");
        this._tiles.push(tile);
      },
      removeTile: function(tile) {
        for (var i = 0; i < this._tiles.length; i++) {
          if (this._tiles[i] === tile) {
            this._tiles.splice(i, 1);
            return;
          }
        }
        $2.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", tile);
      },
      getTileCount: function() {
        return this._tiles.length;
      }
    };
    $2.TileCache = function(options) {
      options = options || {};
      this._maxImageCacheCount = options.maxImageCacheCount || $2.DEFAULT_SETTINGS.maxImageCacheCount;
      this._tilesLoaded = [];
      this._imagesLoaded = [];
      this._imagesLoadedCount = 0;
    };
    $2.TileCache.prototype = {
      /**
       * @returns {Number} The total number of tiles that have been loaded by
       * this TileCache.
       */
      numTilesLoaded: function() {
        return this._tilesLoaded.length;
      },
      /**
       * Caches the specified tile, removing an old tile if necessary to stay under the
       * maxImageCacheCount specified on construction. Note that if multiple tiles reference
       * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
       * the number of images below that number. Note, as well, that even the number of images
       * may temporarily surpass that number, but should eventually come back down to the max specified.
       * @param {Object} options - Tile info.
       * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
       * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
       * @param {Image} options.image - The image of the tile to cache.
       * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
       * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
       * function will release an old tile. The cutoff option specifies a tile level at or below which
       * tiles will not be released.
       */
      cacheTile: function(options) {
        $2.console.assert(options, "[TileCache.cacheTile] options is required");
        $2.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
        $2.console.assert(options.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required");
        $2.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
        var cutoff = options.cutoff || 0;
        var insertionIndex = this._tilesLoaded.length;
        var imageRecord = this._imagesLoaded[options.tile.cacheKey];
        if (!imageRecord) {
          if (!options.data) {
            $2.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute has been deprecated and will be removed in the future.");
            options.data = options.image;
          }
          $2.console.assert(options.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord");
          imageRecord = this._imagesLoaded[options.tile.cacheKey] = new ImageRecord({
            data: options.data,
            ownerTile: options.tile,
            create: options.tiledImage.source.createTileCache,
            destroy: options.tiledImage.source.destroyTileCache,
            getImage: options.tiledImage.source.getTileCacheDataAsImage,
            getData: options.tiledImage.source.getTileCacheData,
            getRenderedContext: options.tiledImage.source.getTileCacheDataAsContext2D
          });
          this._imagesLoadedCount++;
        }
        imageRecord.addTile(options.tile);
        options.tile.cacheImageRecord = imageRecord;
        if (this._imagesLoadedCount > this._maxImageCacheCount) {
          var worstTile = null;
          var worstTileIndex = -1;
          var worstTileRecord = null;
          var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;
          for (var i = this._tilesLoaded.length - 1; i >= 0; i--) {
            prevTileRecord = this._tilesLoaded[i];
            prevTile = prevTileRecord.tile;
            if (prevTile.level <= cutoff || prevTile.beingDrawn) {
              continue;
            } else if (!worstTile) {
              worstTile = prevTile;
              worstTileIndex = i;
              worstTileRecord = prevTileRecord;
              continue;
            }
            prevTime = prevTile.lastTouchTime;
            worstTime = worstTile.lastTouchTime;
            prevLevel = prevTile.level;
            worstLevel = worstTile.level;
            if (prevTime < worstTime || prevTime === worstTime && prevLevel > worstLevel) {
              worstTile = prevTile;
              worstTileIndex = i;
              worstTileRecord = prevTileRecord;
            }
          }
          if (worstTile && worstTileIndex >= 0) {
            this._unloadTile(worstTileRecord);
            insertionIndex = worstTileIndex;
          }
        }
        this._tilesLoaded[insertionIndex] = new TileRecord({
          tile: options.tile,
          tiledImage: options.tiledImage
        });
      },
      /**
       * Clears all tiles associated with the specified tiledImage.
       * @param {OpenSeadragon.TiledImage} tiledImage
       */
      clearTilesFor: function(tiledImage) {
        $2.console.assert(tiledImage, "[TileCache.clearTilesFor] tiledImage is required");
        var tileRecord;
        for (var i = 0; i < this._tilesLoaded.length; ++i) {
          tileRecord = this._tilesLoaded[i];
          if (tileRecord.tiledImage === tiledImage) {
            this._unloadTile(tileRecord);
            this._tilesLoaded.splice(i, 1);
            i--;
          }
        }
      },
      // private
      getImageRecord: function(cacheKey) {
        $2.console.assert(cacheKey, "[TileCache.getImageRecord] cacheKey is required");
        return this._imagesLoaded[cacheKey];
      },
      // private
      _unloadTile: function(tileRecord) {
        $2.console.assert(tileRecord, "[TileCache._unloadTile] tileRecord is required");
        var tile = tileRecord.tile;
        var tiledImage = tileRecord.tiledImage;
        tile.unload();
        tile.cacheImageRecord = null;
        var imageRecord = this._imagesLoaded[tile.cacheKey];
        imageRecord.removeTile(tile);
        if (!imageRecord.getTileCount()) {
          imageRecord.destroy();
          delete this._imagesLoaded[tile.cacheKey];
          this._imagesLoadedCount--;
        }
        tiledImage.viewer.raiseEvent("tile-unloaded", {
          tile,
          tiledImage
        });
      }
    };
  })(OpenSeadragon2);
  (function($2) {
    $2.World = function(options) {
      var _this = this;
      $2.console.assert(options.viewer, "[World] options.viewer is required");
      $2.EventSource.call(this);
      this.viewer = options.viewer;
      this._items = [];
      this._needsDraw = false;
      this._autoRefigureSizes = true;
      this._needsSizesFigured = false;
      this._delegatedFigureSizes = function(event) {
        if (_this._autoRefigureSizes) {
          _this._figureSizes();
        } else {
          _this._needsSizesFigured = true;
        }
      };
      this._figureSizes();
    };
    $2.extend(
      $2.World.prototype,
      $2.EventSource.prototype,
      /** @lends OpenSeadragon.World.prototype */
      {
        /**
         * Add the specified item.
         * @param {OpenSeadragon.TiledImage} item - The item to add.
         * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
         * @fires OpenSeadragon.World.event:add-item
         * @fires OpenSeadragon.World.event:metrics-change
         */
        addItem: function(item, options) {
          $2.console.assert(item, "[World.addItem] item is required");
          $2.console.assert(item instanceof $2.TiledImage, "[World.addItem] only TiledImages supported at this time");
          options = options || {};
          if (options.index !== void 0) {
            var index = Math.max(0, Math.min(this._items.length, options.index));
            this._items.splice(index, 0, item);
          } else {
            this._items.push(item);
          }
          if (this._autoRefigureSizes) {
            this._figureSizes();
          } else {
            this._needsSizesFigured = true;
          }
          this._needsDraw = true;
          item.addHandler("bounds-change", this._delegatedFigureSizes);
          item.addHandler("clip-change", this._delegatedFigureSizes);
          this.raiseEvent("add-item", {
            item
          });
        },
        /**
         * Get the item at the specified index.
         * @param {Number} index - The item's index.
         * @returns {OpenSeadragon.TiledImage} The item at the specified index.
         */
        getItemAt: function(index) {
          $2.console.assert(index !== void 0, "[World.getItemAt] index is required");
          return this._items[index];
        },
        /**
         * Get the index of the given item or -1 if not present.
         * @param {OpenSeadragon.TiledImage} item - The item.
         * @returns {Number} The index of the item or -1 if not present.
         */
        getIndexOfItem: function(item) {
          $2.console.assert(item, "[World.getIndexOfItem] item is required");
          return $2.indexOf(this._items, item);
        },
        /**
         * @returns {Number} The number of items used.
         */
        getItemCount: function() {
          return this._items.length;
        },
        /**
         * Change the index of a item so that it appears over or under others.
         * @param {OpenSeadragon.TiledImage} item - The item to move.
         * @param {Number} index - The new index.
         * @fires OpenSeadragon.World.event:item-index-change
         */
        setItemIndex: function(item, index) {
          $2.console.assert(item, "[World.setItemIndex] item is required");
          $2.console.assert(index !== void 0, "[World.setItemIndex] index is required");
          var oldIndex = this.getIndexOfItem(item);
          if (index >= this._items.length) {
            throw new Error("Index bigger than number of layers.");
          }
          if (index === oldIndex || oldIndex === -1) {
            return;
          }
          this._items.splice(oldIndex, 1);
          this._items.splice(index, 0, item);
          this._needsDraw = true;
          this.raiseEvent("item-index-change", {
            item,
            previousIndex: oldIndex,
            newIndex: index
          });
        },
        /**
         * Remove an item.
         * @param {OpenSeadragon.TiledImage} item - The item to remove.
         * @fires OpenSeadragon.World.event:remove-item
         * @fires OpenSeadragon.World.event:metrics-change
         */
        removeItem: function(item) {
          $2.console.assert(item, "[World.removeItem] item is required");
          var index = $2.indexOf(this._items, item);
          if (index === -1) {
            return;
          }
          item.removeHandler("bounds-change", this._delegatedFigureSizes);
          item.removeHandler("clip-change", this._delegatedFigureSizes);
          item.destroy();
          this._items.splice(index, 1);
          this._figureSizes();
          this._needsDraw = true;
          this._raiseRemoveItem(item);
        },
        /**
         * Remove all items.
         * @fires OpenSeadragon.World.event:remove-item
         * @fires OpenSeadragon.World.event:metrics-change
         */
        removeAll: function() {
          this.viewer._cancelPendingImages();
          var item;
          var i;
          for (i = 0; i < this._items.length; i++) {
            item = this._items[i];
            item.removeHandler("bounds-change", this._delegatedFigureSizes);
            item.removeHandler("clip-change", this._delegatedFigureSizes);
            item.destroy();
          }
          var removedItems = this._items;
          this._items = [];
          this._figureSizes();
          this._needsDraw = true;
          for (i = 0; i < removedItems.length; i++) {
            item = removedItems[i];
            this._raiseRemoveItem(item);
          }
        },
        /**
         * Clears all tiles and triggers updates for all items.
         */
        resetItems: function() {
          for (var i = 0; i < this._items.length; i++) {
            this._items[i].reset();
          }
        },
        /**
         * Updates (i.e. animates bounds of) all items.
         */
        update: function() {
          var animated = false;
          for (var i = 0; i < this._items.length; i++) {
            animated = this._items[i].update() || animated;
          }
          return animated;
        },
        /**
         * Draws all items.
         */
        draw: function() {
          for (var i = 0; i < this._items.length; i++) {
            this._items[i].draw();
          }
          this._needsDraw = false;
        },
        /**
         * @returns {Boolean} true if any items need updating.
         */
        needsDraw: function() {
          for (var i = 0; i < this._items.length; i++) {
            if (this._items[i].needsDraw()) {
              return true;
            }
          }
          return this._needsDraw;
        },
        /**
         * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
         */
        getHomeBounds: function() {
          return this._homeBounds.clone();
        },
        /**
         * To facilitate zoom constraints, we keep track of the pixel density of the
         * densest item in the World (i.e. the item whose content size to viewport size
         * ratio is the highest) and save it as this "content factor".
         * @returns {Number} the number of content units per viewport unit.
         */
        getContentFactor: function() {
          return this._contentFactor;
        },
        /**
         * As a performance optimization, setting this flag to false allows the bounds-change event handler
         * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
         * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
         * or the system may behave oddly.
         * @param {Boolean} [value] The value to which to set the flag.
         */
        setAutoRefigureSizes: function(value) {
          this._autoRefigureSizes = value;
          if (value & this._needsSizesFigured) {
            this._figureSizes();
            this._needsSizesFigured = false;
          }
        },
        /**
         * Arranges all of the TiledImages with the specified settings.
         * @param {Object} options - Specifies how to arrange.
         * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
         * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
         * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
         * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
         * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
         * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
         * @fires OpenSeadragon.World.event:metrics-change
         */
        arrange: function(options) {
          options = options || {};
          var immediately = options.immediately || false;
          var layout = options.layout || $2.DEFAULT_SETTINGS.collectionLayout;
          var rows = options.rows || $2.DEFAULT_SETTINGS.collectionRows;
          var columns = options.columns || $2.DEFAULT_SETTINGS.collectionColumns;
          var tileSize = options.tileSize || $2.DEFAULT_SETTINGS.collectionTileSize;
          var tileMargin = options.tileMargin || $2.DEFAULT_SETTINGS.collectionTileMargin;
          var increment = tileSize + tileMargin;
          var wrap2;
          if (!options.rows && columns) {
            wrap2 = columns;
          } else {
            wrap2 = Math.ceil(this._items.length / rows);
          }
          var x2 = 0;
          var y = 0;
          var item, box, width, height, position;
          this.setAutoRefigureSizes(false);
          for (var i = 0; i < this._items.length; i++) {
            if (i && i % wrap2 === 0) {
              if (layout === "horizontal") {
                y += increment;
                x2 = 0;
              } else {
                x2 += increment;
                y = 0;
              }
            }
            item = this._items[i];
            box = item.getBounds();
            if (box.width > box.height) {
              width = tileSize;
            } else {
              width = tileSize * (box.width / box.height);
            }
            height = width * (box.height / box.width);
            position = new $2.Point(
              x2 + (tileSize - width) / 2,
              y + (tileSize - height) / 2
            );
            item.setPosition(position, immediately);
            item.setWidth(width, immediately);
            if (layout === "horizontal") {
              x2 += increment;
            } else {
              y += increment;
            }
          }
          this.setAutoRefigureSizes(true);
        },
        // private
        _figureSizes: function() {
          var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
          var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
          var oldContentFactor = this._contentFactor || 0;
          if (!this._items.length) {
            this._homeBounds = new $2.Rect(0, 0, 1, 1);
            this._contentSize = new $2.Point(1, 1);
            this._contentFactor = 1;
          } else {
            var item = this._items[0];
            var bounds = item.getBounds();
            this._contentFactor = item.getContentSize().x / bounds.width;
            var clippedBounds = item.getClippedBounds().getBoundingBox();
            var left = clippedBounds.x;
            var top = clippedBounds.y;
            var right = clippedBounds.x + clippedBounds.width;
            var bottom = clippedBounds.y + clippedBounds.height;
            for (var i = 1; i < this._items.length; i++) {
              item = this._items[i];
              bounds = item.getBounds();
              this._contentFactor = Math.max(
                this._contentFactor,
                item.getContentSize().x / bounds.width
              );
              clippedBounds = item.getClippedBounds().getBoundingBox();
              left = Math.min(left, clippedBounds.x);
              top = Math.min(top, clippedBounds.y);
              right = Math.max(right, clippedBounds.x + clippedBounds.width);
              bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
            }
            this._homeBounds = new $2.Rect(left, top, right - left, bottom - top);
            this._contentSize = new $2.Point(
              this._homeBounds.width * this._contentFactor,
              this._homeBounds.height * this._contentFactor
            );
          }
          if (this._contentFactor !== oldContentFactor || !this._homeBounds.equals(oldHomeBounds) || !this._contentSize.equals(oldContentSize)) {
            this.raiseEvent("metrics-change", {});
          }
        },
        // private
        _raiseRemoveItem: function(item) {
          this.raiseEvent("remove-item", { item });
        }
      }
    );
  })(OpenSeadragon2);
})(openseadragon);
var openseadragonExports = openseadragon.exports;
const OpenSeadragon = /* @__PURE__ */ getDefaultExportFromCjs(openseadragonExports);
class CSSOverlayManager {
  constructor(viewer) {
    this.viewer = viewer;
    this.overlayElement = null;
    this.isInitialized = false;
    this.isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || "ontouchstart" in window;
    this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    this.state = {
      selectedHotspot: null,
      currentPosition: { x: 50, y: 50 },
      // Percentage
      targetPosition: { x: 50, y: 50 },
      currentRadius: 0,
      targetRadius: 0,
      opacity: 0,
      targetOpacity: 0,
      isAnimating: false,
      isFadingOut: false,
      isAutoDeselecting: false
    };
    this.focusTracking = {
      referenceZoom: null,
      referenceCenter: null,
      hotspotCenter: null,
      selectionTime: null,
      lastCalculation: 0,
      throttleInterval: 16
      // 60 FPS
    };
    this.config = {
      maxOpacity: 0.7,
      fadeSpeed: 0.25,
      // Increased for faster response
      fadeSpeedAutoDeselect: 0.5,
      positionSpeed: 0.2,
      radiusSpeed: 0.2,
      baseRadius: 150,
      // Not used anymore, kept for compatibility
      updateThrottle: 16,
      enableTransitions: true,
      transitionDuration: 300,
      // New Phase 3 settings
      enableAdvancedMetrics: true,
      adaptiveQuality: true,
      debugMetrics: false
    };
    this.animationFrame = null;
    this.lastUpdateTime = 0;
    this.opacityInterpolation = {
      current: 1,
      target: 1,
      velocity: 0,
      animationId: null,
      interpolationRate: 0.12,
      // ~250ms to 90% complete
      velocityDecay: 0.92,
      // Momentum friction
      minDelta: 1e-3,
      // Animation cutoff threshold
      lastWheelTime: 0,
      wheelAccumulator: 0
    };
    this.cachedViewportRect = null;
    this.viewportRectCacheTime = 0;
    this.viewportRectCacheDuration = 50;
    this.animate = this.animate.bind(this);
    this.updateSpotlightPosition = this.updateSpotlightPosition.bind(this);
    this.renderingPaused = false;
  }
  getCachedViewportRect() {
    const now = performance.now();
    if (!this.cachedViewportRect || now - this.viewportRectCacheTime > this.viewportRectCacheDuration) {
      this.cachedViewportRect = this.viewer.container.getBoundingClientRect();
      this.viewportRectCacheTime = now;
    }
    return this.cachedViewportRect;
  }
  /**
   * Calculate Zunic-Rosin convexity measure - more accurate than sign changes
   * Returns value in (0,1] where 1 is perfectly convex
   */
  calculateZunicRosinConvexity(coords) {
    const hull = this.calculateConvexHull(coords);
    const hullPerimeter = this.calculatePolygonPerimeter(hull);
    const polygonPerimeter = this.calculatePolygonPerimeter(coords);
    return polygonPerimeter / hullPerimeter;
  }
  /**
   * Calculate convex hull using Graham scan algorithm - O(n log n)
   */
  calculateConvexHull(coords) {
    let start = 0;
    for (let i = 1; i < coords.length; i++) {
      if (coords[i][1] < coords[start][1] || coords[i][1] === coords[start][1] && coords[i][0] < coords[start][0]) {
        start = i;
      }
    }
    const sorted = coords.slice().sort((a, b) => {
      if (a === coords[start]) return -1;
      if (b === coords[start]) return 1;
      const angleA = Math.atan2(a[1] - coords[start][1], a[0] - coords[start][0]);
      const angleB = Math.atan2(b[1] - coords[start][1], b[0] - coords[start][0]);
      return angleA - angleB;
    });
    const hull = [sorted[0], sorted[1]];
    for (let i = 2; i < sorted.length; i++) {
      while (hull.length > 1) {
        const p1 = hull[hull.length - 2];
        const p2 = hull[hull.length - 1];
        const p3 = sorted[i];
        const cross = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]);
        if (cross > 0) break;
        hull.pop();
      }
      hull.push(sorted[i]);
    }
    return hull;
  }
  /**
   * Calculate polygon area and perimeter
   */
  calculatePolygonArea(coords) {
    let area = 0;
    const n = coords.length;
    for (let i = 0; i < n; i++) {
      const j = (i + 1) % n;
      area += coords[i][0] * coords[j][1];
      area -= coords[j][0] * coords[i][1];
    }
    return Math.abs(area) / 2;
  }
  calculatePolygonPerimeter(coords) {
    let perimeter = 0;
    const n = coords.length;
    for (let i = 0; i < n; i++) {
      const j = (i + 1) % n;
      const dx = coords[j][0] - coords[i][0];
      const dy = coords[j][1] - coords[i][1];
      perimeter += Math.sqrt(dx * dx + dy * dy);
    }
    return perimeter;
  }
  /**
   * Calculate discrete curvature for roughness measurement
   */
  calculateDiscreteRoughness(coords) {
    let totalCurvature = 0;
    let maxLocalCurvature = 0;
    const n = coords.length;
    for (let i = 0; i < n; i++) {
      const prev = coords[(i - 1 + n) % n];
      const curr = coords[i];
      const next = coords[(i + 1) % n];
      const angle1 = Math.atan2(curr[1] - prev[1], curr[0] - prev[0]);
      const angle2 = Math.atan2(next[1] - curr[1], next[0] - curr[0]);
      let turnAngle = angle2 - angle1;
      while (turnAngle > Math.PI) turnAngle -= 2 * Math.PI;
      while (turnAngle < -Math.PI) turnAngle += 2 * Math.PI;
      const edgeLength = Math.sqrt(
        Math.pow(next[0] - curr[0], 2) + Math.pow(next[1] - curr[1], 2)
      );
      const curvature = Math.abs(turnAngle) / (edgeLength + 1e-10);
      totalCurvature += curvature;
      maxLocalCurvature = Math.max(maxLocalCurvature, curvature);
    }
    return {
      avgCurvature: totalCurvature / n,
      maxCurvature: maxLocalCurvature,
      roughnessScore: 1 - Math.exp(-totalCurvature / n)
    };
  }
  /**
   * Analyze local vertex density
   */
  analyzeVertexDensity(coords) {
    const n = coords.length;
    const densities = new Array(n).fill(0);
    let totalEdgeLength = 0;
    for (let i = 0; i < n; i++) {
      const next = coords[(i + 1) % n];
      totalEdgeLength += Math.sqrt(
        Math.pow(coords[i][0] - next[0], 2) + Math.pow(coords[i][1] - next[1], 2)
      );
    }
    const avgEdgeLength = totalEdgeLength / n;
    const searchRadius = avgEdgeLength * 3;
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        const dist = Math.sqrt(
          Math.pow(coords[i][0] - coords[j][0], 2) + Math.pow(coords[i][1] - coords[j][1], 2)
        );
        if (dist < searchRadius) {
          densities[i]++;
        }
      }
    }
    const maxDensity = Math.max(...densities);
    const avgDensity = densities.reduce((a, b) => a + b, 0) / n;
    const variance = densities.reduce((sum, d) => sum + Math.pow(d - avgDensity, 2), 0) / n;
    return {
      maxDensity,
      avgDensity,
      variance,
      uniformityScore: 1 - Math.sqrt(variance) / (avgDensity + 1)
    };
  }
  /**
   * Calculate polygon metrics
   */
  calculatePolygonMetrics(coords) {
    const area = this.calculatePolygonArea(coords);
    const perimeter = this.calculatePolygonPerimeter(coords);
    const bounds = this.getHotspotBoundsFromCoords(coords);
    const boundingArea = bounds.width * bounds.height;
    return {
      area,
      perimeter,
      fillEfficiency: area / boundingArea,
      compactness: 4 * Math.PI * area / (perimeter * perimeter),
      aspectRatio: bounds.width / bounds.height,
      vertexDensity: coords.length / perimeter
    };
  }
  /**
   * Get bounds from coordinates array
   */
  getHotspotBoundsFromCoords(coords) {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    coords.forEach(([x2, y]) => {
      minX = Math.min(minX, x2);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x2);
      maxY = Math.max(maxY, y);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }
  /**
   * Get performance mode based on FPS
   */
  getPerformanceMode() {
    if (!window.performanceMonitor) return "full";
    const metrics = window.performanceMonitor.getMetrics();
    if (metrics.averageFPS < 30) return "reduced";
    if (metrics.averageFPS < 45) return "medium";
    return "full";
  }
  /**
   * Simplify polygon using Douglas-Peucker algorithm
   */
  simplifyPolygon(coords, tolerance) {
    if (coords.length <= 3) return coords;
    let maxDist = 0;
    let maxIndex = 0;
    const n = coords.length;
    for (let i = 1; i < n - 1; i++) {
      const dist = this.perpendicularDistance(coords[i], coords[0], coords[n - 1]);
      if (dist > maxDist) {
        maxDist = dist;
        maxIndex = i;
      }
    }
    if (maxDist > tolerance) {
      const left = this.simplifyPolygon(coords.slice(0, maxIndex + 1), tolerance);
      const right = this.simplifyPolygon(coords.slice(maxIndex), tolerance);
      return [...left.slice(0, -1), ...right];
    } else {
      return [coords[0], coords[n - 1]];
    }
  }
  /**
   * Calculate perpendicular distance from point to line
   */
  perpendicularDistance(point, lineStart, lineEnd) {
    const dx = lineEnd[0] - lineStart[0];
    const dy = lineEnd[1] - lineStart[1];
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) {
      return Math.sqrt(
        Math.pow(point[0] - lineStart[0], 2) + Math.pow(point[1] - lineStart[1], 2)
      );
    }
    const u = ((point[0] - lineStart[0]) * dx + (point[1] - lineStart[1]) * dy) / (mag * mag);
    const closestPoint = [lineStart[0] + u * dx, lineStart[1] + u * dy];
    return Math.sqrt(
      Math.pow(point[0] - closestPoint[0], 2) + Math.pow(point[1] - closestPoint[1], 2)
    );
  }
  initialize() {
    if (this.isInitialized) return;
    this.overlayElement = document.createElement("div");
    this.overlayElement.className = "css-spotlight-overlay";
    this.useClipPath = this.isSafari || this.isIOS;
    if (this.useClipPath) {
      console.log("Using clip-path strategy for Safari/iOS");
    }
    const styles = {
      position: "fixed",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      zIndex: "1000",
      backgroundColor: `rgba(0, 0, 0, ${this.config.maxOpacity})`,
      opacity: "0",
      transition: this.config.enableTransitions ? `opacity ${this.config.transitionDuration}ms ease-out` : "none",
      willChange: "mask, opacity",
      transform: "translateZ(0)"
      // Force GPU layer
    };
    if (!this.useClipPath) ;
    Object.assign(this.overlayElement.style, styles);
    if (this.isSafari && !document.getElementById("safari-mask-fix")) {
      const style2 = document.createElement("style");
      style2.id = "safari-mask-fix";
      style2.textContent = `
        .css-spotlight-overlay {
            -webkit-mask-composite: source-in;
            -webkit-backface-visibility: hidden;
            -webkit-transform: translateZ(0);
        }
    `;
      document.head.appendChild(style2);
    }
    this.viewer.container.appendChild(this.overlayElement);
    this.setupEventListeners();
    this.isInitialized = true;
    console.log("CSSOverlayManager initialized with dynamic SVG data URI masks");
  }
  setupEventListeners() {
    this.viewer.addHandler("viewport-change", () => {
      if (this.state.selectedHotspot) {
        this.updateSpotlightPosition();
      }
    });
    this.viewer.addHandler("zoom", () => {
      if (this.state.selectedHotspot) {
        this.checkAutoDeselect();
      }
    });
    this.viewer.addHandler("animation-finish", () => {
      if (this.state.selectedHotspot) {
        this.checkAutoDeselect();
      }
    });
    this.viewer.addHandler("pan", () => {
      if (this.state.selectedHotspot && !this.state.isAnimating) {
        this.startAnimation();
      }
    });
  }
  selectHotspot(hotspot) {
    var _a, _b;
    if (((_a = this.state.selectedHotspot) == null ? void 0 : _a.id) === (hotspot == null ? void 0 : hotspot.id)) return;
    console.log("🔦 [SPOTLIGHT] CSSOverlayManager: selectHotspot called", {
      hotspotId: hotspot == null ? void 0 : hotspot.id,
      previousSelected: ((_b = this.state.selectedHotspot) == null ? void 0 : _b.id) || "none"
    });
    this.state.isManualSelection = true;
    if (this.state.selectedHotspot && this.state.selectedHotspot.id !== (hotspot == null ? void 0 : hotspot.id)) {
      console.log("🔄 CSSOverlayManager: Clearing previous selection");
      this.state.targetOpacity = 0;
      this.state.currentOpacity = 0;
      if (this.overlayElement) {
        this.overlayElement.style.opacity = "0";
        this.overlayElement.style.mask = "";
        this.overlayElement.style.webkitMask = "";
      }
    }
    this.state.selectedHotspot = hotspot;
    if (hotspot) {
      this.updateSpotlightPosition();
      this.state.targetOpacity = 1;
      setTimeout(() => {
        this.trackFocusReference();
      }, 800);
      this.startAnimation();
      setTimeout(() => {
        this.state.isManualSelection = false;
      }, 1e3);
    } else {
      this.state.targetOpacity = 0;
      this.state.targetRadius = 0;
      this.resetFocusTracking();
      this.startAnimation();
      this.state.isManualSelection = false;
    }
  }
  /**
   * Pause rendering for performance optimization (e.g., during animations)
   */
  pauseRendering() {
    this.renderingPaused = true;
    console.log("⏸️  CSS Rendering paused for animation");
  }
  /**
   * Resume rendering after animation completes
   */
  resumeRendering() {
    this.renderingPaused = false;
    console.log("▶️  CSS Rendering resumed after animation");
    if (this.state.selectedHotspot) {
      this.updateSpotlightPosition();
    }
  }
  updateSpotlightPosition() {
    if (this.renderingPaused) {
      return;
    }
    if (!this.state.selectedHotspot || !this.overlayElement) return;
    const hotspot = this.state.selectedHotspot;
    const viewportRect = this.getCachedViewportRect();
    let coords = hotspot.shape === "polygon" ? hotspot.coordinates : hotspot.coordinates[0];
    const performanceMode = this.getPerformanceMode();
    if (performanceMode === "reduced") {
      coords = this.simplifyPolygon(coords, 0.5);
    }
    const expansionFactor = 1;
    const expandedCoords = this.expandPolygon(coords, expansionFactor);
    const screenPoints = [];
    let centerX = 0, centerY = 0;
    expandedCoords.forEach(([x2, y]) => {
      const viewportPoint = this.viewer.viewport.imageToViewportCoordinates(
        new OpenSeadragon.Point(x2, y)
      );
      const windowPoint = this.viewer.viewport.viewportToWindowCoordinates(viewportPoint);
      centerX += windowPoint.x;
      centerY += windowPoint.y;
    });
    centerX /= expandedCoords.length;
    centerY /= expandedCoords.length;
    let shrinkFactor = 1;
    if (this.state.isAutoDeselecting && this.state.targetOpacity === 0 && this.state.opacity < 1) {
      shrinkFactor = Math.max(0.1, this.state.opacity * this.state.opacity);
    }
    expandedCoords.forEach(([x2, y]) => {
      const viewportPoint = this.viewer.viewport.imageToViewportCoordinates(
        new OpenSeadragon.Point(x2, y)
      );
      const windowPoint = this.viewer.viewport.viewportToWindowCoordinates(viewportPoint);
      const shrunkX = centerX + (windowPoint.x - centerX) * shrinkFactor;
      const shrunkY = centerY + (windowPoint.y - centerY) * shrinkFactor;
      screenPoints.push(`${shrunkX},${shrunkY}`);
    });
    if (screenPoints.length > 0) {
      if (this.useClipPath) {
        const vw = viewportRect.width;
        const vh = viewportRect.height;
        const outerPath = `0,0 ${vw},0 ${vw},${vh} 0,${vh} 0,0`;
        const innerPath = screenPoints.slice().reverse().join(" ");
        const clipPath = `polygon(${outerPath} ${innerPath})`;
        this.overlayElement.style.clipPath = clipPath;
        this.overlayElement.style.webkitClipPath = clipPath;
      } else {
        const svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="${viewportRect.width}" height="${viewportRect.height}" viewBox="0 0 ${viewportRect.width} ${viewportRect.height}">
            <defs>
                <mask id="spotlightMask" maskUnits="userSpaceOnUse">
                    <rect fill="white" x="0" y="0" width="100%" height="100%"/>
                    <polygon fill="black" points="${screenPoints.join(" ")}"/>
                </mask>
            </defs>
            <rect width="100%" height="100%" fill="black" mask="url(#spotlightMask)"/>
        </svg>`;
        const encodedSvg = btoa(unescape(encodeURIComponent(svgString)));
        const dataUri = `data:image/svg+xml;base64,${encodedSvg}`;
        this.overlayElement.style.mask = `url("${dataUri}")`;
        this.overlayElement.style.webkitMask = `url("${dataUri}")`;
        this.overlayElement.style.maskSize = "100% 100%";
        this.overlayElement.style.webkitMaskSize = "100% 100%";
        this.overlayElement.style.maskRepeat = "no-repeat";
        this.overlayElement.style.webkitMaskRepeat = "no-repeat";
      }
    }
    if (!this.state.isAnimating) {
      this.applySpotlightStyles();
    }
  }
  calculateSpotlightRadius(bounds, zoom) {
    const topLeft = this.viewer.viewport.imageToViewportCoordinates(
      new OpenSeadragon.Point(bounds.x, bounds.y)
    );
    const bottomRight = this.viewer.viewport.imageToViewportCoordinates(
      new OpenSeadragon.Point(bounds.x + bounds.width, bounds.y + bounds.height)
    );
    const widthInViewport = bottomRight.x - topLeft.x;
    const heightInViewport = bottomRight.y - topLeft.y;
    const windowWidth = widthInViewport * this.viewer.container.clientWidth;
    const windowHeight = heightInViewport * this.viewer.container.clientHeight;
    const maxDimension = Math.max(windowWidth, windowHeight);
    const radius = maxDimension * 0.75;
    return Math.max(50, Math.min(500, radius));
  }
  trackFocusReference() {
    if (!this.state.selectedHotspot || !this.viewer || !this.viewer.viewport) return;
    const currentZoom = this.viewer.viewport.getZoom();
    const center = this.viewer.viewport.getCenter();
    const bounds = this.getHotspotBounds(this.state.selectedHotspot);
    this.focusTracking = {
      referenceZoom: currentZoom,
      referenceCenter: { x: center.x, y: center.y },
      hotspotCenter: bounds ? { x: bounds.centerX, y: bounds.centerY } : null,
      selectionTime: Date.now(),
      lastCalculation: 0,
      throttleInterval: 16
    };
  }
  checkAutoDeselect() {
    if (!this.state.selectedHotspot || !this.focusTracking.referenceZoom) return;
    const timeSinceSelection = Date.now() - this.focusTracking.selectionTime;
    if (timeSinceSelection < 500) return;
    const focusScore = this.calculateFocusScore();
    const visibleOpacity = focusScore * this.config.maxOpacity;
    const visibleOpacityThreshold = 0.1;
    if (visibleOpacity < visibleOpacityThreshold) {
      console.log("Auto-deselecting: visible opacity below threshold", {
        focusScore: focusScore.toFixed(3),
        visibleOpacity: visibleOpacity.toFixed(3),
        threshold: visibleOpacityThreshold
      });
      this.autoDeselect();
    }
  }
  calculateFocusScore() {
    if (!this.state.selectedHotspot || !this.focusTracking.referenceZoom) {
      return 1;
    }
    const currentZoom = this.viewer.viewport.getZoom();
    const currentCenter = this.viewer.viewport.getCenter();
    const zoomRatio = currentZoom / this.focusTracking.referenceZoom;
    let zoomScore = 1;
    const START_FADE = 0.85;
    const END_FADE = 0.4;
    if (zoomRatio >= START_FADE) {
      zoomScore = 1;
    } else if (zoomRatio <= END_FADE) {
      zoomScore = 0;
    } else {
      const normalized = (zoomRatio - END_FADE) / (START_FADE - END_FADE);
      zoomScore = 1 - Math.pow(1 - normalized, 3);
    }
    let distanceScore = 1;
    if (this.state.selectedHotspot && currentCenter) {
      const coords = this.state.selectedHotspot.shape === "polygon" ? this.state.selectedHotspot.coordinates : this.state.selectedHotspot.coordinates[0];
      const imagePt = this.viewer.viewport.viewportToImageCoordinates(currentCenter);
      const isInsidePolygon = this.isPointInPolygon({ x: imagePt.x, y: imagePt.y }, coords);
      if (isInsidePolygon) {
        distanceScore = 1;
        console.log("[CSS] Inside hotspot polygon - maintaining 100% opacity");
      } else {
        const distanceToEdge = this.calculateDistanceToPolygon(
          { x: imagePt.x, y: imagePt.y },
          coords
        );
        const imageSize = this.viewer.world.getItemAt(0).getContentSize();
        const distanceInViewport = distanceToEdge / imageSize.x;
        const EDGE_FADE_START = 0;
        const EDGE_FADE_END = 0.015;
        if (distanceInViewport <= EDGE_FADE_START) {
          distanceScore = 1;
        } else if (distanceInViewport >= EDGE_FADE_END) {
          distanceScore = 0;
        } else {
          const normalized = distanceInViewport / EDGE_FADE_END;
          distanceScore = 1 - Math.pow(normalized, 1.8);
          console.log(
            `[CSS] Outside polygon - distance: ${(distanceInViewport * 100).toFixed(2)}%, opacity: ${(distanceScore * 100).toFixed(0)}%`
          );
        }
      }
    }
    if (distanceScore < 0.1) {
      return distanceScore;
    }
    const combinedScore = Math.min(zoomScore, distanceScore);
    return combinedScore;
  }
  /**
   * Quantize opacity to discrete levels for clearer visual steps
   */
  quantizeToLevels(value, levels) {
    let closestLevel = levels[0];
    let minDiff = Math.abs(value - levels[0]);
    for (const level of levels) {
      const diff = Math.abs(value - level);
      if (diff < minDiff) {
        minDiff = diff;
        closestLevel = level;
      }
    }
    return closestLevel;
  }
  /**
   * Detect wheel velocity and adapt interpolation parameters
   */
  detectWheelVelocity(deltaY) {
    const now = performance.now();
    const timeDelta = now - this.opacityInterpolation.lastWheelTime;
    this.opacityInterpolation.lastWheelTime = now;
    const velocity = Math.abs(deltaY) / Math.max(timeDelta, 1) * 1e3;
    if (velocity > 2e3) {
      this.opacityInterpolation.interpolationRate = 0.18;
      this.opacityInterpolation.velocityDecay = 0.88;
      this.opacityInterpolation.velocity += deltaY * 5e-4;
    } else if (velocity < 500) {
      this.opacityInterpolation.interpolationRate = 0.08;
      this.opacityInterpolation.velocityDecay = 0.95;
      this.opacityInterpolation.velocity = 0;
    } else {
      this.opacityInterpolation.interpolationRate = 0.12;
      this.opacityInterpolation.velocityDecay = 0.92;
      this.opacityInterpolation.velocity += deltaY * 2e-4;
    }
    return velocity;
  }
  /**
   * Set target opacity and start interpolation if needed
   */
  setTargetOpacity(target, wheelDelta = null) {
    if (wheelDelta !== null) {
      this.detectWheelVelocity(wheelDelta);
    }
    this.opacityInterpolation.target = target;
    if (!this.opacityInterpolation.animationId) {
      this.interpolateOpacity();
    }
  }
  /**
   * Smooth interpolation of opacity using requestAnimationFrame
   */
  interpolateOpacity() {
    const interp = this.opacityInterpolation;
    interp.velocity *= interp.velocityDecay;
    const delta = interp.target - interp.current;
    interp.current += delta * interp.interpolationRate;
    if (this.spotlightOverlay) {
      const opacity = Math.max(0, Math.min(1, interp.current)) * this.config.maxOpacity;
      this.spotlightOverlay.style.opacity = opacity.toString();
    }
    if (Math.abs(delta) > interp.minDelta || Math.abs(interp.velocity) > 1e-3) {
      interp.animationId = requestAnimationFrame(() => this.interpolateOpacity());
    } else {
      interp.animationId = null;
      interp.current = interp.target;
    }
  }
  /**
   * Check if a point is inside a polygon using ray casting algorithm
   */
  isPointInPolygon(point, polygon) {
    const x2 = point.x;
    const y = point.y;
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0];
      const yi = polygon[i][1];
      const xj = polygon[j][0];
      const yj = polygon[j][1];
      const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  /**
   * Calculate minimum distance from point to polygon edge
   */
  calculateDistanceToPolygon(point, polygon) {
    let minDistance = Infinity;
    for (let i = 0; i < polygon.length; i++) {
      const j = (i + 1) % polygon.length;
      const distance = this.distanceToLineSegment(
        point,
        { x: polygon[i][0], y: polygon[i][1] },
        { x: polygon[j][0], y: polygon[j][1] }
      );
      minDistance = Math.min(minDistance, distance);
    }
    return minDistance;
  }
  /**
   * Calculate distance from point to line segment
   */
  distanceToLineSegment(point, lineStart, lineEnd) {
    const dx = lineEnd.x - lineStart.x;
    const dy = lineEnd.y - lineStart.y;
    const lengthSquared = dx * dx + dy * dy;
    if (lengthSquared === 0) {
      return Math.sqrt(
        Math.pow(point.x - lineStart.x, 2) + Math.pow(point.y - lineStart.y, 2)
      );
    }
    let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t));
    const projectionX = lineStart.x + t * dx;
    const projectionY = lineStart.y + t * dy;
    return Math.sqrt(Math.pow(point.x - projectionX, 2) + Math.pow(point.y - projectionY, 2));
  }
  autoDeselect() {
    var _a;
    if (this.state.isManualSelection) {
      console.log("⏸️ Skipping auto-deselect during manual selection");
      return;
    }
    console.log("🔚 [SPOTLIGHT] CSSOverlayManager: Auto-deselecting hotspot", {
      selectedHotspot: ((_a = this.state.selectedHotspot) == null ? void 0 : _a.id) || "none",
      currentOpacity: this.state.opacity
    });
    this.state.opacity = 0;
    this.state.targetOpacity = 0;
    this.overlayElement.style.opacity = "0";
    this.overlayElement.style.display = "none";
    if (this.useClipPath) {
      this.overlayElement.style.clipPath = "";
      this.overlayElement.style.webkitClipPath = "";
    }
    this.state.selectedHotspot = null;
    this.resetFocusTracking();
    this.state.isAutoDeselecting = false;
    this.state.isFadingOut = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.state.isAnimating = false;
    }
    if (window.nativeHotspotRenderer) {
      window.nativeHotspotRenderer.instantDeselect();
      if (window.nativeHotspotRenderer.eventCoordinator) {
        console.log("🔄 CSSOverlayManager: Ensuring drag state reset after auto-deselect");
        window.nativeHotspotRenderer.eventCoordinator.resetDragState();
      }
    }
    if (window.artworkViewerHandleHotspotClick) {
      window.artworkViewerHandleHotspotClick(null);
    }
  }
  clearSelection() {
    this.selectHotspot(null);
    if (this.useClipPath && this.overlayElement) {
      this.overlayElement.style.clipPath = "";
      this.overlayElement.style.webkitClipPath = "";
    }
  }
  startAnimation() {
    if (this.state.isAnimating) return;
    this.state.isAnimating = true;
    this.animate();
  }
  animate() {
    const now = performance.now();
    if (now - this.lastUpdateTime < this.config.updateThrottle) {
      this.animationFrame = requestAnimationFrame(this.animate);
      return;
    }
    this.lastUpdateTime = now;
    const opacityDiff = this.state.targetOpacity - this.state.opacity;
    const fadeSpeed = this.state.isAutoDeselecting ? this.config.fadeSpeedAutoDeselect : this.config.fadeSpeed;
    if (Math.abs(opacityDiff) > 0.01) {
      this.state.opacity += opacityDiff * fadeSpeed;
    } else {
      this.state.opacity = this.state.targetOpacity;
    }
    if (this.state.targetOpacity === 0 && this.state.opacity > 0) {
      this.updateSpotlightPosition();
    }
    const posXDiff = this.state.targetPosition.x - this.state.currentPosition.x;
    const posYDiff = this.state.targetPosition.y - this.state.currentPosition.y;
    if (Math.abs(posXDiff) > 0.1 || Math.abs(posYDiff) > 0.1) {
      this.state.currentPosition.x += posXDiff * this.config.positionSpeed;
      this.state.currentPosition.y += posYDiff * this.config.positionSpeed;
    } else {
      this.state.currentPosition = { ...this.state.targetPosition };
    }
    const radiusDiff = this.state.targetRadius - this.state.currentRadius;
    if (Math.abs(radiusDiff) > 1) {
      this.state.currentRadius += radiusDiff * this.config.radiusSpeed;
    } else {
      this.state.currentRadius = this.state.targetRadius;
    }
    this.applySpotlightStyles();
    const isComplete = Math.abs(opacityDiff) <= 0.01 && Math.abs(posXDiff) <= 0.1 && Math.abs(posYDiff) <= 0.1 && Math.abs(radiusDiff) <= 1;
    if (isComplete && this.state.opacity === 0 && !this.state.selectedHotspot) {
      this.state.isAnimating = false;
      this.state.isAutoDeselecting = false;
      this.overlayElement.style.display = "none";
    } else {
      this.animationFrame = requestAnimationFrame(this.animate);
    }
  }
  applySpotlightStyles() {
    if (!this.overlayElement) return;
    if (this.state.opacity > 0 && this.overlayElement.style.display === "none") {
      this.overlayElement.style.display = "block";
    }
    const focusScore = this.state.selectedHotspot ? this.calculateFocusScore() : 1;
    const adjustedOpacity = this.state.opacity * focusScore;
    this.overlayElement.style.opacity = adjustedOpacity;
    this.overlayElement.style.transform = "translateZ(0)";
    if (adjustedOpacity === 0 && !this.state.selectedHotspot) {
      this.overlayElement.style.display = "none";
    }
  }
  getHotspotBounds(hotspot) {
    if (!hotspot.coordinates) return null;
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    const processPoints = (points) => {
      points.forEach(([x2, y]) => {
        minX = Math.min(minX, x2);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x2);
        maxY = Math.max(maxY, y);
      });
    };
    if (hotspot.shape === "polygon") {
      processPoints(hotspot.coordinates);
    } else if (hotspot.shape === "multipolygon") {
      hotspot.coordinates.forEach((polygon) => processPoints(polygon));
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }
  /**
   * Calculate intelligent polygon expansion based on shape characteristics
   */
  calculateAdaptivePolygonExpansion(coords) {
    const metrics = this.calculatePolygonMetrics(coords);
    this.calculateZunicRosinConvexity(coords);
    const roughness = this.calculateDiscreteRoughness(coords);
    let compositeScore = 0;
    if (roughness.maxCurvature > 10) {
      compositeScore = Math.max(compositeScore, 0.5);
    }
    if (metrics.aspectRatio > 3 || metrics.aspectRatio < 0.33) {
      compositeScore = Math.max(compositeScore, 0.4);
    }
    const expansionFactor = 1 + compositeScore * 0.1;
    return expansionFactor;
  }
  /**
   * Debug method to log expansion metrics
   */
  logExpansionMetrics(hotspotId) {
    if (this.lastExpansionMetrics) {
      console.log(`Expansion metrics for hotspot ${hotspotId}:`, this.lastExpansionMetrics);
    }
  }
  /**
   * Expand polygon by a factor from its centroid
   */
  expandPolygon(coords, factor) {
    const bounds = this.getHotspotBoundsFromCoords(coords);
    const centerX = bounds.centerX;
    const centerY = bounds.centerY;
    return coords.map(([x2, y]) => {
      const dx = x2 - centerX;
      const dy = y - centerY;
      return [centerX + dx * factor, centerY + dy * factor];
    });
  }
  resetFocusTracking() {
    this.focusTracking = {
      referenceZoom: null,
      referenceCenter: null,
      hotspotCenter: null,
      selectionTime: null,
      lastCalculation: 0,
      throttleInterval: 16
    };
  }
  // Compatibility methods for seamless replacement
  prepareForZoom() {
  }
  endZoom() {
    if (this.state.selectedHotspot) {
      this.updateSpotlightPosition();
    }
  }
  /**
   * Reset overlay state after cinematic zoom (compatibility method)
   * Not needed for CSSOverlayManager but added for interface consistency
   */
  resetAnimationState() {
    console.log("🔄 CSSOverlayManager: Animation state reset (no-op)");
  }
  destroy() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    if (this.viewer) {
      this.viewer.removeAllHandlers("viewport-change");
      this.viewer.removeAllHandlers("zoom");
      this.viewer.removeAllHandlers("animation-finish");
      this.viewer.removeAllHandlers("pan");
    }
    if (this.overlayElement && this.overlayElement.parentNode) {
      this.overlayElement.parentNode.removeChild(this.overlayElement);
    }
    if (this.useClipPath && this.overlayElement) {
      this.overlayElement.style.clipPath = "";
      this.overlayElement.style.webkitClipPath = "";
    }
    this.overlayElement = null;
    this.viewer = null;
    this.isInitialized = false;
  }
}
const DEBUG_ENABLED = typeof window !== "undefined" && (window.DEBUG || localStorage.getItem("debugLevel") === "1" || new URLSearchParams(window.location.search).has("debug"));
const LogLevel$1 = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};
let currentLogLevel = LogLevel$1.WARN;
let Logger$1 = class Logger {
  constructor(prefix = "") {
    this.prefix = prefix;
  }
  _shouldLog(level) {
    return DEBUG_ENABLED && level >= currentLogLevel;
  }
  _formatMessage(message, ...args) {
    (/* @__PURE__ */ new Date()).toISOString();
    const prefixStr = this.prefix ? `[${this.prefix}] ` : "";
    return [`${prefixStr}${message}`, ...args];
  }
  debug(message, ...args) {
    if (this._shouldLog(LogLevel$1.DEBUG)) {
      console.log(...this._formatMessage(message, ...args));
    }
  }
  info(message, ...args) {
    if (this._shouldLog(LogLevel$1.INFO)) {
      console.info(...this._formatMessage(message, ...args));
    }
  }
  warn(message, ...args) {
    if (this._shouldLog(LogLevel$1.WARN)) {
      console.warn(...this._formatMessage(message, ...args));
    }
  }
  error(message, ...args) {
    if (this._shouldLog(LogLevel$1.ERROR)) {
      console.error(...this._formatMessage(message, ...args));
    }
  }
  // Special method for performance-critical paths
  perf(message, ...args) {
    if (DEBUG_ENABLED && window.DEBUG_PERFORMANCE) {
      console.log(`[PERF] ${this.prefix ? `[${this.prefix}] ` : ""}${message}`, ...args);
    }
  }
  // Create a child logger with additional prefix
  child(childPrefix) {
    const newPrefix = this.prefix ? `${this.prefix}:${childPrefix}` : childPrefix;
    return new Logger(newPrefix);
  }
};
function createLogger(prefix) {
  return new Logger$1(prefix);
}
class PerformanceDiagnostics {
  constructor() {
    this.metrics = {
      frame: { count: 0, slow: 0, verySllow: 0 },
      cinematic: { active: false, startTime: 0, framesDuring: 0 },
      systems: /* @__PURE__ */ new Map(),
      // Track time by system
      lastReport: 0
    };
    this.config = {
      slowFrameThreshold: 20,
      // >20ms = below 50 FPS
      verySlowThreshold: 33,
      // >33ms = below 30 FPS
      reportInterval: 5e3,
      // Report every 5 seconds
      minReportableTime: 1
      // Only report systems taking >1ms
    };
    this.frameStartTime = 0;
    this.currentFrame = {};
  }
  startFrame() {
    this.frameStartTime = performance.now();
    this.currentFrame = {};
    this.metrics.frame.count++;
  }
  measureSystem(systemName, fn) {
    const start = performance.now();
    const result = fn();
    const duration = performance.now() - start;
    this.currentFrame[systemName] = duration;
    if (!this.metrics.systems.has(systemName)) {
      this.metrics.systems.set(systemName, { total: 0, count: 0, max: 0 });
    }
    const systemMetrics = this.metrics.systems.get(systemName);
    systemMetrics.total += duration;
    systemMetrics.count++;
    systemMetrics.max = Math.max(systemMetrics.max, duration);
    return result;
  }
  endFrame() {
    if (!this.frameStartTime) return;
    const frameTime = performance.now() - this.frameStartTime;
    if (frameTime > this.config.verySlowThreshold) {
      this.metrics.frame.verySllow++;
      this.logSlowFrame(frameTime);
    } else if (frameTime > this.config.slowFrameThreshold) {
      this.metrics.frame.slow++;
    }
    if (this.metrics.cinematic.active) {
      this.metrics.cinematic.framesDuring++;
    }
    const now = performance.now();
    if (now - this.metrics.lastReport > this.config.reportInterval) {
      this.generateReport();
      this.resetMetrics();
      this.metrics.lastReport = now;
    }
  }
  logSlowFrame(frameTime) {
    const systems = Object.entries(this.currentFrame).filter(([_, time]) => time > this.config.minReportableTime).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([name2, time]) => `${name2}:${time.toFixed(1)}ms`).join(" | ");
    console.log(`[SLOW FRAME] ${frameTime.toFixed(1)}ms - ${systems}`);
  }
  setCinematicActive(active) {
    if (active && !this.metrics.cinematic.active) {
      this.metrics.cinematic.active = true;
      this.metrics.cinematic.startTime = performance.now();
      this.metrics.cinematic.framesDuring = 0;
      console.log("[Perf] Cinematic zoom START");
    } else if (!active && this.metrics.cinematic.active) {
      const duration = performance.now() - this.metrics.cinematic.startTime;
      const avgFPS = (this.metrics.cinematic.framesDuring / (duration / 1e3)).toFixed(1);
      console.log(
        `[Perf] Cinematic zoom END - ${avgFPS} FPS avg (${this.metrics.cinematic.framesDuring} frames in ${duration.toFixed(0)}ms)`
      );
      this.metrics.cinematic.active = false;
      this.metrics.cinematic.framesDuring = 0;
    }
  }
  generateReport() {
    if (this.metrics.frame.count === 0) return;
    const totalFrames = this.metrics.frame.count;
    const slowPercent = ((this.metrics.frame.slow + this.metrics.frame.verySllow) / totalFrames * 100).toFixed(1);
    const verySlowPercent = (this.metrics.frame.verySllow / totalFrames * 100).toFixed(1);
    if (this.metrics.frame.slow > 0 || this.metrics.frame.verySllow > 0) {
      const topSystems = Array.from(this.metrics.systems.entries()).map(([name2, data]) => ({
        name: name2,
        avg: data.total / data.count,
        max: data.max
      })).filter((s) => s.avg > this.config.minReportableTime).sort((a, b) => b.avg - a.avg).slice(0, 3);
      const systemsReport = topSystems.map((s) => `${s.name}:${s.avg.toFixed(1)}ms(max:${s.max.toFixed(1)})`).join(" | ");
      console.log(
        `[Perf Report] Frames:${totalFrames} Slow:${slowPercent}% VerySlow:${verySlowPercent}% | Top: ${systemsReport}`
      );
    }
  }
  resetMetrics() {
    this.metrics.frame = { count: 0, slow: 0, verySllow: 0 };
    this.metrics.systems.clear();
  }
}
const performanceDiagnostics = new PerformanceDiagnostics();
const logger$1 = createLogger("Canvas2DOverlay");
class RenderProfiler {
  constructor() {
    this.metrics = {
      transform: [],
      polygonDraw: [],
      total: []
    };
    this.frameCount = 0;
  }
  measure(section, fn) {
    const start = performance.now();
    const result = fn();
    const duration = performance.now() - start;
    if (!this.metrics[section]) this.metrics[section] = [];
    this.metrics[section].push(duration);
    if (++this.frameCount % 60 === 0) {
      this.logAverages();
    }
    return result;
  }
  logAverages() {
    const avgs = {};
    let totalTime = 0;
    for (const [key, values] of Object.entries(this.metrics)) {
      if (values.length > 0) {
        const avg = values.reduce((a, b) => a + b) / values.length;
        avgs[key] = avg.toFixed(2);
        totalTime += avg;
        this.metrics[key] = [];
      }
    }
    if (totalTime > 5) {
      console.log(
        `[Canvas2D Perf] Total: ${totalTime.toFixed(1)}ms | Transform: ${avgs.transform || 0}ms | Draw: ${avgs.polygonDraw || 0}ms`
      );
    }
  }
}
class Canvas2DOverlayManager {
  constructor(viewer) {
    this.viewer = viewer;
    this.canvas = null;
    this.context = null;
    this.isInitialized = false;
    this.isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || "ontouchstart" in window;
    this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    this.maskCache = /* @__PURE__ */ new Map();
    this.transformCache = /* @__PURE__ */ new Map();
    this.state = {
      selectedHotspot: null,
      currentOpacity: 0,
      targetOpacity: 0,
      isAnimating: false,
      selectionZoom: null,
      // Track zoom level when hotspot was selected
      selectionBounds: null,
      // Track viewport bounds when hotspot was selected
      selectionScale: null,
      // Track scale when hotspot was selected
      autoDeselectThreshold: 0.3,
      // Deselect when zoom drops to 30% of selection zoom
      selectionCenter: null,
      // Track the center point when hotspot was selected
      panThreshold: 0.02,
      // Deselect when panned away by 2% of viewport (matching CSSOverlayManager)
      isCinematicZooming: false,
      // Track if we're in cinematic zoom
      lastPinchZoom: null,
      // Track last zoom level during pinch gesture
      lastLoggedZoom: 0,
      // For debug logging
      lastLoggedScale: 0,
      // For debug logging with scale
      isPinching: false,
      // Track if currently pinching
      cinematicZoomCompleted: false,
      // Track if cinematic zoom has completed
      debugInfo: null
      // Visual debug information
    };
    this.config = {
      maxOpacity: 0.7,
      fadeSpeed: 0.25,
      // Increased from 0.15 for more responsive transitions
      fadeSpeedQuickClose: 0.4,
      // Even faster for manual deselection
      updateThrottle: 16,
      // 60 FPS target (was 33ms = 30 FPS)
      maxVerticesMobile: 50,
      simplificationTolerance: 2,
      devicePixelRatioMax: 2,
      smoothingFactor: 0.8,
      // Interpolation smoothing (0.1 = very smooth, 1.0 = instant)
      positionSmoothingMultiplier: 1,
      // Position smoothing relative to base
      zoomSmoothingMultiplier: 0.9,
      // Zoom smoothing relative to base (slightly slower)
      useInterpolation: true
      // Toggle for interpolation system
    };
    logger$1.debug("Constructor - auto-deselect threshold:", this.state.autoDeselectThreshold);
    this.frameCount = 0;
    this.lastFrameTime = 0;
    this.frameHistory = [];
    this.animationFrame = null;
    this.lastUpdateTime = 0;
    this.animate = this.animate.bind(this);
    this.redraw = this.redraw.bind(this);
    this.handleViewportChange = this.handleViewportChange.bind(this);
    this.magneticInkAnimator = null;
    this.profiler = new RenderProfiler();
    this.diagnostics = {
      frameStartTime: 0,
      cinematicActive: false,
      lastLogTime: 0,
      slowFrames: 0,
      totalFrames: 0
    };
    this.renderingPaused = false;
  }
  initialize() {
    if (this.isInitialized) return;
    logger$1.debug("Initializing...");
    logger$1.debug("Auto-deselect feature enabled, threshold:", this.state.autoDeselectThreshold);
    this.canvas = document.createElement("canvas");
    this.canvas.className = "canvas2d-spotlight-overlay";
    Object.assign(this.canvas.style, {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      pointerEvents: "none",
      zIndex: "9999",
      opacity: "0",
      transform: "translateZ(0)",
      willChange: "opacity"
    });
    this.context = this.canvas.getContext("2d", {
      alpha: true,
      desynchronized: false,
      // Keep synchronized
      willReadFrequently: false
    });
    this.resize();
    const container = this.viewer.container;
    container.appendChild(this.canvas);
    container.classList.add("canvas2d-active");
    logger$1.debug("Canvas added to container");
    this.setupEventListeners();
    this.isInitialized = true;
    logger$1.debug("Initialized successfully");
  }
  setupEventListeners() {
    let isAnimating = false;
    this.viewer.addHandler("animation-start", () => {
      isAnimating = true;
    });
    this.viewer.addHandler("animation-finish", () => {
      isAnimating = false;
      if (this.state.isCinematicZooming && this.state.selectedHotspot) {
        logger$1.debug("Animation finished, checking if cinematic zoom completed...");
        setTimeout(() => {
          if (this.state.isCinematicZooming) {
            logger$1.debug("Auto-completing cinematic zoom (mobile fallback)");
            this.updateSelectionZoom();
          }
        }, 150);
      }
    });
    this.updateHandler = () => {
      if (!this.state.selectedHotspot) return;
      const currentZoom = this.viewer.viewport.getZoom();
      if (!isAnimating && this.state.cinematicZoomCompleted && this.state.selectionZoom) {
        if (currentZoom < this.state.selectionZoom) {
          logger$1.debug(
            `Zooming out from ${this.state.selectionZoom.toFixed(2)} to ${currentZoom.toFixed(2)}`
          );
        }
      }
      let zoomOpacity = 1;
      let panOpacity = 1;
      const referenceZoom = this.state.selectionZoom || this.state.startingZoom;
      this.state.selectionCenter || this.state.startingCenter;
      const isInsideHotspot = this.isViewportInsideHotspot();
      if (this.state.selectedHotspot) {
        const viewportBounds = this.viewer.viewport.getBounds();
        const containerSize = this.viewer.viewport.getContainerSize();
        const currentScale = containerSize.x / viewportBounds.width;
        const referenceScale = this.state.selectionScale || this.state.startingScale;
        const scaleRatio = referenceScale ? currentScale / referenceScale : 1;
        if (Math.abs(this.state.lastLoggedScale - currentScale) > 1 || !this.state.debugInfo) {
          logger$1.debug(
            `Bounds Debug: scale=${currentScale.toFixed(1)}, ref=${(referenceScale == null ? void 0 : referenceScale.toFixed(1)) || "null"}, ratio=${scaleRatio.toFixed(3)}, bounds.w=${viewportBounds.width.toFixed(3)}`
          );
          this.state.lastLoggedScale = currentScale;
        }
        this.state.debugInfo = {
          scale: currentScale,
          refScale: referenceScale || 0,
          ratio: scaleRatio,
          opacity: 0,
          // Will be updated below
          bounds: viewportBounds.width
        };
        const START_FADE = 0.85;
        const END_FADE = 0.4;
        if (scaleRatio >= START_FADE) {
          zoomOpacity = 1;
        } else if (scaleRatio <= END_FADE) {
          zoomOpacity = 0;
        } else {
          const normalized = (scaleRatio - END_FADE) / (START_FADE - END_FADE);
          zoomOpacity = Math.pow(normalized, 2);
        }
        if (this.state.debugInfo) {
          this.state.debugInfo.opacity = zoomOpacity;
        }
      }
      if (this.state.selectedHotspot && !this.state.isCinematicZooming && this.state.cinematicZoomCompleted) {
        if (isInsideHotspot) {
          panOpacity = 1;
          logger$1.debug("Inside hotspot polygon - maintaining 100% opacity");
        } else {
          const currentCenter = this.viewer.viewport.getCenter();
          const imagePt = this.viewer.viewport.viewportToImageCoordinates(currentCenter);
          const coords = this.state.selectedHotspot.shape === "polygon" ? this.state.selectedHotspot.coordinates : this.state.selectedHotspot.coordinates[0];
          const distanceToEdge = this.calculateDistanceToPolygon(
            { x: imagePt.x, y: imagePt.y },
            coords
          );
          const imageSize = this.viewer.world.getItemAt(0).getContentSize();
          const distanceInViewport = distanceToEdge / imageSize.x;
          const EDGE_FADE_START = 0;
          const EDGE_FADE_END = 0.015;
          if (distanceInViewport <= EDGE_FADE_START) {
            panOpacity = 1;
          } else if (distanceInViewport >= EDGE_FADE_END) {
            panOpacity = 0;
          } else {
            const normalized = distanceInViewport / EDGE_FADE_END;
            panOpacity = 1 - Math.pow(normalized, 1.8);
            logger$1.debug(
              `Outside polygon - distance: ${(distanceInViewport * 100).toFixed(2)}%, opacity: ${(panOpacity * 100).toFixed(0)}%`
            );
          }
        }
      }
      const targetOpacity = Math.min(zoomOpacity, panOpacity);
      if (this.state.selectedHotspot && Math.abs(this.state.targetOpacity - targetOpacity) > 0.01) {
        const currentZoom2 = this.viewer.viewport.getZoom();
        const zoomRatio = referenceZoom ? currentZoom2 / referenceZoom : 1;
        const fadePhase = zoomRatio >= 0.95 ? " (full)" : zoomRatio <= 0.5 ? " (hidden)" : ` (fading ${((1 - zoomOpacity) * 100).toFixed(0)}%)`;
        const panStatus = panOpacity === 1 ? "" : panOpacity === 0 ? " PAN:hidden" : ` PAN:${(panOpacity * 100).toFixed(0)}%`;
        logger$1.debug(
          `Fade: zoomRatio=${zoomRatio.toFixed(3)}${fadePhase}, zoom=${zoomOpacity.toFixed(3)}, pan=${panOpacity.toFixed(3)}${panStatus}, target=${targetOpacity.toFixed(3)}`
        );
      }
      if (Math.abs(this.state.targetOpacity - targetOpacity) > 1e-3) {
        this.state.targetOpacity = targetOpacity;
        this.startAnimation();
        const autoDeselectThreshold = 0.02;
        if (targetOpacity < autoDeselectThreshold && this.state.selectedHotspot && !this.state.isCinematicZooming) {
          logger$1.debug(
            `Auto-deselecting - opacity ${targetOpacity.toFixed(3)} below threshold ${autoDeselectThreshold}`
          );
          this.forceCompleteRemoval();
          this.autoDeselect();
          return;
        }
        if (this.state.isCinematicZooming) {
          logger$1.debug(
            `Cinematic zoom progress - currentZoom: ${this.viewer.viewport.getZoom().toFixed(2)}, targetOpacity: ${targetOpacity.toFixed(2)}`
          );
        } else if (!this.state.previousInsideState !== isInsideHotspot) {
          logger$1.debug(
            `Viewport ${isInsideHotspot ? "INSIDE" : "OUTSIDE"} hotspot, opacity: ${targetOpacity.toFixed(2)}`
          );
          this.state.previousInsideState = isInsideHotspot;
        }
      }
      this.redrawSynchronized();
    };
    this.viewer.addHandler("update-viewport", this.updateHandler);
    this.viewer.addHandler("resize", () => {
      this.resize();
      if (this.state.selectedHotspot) {
        this.redrawSynchronized();
      }
    });
    this.resizeHandler = () => this.resize();
    window.addEventListener("resize", this.resizeHandler);
  }
  resize() {
    if (!this.canvas) return;
    const rect = this.viewer.container.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, this.config.devicePixelRatioMax);
    this.canvas.width = Math.round(rect.width * dpr);
    this.canvas.height = Math.round(rect.height * dpr);
    this.canvas.style.width = `${Math.round(rect.width)}px`;
    this.canvas.style.height = `${Math.round(rect.height)}px`;
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.scale(dpr, dpr);
    this.transformCache.clear();
    logger$1.debug(`Resized to ${rect.width}x${rect.height} (DPR: ${dpr})`);
  }
  /**
   * Create debug overlay for BrowserStack testing
   */
  createDebugOverlay() {
    if (!this.isMobile) return;
    if (!this.debugDiv) {
      this.debugDiv = document.createElement("div");
      this.debugDiv.id = "canvas2d-debug-overlay";
      this.debugDiv.style.cssText = `
                position: fixed;
                top: 10px;
                left: 10px;
                background: rgba(255, 255, 255, 0.95);
                border: 2px solid #000;
                padding: 10px;
                z-index: 10000;
                font-family: monospace;
                font-size: 12px;
                color: #000;
                min-width: 200px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                border-radius: 5px;
                pointer-events: none;
            `;
      document.body.appendChild(this.debugDiv);
      logger$1.debug("Debug overlay created for mobile testing");
    }
  }
  /**
   * Update debug overlay with current values
   */
  updateDebugOverlay() {
    if (!this.debugDiv || !this.state.selectedHotspot) return;
    const viewportBounds = this.viewer.viewport.getBounds();
    const containerSize = this.viewer.viewport.getContainerSize();
    const currentScale = containerSize.x / viewportBounds.width;
    const currentZoom = this.viewer.viewport.getZoom();
    const referenceScale = this.state.selectionScale || currentScale;
    const scaleRatio = currentScale / referenceScale;
    let opacity = 1;
    if (scaleRatio >= 0.85) {
      opacity = 1;
    } else if (scaleRatio <= 0.4) {
      opacity = 0;
    } else {
      const normalized = (scaleRatio - 0.4) / (0.85 - 0.4);
      opacity = Math.pow(normalized, 2);
    }
    const cinematicStatus = this.state.isCinematicZooming ? "⏳ IN PROGRESS" : this.state.cinematicZoomCompleted ? "✅ COMPLETED" : "❌ NOT STARTED";
    const refScaleStatus = !referenceScale ? "⚠️ WAITING" : referenceScale === this.state.startingScale ? "📍 USING START" : referenceScale === this.state.selectionScale ? "🎯 USING SELECTION" : "❓ UNKNOWN";
    this.debugDiv.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px; color: blue;">Canvas2D Debug</div>
            <div><b>Current:</b> ${currentScale.toFixed(1)}</div>
            <div><b>Reference:</b> ${referenceScale ? referenceScale.toFixed(1) : "NOT SET"} ${refScaleStatus}</div>
            <div style="font-size: 10px;">Start: ${this.state.startingScale ? this.state.startingScale.toFixed(1) : "null"} | Sel: ${this.state.selectionScale ? this.state.selectionScale.toFixed(1) : "null"}</div>
            <div style="color: ${scaleRatio !== 1 ? "green" : "red"}; font-weight: bold;">Ratio: ${scaleRatio.toFixed(3)}</div>
            <div style="color: ${opacity < 1 ? "blue" : "black"};">Opacity: ${opacity.toFixed(2)}</div>
            <div style="font-size: 10px;">Zoom: ${currentZoom.toFixed(2)} | Bounds: ${viewportBounds.width.toFixed(3)}</div>
            <div style="margin-top: 3px; padding-top: 3px; border-top: 1px solid #ccc;">
                <div>Cinematic: ${cinematicStatus}</div>
            </div>
            <div style="margin-top: 3px; padding-top: 3px; border-top: 1px solid #ccc;">
                ${scaleRatio >= 0.85 ? "🟢 FULL" : scaleRatio <= 0.4 ? "⚫ HIDDEN" : "🟡 FADING"}
            </div>
        `;
  }
  /**
   * Select a hotspot for spotlight effect
   */
  selectHotspot(hotspot) {
    var _a, _b, _c, _d;
    logger$1.debug("selectHotspot called", {
      newHotspotId: (hotspot == null ? void 0 : hotspot.id) || "null",
      currentHotspotId: ((_a = this.state.selectedHotspot) == null ? void 0 : _a.id) || "null",
      isInitialized: this.isInitialized,
      canvasExists: !!this.canvas,
      contextExists: !!this.context,
      canvasDisplay: (_c = (_b = this.canvas) == null ? void 0 : _b.style) == null ? void 0 : _c.display,
      timestamp: Date.now()
    });
    if (((_d = this.state.selectedHotspot) == null ? void 0 : _d.id) === (hotspot == null ? void 0 : hotspot.id)) {
      const hotspotGroup = document.querySelector(`g[data-hotspot-id="${hotspot.id}"]`);
      if (hotspotGroup) {
        hotspotGroup.classList.remove("hotspot-echo-reveal");
        hotspotGroup.classList.remove(
          "border-gradient",
          "border-double",
          "border-emboss",
          "border-pulse",
          "border-neumorphic",
          "border-recessed",
          "border-pigment"
        );
        const paths = hotspotGroup.querySelectorAll("path, polygon, polyline");
        paths.forEach((path) => {
          path.style.stroke = "";
          path.style.strokeWidth = "";
          path.style.strokeOpacity = "";
          path.style.strokeDasharray = "";
          path.style.strokeDashoffset = "";
          path.style.filter = "";
          path.style.animation = "";
          path.style.animationDelay = "";
          path.removeAttribute("stroke");
          path.removeAttribute("stroke-width");
          path.removeAttribute("stroke-opacity");
          path.removeAttribute("stroke-dasharray");
          path.removeAttribute("stroke-dashoffset");
          path.removeAttribute("filter");
        });
        hotspotGroup.style.removeProperty("--zoom-factor");
        hotspotGroup.style.animation = "";
        hotspotGroup.style.animationDelay = "";
        requestAnimationFrame(() => {
          void hotspotGroup.offsetHeight;
          requestAnimationFrame(() => {
            logger$1.debug(
              `✅ [iOS FIX] Border classes + inline styles removed for hotspot ${hotspot.id}`
            );
          });
        });
      } else {
        logger$1.warn(`⚠️ [iOS FIX] Could not find SVG group for hotspot ${hotspot.id}`);
      }
      if (this.canvas && this.canvas.style.display === "none") {
        logger$1.warn("Same hotspot but canvas is hidden, reinitializing spotlight");
      } else {
        logger$1.warn("Same hotspot already selected and visible, skipping");
        return;
      }
    }
    if (!this.isInitialized) {
      logger$1.error("Not initialized! Initializing now...");
      this.initialize();
    }
    logger$1.debug("Selecting hotspot", (hotspot == null ? void 0 : hotspot.id) || "null");
    this.state.selectedHotspot = hotspot;
    if (hotspot) {
      const currentZoom = this.viewer.viewport.getZoom();
      const currentCenter = this.viewer.viewport.getCenter();
      const currentBounds = this.viewer.viewport.getBounds();
      const containerSize = this.viewer.viewport.getContainerSize();
      const currentScale = containerSize.x / currentBounds.width;
      this.state.startingZoom = currentZoom;
      this.state.startingCenter = currentCenter;
      this.state.startingScale = currentScale;
      this.state.selectionZoom = null;
      this.state.selectionBounds = null;
      this.state.selectionScale = null;
      this.state.selectionCenter = null;
      this.state.isCinematicZooming = true;
      this.state.cinematicZoomCompleted = false;
      performanceDiagnostics.setCinematicActive(true);
      this.state.isPinching = false;
      this.state.lastPinchZoom = currentZoom;
      logger$1.debug(
        `Starting cinematic zoom from zoom=${currentZoom.toFixed(2)}, scale=${currentScale.toFixed(1)}`
      );
      if (this.cinematicTimeout) {
        clearTimeout(this.cinematicTimeout);
      }
      this.cinematicTimeout = setTimeout(() => {
        if (this.state.isCinematicZooming && this.state.selectedHotspot) {
          logger$1.debug("Cinematic zoom timeout - forcing completion (mobile safety)");
          this.updateSelectionZoom();
        }
      }, 2e3);
      if (!this.maskCache.has(hotspot.id)) {
        this.preRenderMask(hotspot);
      }
      this.state.currentOpacity = 0;
      this.state.targetOpacity = 1;
      this.canvas.style.opacity = "1";
      this.canvas.style.display = "block";
      this.startAnimation();
      this.redrawSynchronized();
    } else {
      this.state.targetOpacity = 0;
      this.startAnimation();
    }
  }
  /**
   * Clear the current selection
   */
  clearSelection() {
    logger$1.debug("Clearing selection");
    this.state.selectionZoom = null;
    this.state.selectionCenter = null;
    this.state.isCinematicZooming = false;
    performanceDiagnostics.setCinematicActive(false);
    if (this.canvas) {
      if (this.context) {
        const rect = this.viewer.container.getBoundingClientRect();
        this.context.clearRect(0, 0, rect.width, rect.height);
        const dpr = Math.min(window.devicePixelRatio || 1, this.config.devicePixelRatioMax);
        this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
        this.context.globalCompositeOperation = "source-over";
        this.context.globalAlpha = 1;
      }
      this.canvas.style.display = "none";
      this.state.currentOpacity = 0;
      this.state.targetOpacity = 0;
      this.canvas.style.opacity = "1";
    }
    this.state.selectedHotspot = null;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.state.isAnimating = false;
    }
    const allHotspotGroups = document.querySelectorAll('g[data-canvas2d-selected="true"]');
    allHotspotGroups.forEach((group) => {
      group.removeAttribute("data-canvas2d-selected");
      if (group.style.display === "none") {
        group.style.display = "";
      }
      const mainPath = group.querySelector(".main-path");
      if (mainPath) {
        if (mainPath.style.stroke === "transparent") {
          mainPath.style.stroke = "";
        }
        if (mainPath.style.strokeWidth === "0" || mainPath.style.strokeWidth === "0px") {
          mainPath.style.strokeWidth = "";
        }
        if (mainPath.style.opacity === "0") {
          mainPath.style.opacity = "";
        }
      }
    });
    if (this.onSpotlightCleared) {
      logger$1.debug("🔚 [SPOTLIGHT] Notifying renderer that spotlight has been cleared");
      this.onSpotlightCleared();
    }
  }
  /**
   * Adjust smoothing settings for fine-tuning
   */
  setSmoothingFactor(factor) {
    this.config.smoothingFactor = Math.max(0.1, Math.min(1, factor));
    logger$1.debug(`Smoothing factor set to ${this.config.smoothingFactor}`);
  }
  /**
   * Toggle interpolation system
   */
  setInterpolation(enabled) {
    this.config.useInterpolation = enabled;
    if (!enabled) {
      this.lastTransform = null;
    }
    logger$1.debug(`Interpolation ${enabled ? "enabled" : "disabled"}`);
  }
  /**
   * Set auto-deselect threshold (0-1, where 1 = 100% of selection zoom)
   */
  setAutoDeselectThreshold(threshold) {
    this.state.autoDeselectThreshold = Math.max(0.1, Math.min(1, threshold));
    logger$1.debug(`Auto-deselect threshold set to ${this.state.autoDeselectThreshold}`);
  }
  /**
   * Update selection zoom after cinematic zoom completes
   */
  updateSelectionZoom() {
    if (!this.state.isCinematicZooming || !this.state.selectedHotspot) {
      logger$1.debug("updateSelectionZoom skipped - already completed or no hotspot");
      return;
    }
    if (this.cinematicTimeout) {
      clearTimeout(this.cinematicTimeout);
      this.cinematicTimeout = null;
    }
    const delay = this.isMobile ? 100 : 50;
    setTimeout(() => {
      var _a;
      const stableZoom = this.viewer.viewport.getZoom();
      const stableBounds = this.viewer.viewport.getBounds();
      const containerSize = this.viewer.viewport.getContainerSize();
      const stableScale = containerSize.x / stableBounds.width;
      this.state.selectionZoom = stableZoom;
      this.state.selectionBounds = stableBounds;
      this.state.selectionScale = stableScale;
      this.state.selectionCenter = this.viewer.viewport.getCenter();
      this.state.isCinematicZooming = false;
      this.state.cinematicZoomCompleted = true;
      performanceDiagnostics.setCinematicActive(false);
      this.state.lastPinchZoom = stableZoom;
      logger$1.debug("Stable values captured:");
      logger$1.debug(`  - Zoom: ${stableZoom.toFixed(2)}`);
      logger$1.debug(`  - Scale: ${stableScale.toFixed(1)}`);
      logger$1.debug(`  - Bounds width: ${stableBounds.width.toFixed(3)}`);
      logger$1.debug(
        `  - Previous starting scale: ${((_a = this.state.startingScale) == null ? void 0 : _a.toFixed(1)) || "null"}`
      );
      logger$1.debug(`  - Delay: ${delay}ms`);
      logger$1.debug("Ready for fade on dezoom");
    }, delay);
  }
  /**
   * Auto-deselect when opacity is too low
   */
  autoDeselect() {
    if (!this.state.selectedHotspot) return;
    logger$1.debug("Auto-deselecting hotspot");
    this.clearSelection();
    if (window.nativeHotspotRenderer) {
      window.nativeHotspotRenderer.deselectHotspot();
    }
  }
  /**
   * Force complete removal of all visual artifacts
   */
  forceCompleteRemoval() {
    if (!this.context || !this.canvas) return;
    logger$1.debug("Forcing complete removal of all artifacts");
    const rect = this.viewer.container.getBoundingClientRect();
    this.context.clearRect(0, 0, rect.width, rect.height);
    const dpr = Math.min(window.devicePixelRatio || 1, this.config.devicePixelRatioMax);
    this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
    this.context.globalCompositeOperation = "source-over";
    this.context.globalAlpha = 1;
    this.canvas.style.opacity = "0";
    this.canvas.style.display = "none";
    this.canvas.offsetHeight;
    setTimeout(() => {
      if (this.canvas) {
        this.canvas.style.display = "block";
        this.canvas.style.opacity = "1";
      }
    }, 10);
    this.state.currentOpacity = 0;
    this.state.targetOpacity = 0;
  }
  /**
   * Force recalculation
   */
  forceRecalculation() {
    this.lastTransform = null;
    logger$1.debug("Forced recalculation");
  }
  /**
   * Pre-render a polygon mask for performance
   */
  preRenderMask(hotspot) {
    logger$1.debug(`Pre-rendering mask for hotspot ${hotspot.id}`);
    let coords = hotspot.shape === "polygon" ? hotspot.coordinates : hotspot.coordinates[0];
    if (this.isMobile && coords.length > this.config.maxVerticesMobile) {
      coords = this.simplifyPolygon(coords, this.config.simplificationTolerance);
      logger$1.debug(
        `Simplified polygon from ${hotspot.coordinates.length} to ${coords.length} vertices`
      );
    }
    const bounds = this.getPolygonBounds(coords);
    const maskCanvas = document.createElement("canvas");
    const padding = 0;
    maskCanvas.width = bounds.width + padding * 2;
    maskCanvas.height = bounds.height + padding * 2;
    const maskContext = maskCanvas.getContext("2d");
    maskContext.translate(-bounds.x + padding, -bounds.y + padding);
    maskContext.beginPath();
    maskContext.moveTo(coords[0][0], coords[0][1]);
    for (let i = 1; i < coords.length; i++) {
      maskContext.lineTo(coords[i][0], coords[i][1]);
    }
    maskContext.closePath();
    maskContext.fill();
    this.maskCache.set(hotspot.id, {
      canvas: maskCanvas,
      bounds,
      coords
    });
  }
  /**
   * Simplify polygon using Douglas-Peucker algorithm
   */
  simplifyPolygon(coords, tolerance) {
    if (coords.length <= 3) return coords;
    let maxDist = 0;
    let maxIndex = 0;
    const n = coords.length;
    for (let i = 1; i < n - 1; i++) {
      const dist = this.perpendicularDistance(coords[i], coords[0], coords[n - 1]);
      if (dist > maxDist) {
        maxDist = dist;
        maxIndex = i;
      }
    }
    if (maxDist > tolerance) {
      const left = this.simplifyPolygon(coords.slice(0, maxIndex + 1), tolerance);
      const right = this.simplifyPolygon(coords.slice(maxIndex), tolerance);
      return [...left.slice(0, -1), ...right];
    } else {
      return [coords[0], coords[n - 1]];
    }
  }
  /**
   * Check if the viewport center is inside the selected hotspot
   */
  isViewportInsideHotspot() {
    if (!this.state.selectedHotspot) return false;
    const viewportCenter = this.viewer.viewport.getCenter();
    const imagePoint = this.viewer.viewport.viewportToImageCoordinates(viewportCenter);
    const coords = this.state.selectedHotspot.shape === "polygon" ? this.state.selectedHotspot.coordinates : this.state.selectedHotspot.coordinates[0];
    return this.pointInPolygon(imagePoint.x, imagePoint.y, coords);
  }
  /**
   * Calculate minimum distance from point to polygon edge
   */
  calculateDistanceToPolygon(point, polygon) {
    let minDistance = Infinity;
    for (let i = 0; i < polygon.length; i++) {
      const j = (i + 1) % polygon.length;
      const distance = this.distanceToLineSegment(
        point,
        { x: polygon[i][0], y: polygon[i][1] },
        { x: polygon[j][0], y: polygon[j][1] }
      );
      minDistance = Math.min(minDistance, distance);
    }
    return minDistance;
  }
  /**
   * Calculate distance from point to line segment
   */
  distanceToLineSegment(point, lineStart, lineEnd) {
    const dx = lineEnd.x - lineStart.x;
    const dy = lineEnd.y - lineStart.y;
    const lengthSquared = dx * dx + dy * dy;
    if (lengthSquared === 0) {
      return Math.sqrt(
        Math.pow(point.x - lineStart.x, 2) + Math.pow(point.y - lineStart.y, 2)
      );
    }
    let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t));
    const projectionX = lineStart.x + t * dx;
    const projectionY = lineStart.y + t * dy;
    return Math.sqrt(Math.pow(point.x - projectionX, 2) + Math.pow(point.y - projectionY, 2));
  }
  /**
   * Check if a point is inside a polygon using ray casting algorithm
   */
  pointInPolygon(x2, y, coords) {
    let inside = false;
    for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
      const xi = coords[i][0], yi = coords[i][1];
      const xj = coords[j][0], yj = coords[j][1];
      const intersect = yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  /**
   * Easing function for smooth transitions
   */
  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }
  /**
   * Calculate perpendicular distance from point to line
   */
  perpendicularDistance(point, lineStart, lineEnd) {
    const dx = lineEnd[0] - lineStart[0];
    const dy = lineEnd[1] - lineStart[1];
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) {
      return Math.sqrt(
        Math.pow(point[0] - lineStart[0], 2) + Math.pow(point[1] - lineStart[1], 2)
      );
    }
    const u = ((point[0] - lineStart[0]) * dx + (point[1] - lineStart[1]) * dy) / (mag * mag);
    const closestPoint = [lineStart[0] + u * dx, lineStart[1] + u * dy];
    return Math.sqrt(
      Math.pow(point[0] - closestPoint[0], 2) + Math.pow(point[1] - closestPoint[1], 2)
    );
  }
  /**
   * Get polygon bounds
   */
  getPolygonBounds(coords) {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    coords.forEach(([x2, y]) => {
      minX = Math.min(minX, x2);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x2);
      maxY = Math.max(maxY, y);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }
  /**
   * Pause rendering for performance optimization (e.g., during animations)
   */
  pauseRendering() {
    this.renderingPaused = true;
    logger$1.debug("⏸️  Rendering paused for animation");
  }
  /**
   * Resume rendering after animation completes
   */
  resumeRendering() {
    this.renderingPaused = false;
    logger$1.debug("▶️  Rendering resumed after animation");
    if (this.state.selectedHotspot) {
      this.redrawSynchronized();
    }
  }
  /**
   * Redraw synchronized with OpenSeadragon's viewport
   */
  redrawSynchronized() {
    if (this.renderingPaused) {
      return;
    }
    performanceDiagnostics.startFrame();
    performance.now();
    this.diagnostics.totalFrames++;
    if (!this.context) {
      logger$1.error("No context available for redraw!");
      if (!this.isInitialized) {
        logger$1.error("Manager not initialized, initializing now...");
        this.initialize();
      }
      return;
    }
    if (!this.state.selectedHotspot) {
      logger$1.warn("No selected hotspot for redraw");
      return;
    }
    const maskData = this.maskCache.get(this.state.selectedHotspot.id);
    if (!maskData) {
      logger$1.error("No mask data cached for hotspot:", this.state.selectedHotspot.id);
      this.preRenderMask(this.state.selectedHotspot);
      return;
    }
    const rect = this.viewer.container.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, this.config.devicePixelRatioMax);
    this.context.clearRect(0, 0, rect.width, rect.height);
    this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
    this.context.globalCompositeOperation = "source-over";
    this.context.globalAlpha = 1;
    const screenCoords = performanceDiagnostics.measureSystem("Canvas2D.transform", () => {
      return this.transformCoordinatesPrecise(maskData.coords);
    });
    const shrinkFactor = 0.99;
    const centerX = screenCoords.reduce((sum, coord) => sum + coord[0], 0) / screenCoords.length;
    const centerY = screenCoords.reduce((sum, coord) => sum + coord[1], 0) / screenCoords.length;
    const shrunkCoords = screenCoords.map((coord) => {
      const dx = coord[0] - centerX;
      const dy = coord[1] - centerY;
      return [
        centerX + dx * shrinkFactor | 0,
        // Integer coordinates for performance
        centerY + dy * shrinkFactor | 0
        // Integer coordinates for performance
      ];
    });
    const fillOpacity = this.state.currentOpacity * this.config.maxOpacity;
    performanceDiagnostics.measureSystem("Canvas2D.draw", () => {
      this.context.save();
      this.context.beginPath();
      this.context.rect(0, 0, rect.width, rect.height);
      this.context.moveTo(shrunkCoords[0][0], shrunkCoords[0][1]);
      for (let i = 1; i < shrunkCoords.length; i++) {
        this.context.lineTo(shrunkCoords[i][0], shrunkCoords[i][1]);
      }
      this.context.closePath();
      this.context.fillStyle = `rgba(0, 0, 0, ${fillOpacity})`;
      this.context.fill("evenodd");
      this.context.restore();
    });
    performanceDiagnostics.endFrame();
  }
  /**
   * Transform coordinates with precise viewport-to-window mapping
   */
  transformCoordinatesPrecise(coords) {
    const viewport = this.viewer.viewport;
    const coordCount = coords.length;
    const start = coordCount > 50 ? performance.now() : 0;
    try {
      if (!viewport.contentSize) {
        return coords.map(([x2, y]) => {
          const imagePoint = new OpenSeadragon.Point(x2, y);
          const viewportPoint = viewport.imageToViewportCoordinates(imagePoint);
          const windowPoint = viewport.viewportToWindowCoordinates(viewportPoint);
          return [windowPoint.x | 0, windowPoint.y | 0];
        });
      }
      const imageWidth = viewport.contentSize.x;
      const bounds = viewport.getBounds();
      const scale = viewport.getContainerSize().x / bounds.width;
      const offsetX = -bounds.x * scale;
      const offsetY = -bounds.y * scale;
      const result = coords.map(([x2, y]) => {
        const vpX = x2 / imageWidth;
        const vpY = y / imageWidth;
        const windowX = vpX * scale + offsetX | 0;
        const windowY = vpY * scale + offsetY | 0;
        return [windowX, windowY];
      });
      if (start > 0) {
        const time = performance.now() - start;
        if (time > 5) {
          console.log(
            `[Transform] ${coordCount} coords in ${time.toFixed(1)}ms (${(time / coordCount).toFixed(2)}ms per coord)`
          );
        }
      }
      return result;
    } catch (error) {
      console.warn("[Canvas2D] Transform error, using fallback:", error.message);
      return coords.map(([x2, y]) => {
        try {
          const imagePoint = new OpenSeadragon.Point(x2, y);
          const viewportPoint = viewport.imageToViewportCoordinates(imagePoint);
          const windowPoint = viewport.viewportToWindowCoordinates(viewportPoint);
          return [windowPoint.x | 0, windowPoint.y | 0];
        } catch (e) {
          return [0, 0];
        }
      });
    }
  }
  /**
   * Transform polygon coordinates from image space to screen space with smooth transform
   */
  transformCoordinates(coords, smoothTransform = null) {
    if (smoothTransform) {
      const containerSize = this.viewer.viewport.getContainerSize();
      const scale = smoothTransform.scale;
      return coords.map(([x2, y]) => {
        const imageToViewport = this.viewer.viewport.imageToViewportCoordinates(
          new OpenSeadragon.Point(x2, y)
        );
        const windowX = imageToViewport.x * scale + containerSize.x / 2 - smoothTransform.viewportCenter.x * scale;
        const windowY = imageToViewport.y * scale + containerSize.y / 2 - smoothTransform.viewportCenter.y * scale;
        return [windowX, windowY];
      });
    } else {
      const screenCoords = coords.map(([x2, y]) => {
        const viewportPoint = this.viewer.viewport.imageToViewportCoordinates(
          new OpenSeadragon.Point(x2, y)
        );
        const windowPoint = this.viewer.viewport.viewportToWindowCoordinates(viewportPoint);
        return [windowPoint.x, windowPoint.y];
      });
      return screenCoords;
    }
  }
  /**
   * Handle viewport change
   */
  handleViewportChange() {
  }
  /**
   * Start animation loop
   */
  startAnimation() {
    if (this.state.isAnimating) return;
    logger$1.debug("Starting animation, target opacity:", this.state.targetOpacity);
    this.state.isAnimating = true;
    this.lastFrameTime = performance.now();
    this.animate();
  }
  /**
   * Animation loop
   */
  animate() {
    const now = performance.now();
    const deltaTime = now - this.lastUpdateTime;
    if (deltaTime < this.config.updateThrottle) {
      this.animationFrame = requestAnimationFrame(this.animate);
      return;
    }
    this.lastUpdateTime = now;
    const opacityDiff = this.state.targetOpacity - this.state.currentOpacity;
    if (Math.abs(opacityDiff) > 1e-3) {
      this.state.currentOpacity += opacityDiff * this.config.fadeSpeed;
      this.redrawSynchronized();
      this.animationFrame = requestAnimationFrame(this.animate);
    } else {
      this.state.currentOpacity = this.state.targetOpacity;
      this.state.isAnimating = false;
      if (this.state.currentOpacity === 0) {
        this.canvas.style.display = "none";
        if (this.state.selectedHotspot && this.onSpotlightCleared) {
          logger$1.debug("🔚 [SPOTLIGHT] Spotlight fully faded out, notifying renderer");
          this.onSpotlightCleared();
        }
      }
    }
    this.updatePerformanceMetrics(now);
  }
  /**
   * Redraw the mask with smooth transform
   */
  redrawSmooth(smoothTransform) {
    if (!this.context || !this.state.selectedHotspot) return;
    const frameStart = performance.now();
    if (this.canvas.style.display === "none") {
      this.canvas.style.display = "block";
    }
    const dpr = Math.min(window.devicePixelRatio || 1, this.config.devicePixelRatioMax);
    const rect = this.viewer.container.getBoundingClientRect();
    this.context.clearRect(0, 0, rect.width, rect.height);
    this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
    this.context.globalCompositeOperation = "source-over";
    const maskData = this.maskCache.get(this.state.selectedHotspot.id);
    if (!maskData) {
      logger$1.warn("No mask data found for hotspot");
      return;
    }
    const screenCoords = this.transformCoordinates(maskData.coords, smoothTransform);
    const shrinkFactor = 0.99;
    const centerX = screenCoords.reduce((sum, coord) => sum + coord[0], 0) / screenCoords.length;
    const centerY = screenCoords.reduce((sum, coord) => sum + coord[1], 0) / screenCoords.length;
    const shrunkCoords = screenCoords.map((coord) => {
      const dx = coord[0] - centerX;
      const dy = coord[1] - centerY;
      return [
        centerX + dx * shrinkFactor | 0,
        // Integer coordinates for performance
        centerY + dy * shrinkFactor | 0
        // Integer coordinates for performance
      ];
    });
    const fillOpacity = this.state.currentOpacity * this.config.maxOpacity;
    this.context.save();
    this.context.imageSmoothingEnabled = true;
    this.context.imageSmoothingQuality = "high";
    this.context.beginPath();
    this.context.rect(0, 0, rect.width, rect.height);
    this.context.moveTo(shrunkCoords[0][0], shrunkCoords[0][1]);
    for (let i = 1; i < shrunkCoords.length; i++) {
      this.context.lineTo(shrunkCoords[i][0], shrunkCoords[i][1]);
    }
    this.context.closePath();
    this.context.fillStyle = `rgba(0, 0, 0, ${fillOpacity})`;
    this.context.fill("evenodd");
    this.context.restore();
    const frameTime = performance.now() - frameStart;
    this.frameHistory.push(frameTime);
    if (this.frameHistory.length > 60) {
      this.frameHistory.shift();
    }
  }
  /**
   * Original redraw method for non-smooth updates
   */
  redraw() {
    if (!this.context || !this.state.selectedHotspot) return;
    if (this.canvas.style.display === "none") {
      this.canvas.style.display = "block";
    }
    const dpr = Math.min(window.devicePixelRatio || 1, this.config.devicePixelRatioMax);
    const rect = this.viewer.container.getBoundingClientRect();
    this.context.clearRect(0, 0, rect.width, rect.height);
    this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
    this.context.globalCompositeOperation = "source-over";
    const maskData = this.maskCache.get(this.state.selectedHotspot.id);
    if (!maskData) {
      logger$1.warn("No mask data found for hotspot");
      return;
    }
    const screenCoords = this.transformCoordinates(maskData.coords);
    const fillOpacity = this.state.currentOpacity * this.config.maxOpacity;
    this.context.save();
    this.context.beginPath();
    this.context.rect(0, 0, rect.width, rect.height);
    this.context.moveTo(screenCoords[0][0] | 0, screenCoords[0][1] | 0);
    for (let i = 1; i < screenCoords.length; i++) {
      this.context.lineTo(screenCoords[i][0] | 0, screenCoords[i][1] | 0);
    }
    this.context.closePath();
    this.context.fillStyle = `rgba(0, 0, 0, ${fillOpacity})`;
    this.context.fill("evenodd");
    this.context.restore();
  }
  /**
   * Update performance metrics
   */
  updatePerformanceMetrics(now) {
    this.frameCount++;
    if (now - this.lastFrameTime >= 1e3) {
      this.frameCount;
      this.frameHistory.length > 0 ? this.frameHistory.reduce((a, b) => a + b) / this.frameHistory.length : 0;
      this.frameCount = 0;
      this.lastFrameTime = now;
    }
  }
  /**
   * Start magnetic ink reveal animation for refined mode
   * @param {Object} centralHotspot - The closest hotspot to tap
   * @param {Array} secondaryHotspots - Array of secondary hotspots
   * @param {Object} tapPoint - The tap coordinates in image space
   */
  startMagneticInkReveal(centralHotspot, secondaryHotspots, tapPoint) {
    if (!this.magneticInkAnimator) {
      return;
    }
    logger$1.debug("Starting magnetic ink reveal", {
      central: centralHotspot == null ? void 0 : centralHotspot.id,
      secondary: secondaryHotspots == null ? void 0 : secondaryHotspots.length,
      tapPoint
    });
    this.magneticInkAnimator.startReveal(centralHotspot, secondaryHotspots, tapPoint);
  }
  /**
   * Clear magnetic ink animations
   */
  clearMagneticInkAnimation() {
    if (this.magneticInkAnimator) {
      this.magneticInkAnimator.clearAnimations();
    }
  }
  /**
   * Clean up resources
   */
  destroy() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    if (this.magneticInkAnimator) {
      this.magneticInkAnimator.destroy();
      this.magneticInkAnimator = null;
    }
    if (this.viewer) {
      this.viewer.removeHandler("update-viewport", this.updateHandler);
      this.viewer.removeHandler("resize");
    }
    if (this.resizeHandler) {
      window.removeEventListener("resize", this.resizeHandler);
    }
    if (this.canvas && this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    if (this.debugDiv && this.debugDiv.parentNode) {
      this.debugDiv.parentNode.removeChild(this.debugDiv);
      this.debugDiv = null;
    }
    if (this.viewer) {
      this.viewer.container.classList.remove("canvas2d-active");
    }
    this.maskCache.clear();
    this.transformCache.clear();
    this.canvas = null;
    this.context = null;
    this.viewer = null;
    this.isInitialized = false;
  }
}
class OverlayManagerFactory {
  /**
   * Create the appropriate overlay manager for the current browser
   * @param {Object} viewer - OpenSeadragon viewer instance
   * @param {Object} colorScheme - Optional color scheme for Safari borders
   * @returns {CSSOverlayManager|Canvas2DOverlayManager} The appropriate overlay manager
   */
  static create(viewer, colorScheme = null) {
    const browserInfo = this.detectBrowser();
    const performanceInfo = this.detectPerformanceCapabilities();
    console.log("Browser detection:", {
      isSafari: browserInfo.isSafari,
      isIOS: browserInfo.isIOS,
      isWebKit: browserInfo.isWebKit,
      isPlaywrightWebKit: browserInfo.isPlaywrightWebKit,
      isMobile: performanceInfo.isMobile,
      isLowEnd: performanceInfo.isLowEnd,
      userAgent: navigator.userAgent
    });
    if (browserInfo.isPlaywrightWebKit) {
      console.log(
        "Using CSSOverlayManager for Playwright WebKit (avoids Canvas2D masking bug)"
      );
      return new CSSOverlayManager(viewer);
    }
    if (browserInfo.isSafari || browserInfo.isIOS || browserInfo.isMacOSSafari || browserInfo.isWebKit && !window.chrome) {
      console.log(
        "Using Canvas2DOverlayManager for Safari/WebKit browser (reliable sharp outline)"
      );
      return new Canvas2DOverlayManager(viewer);
    }
    if (!performanceInfo.isMobile) {
      console.log("Using CSSOverlayManager for non-Safari desktop browser");
      return new CSSOverlayManager(viewer);
    }
    if (performanceInfo.isMobile) {
      console.log("Using Canvas2DOverlayManager for mobile performance optimization");
      return new Canvas2DOverlayManager(viewer);
    }
    console.log("Using CSSOverlayManager (default)");
    return new CSSOverlayManager(viewer);
  }
  /**
   * Detect browser type with comprehensive checks
   * @returns {Object} Browser detection results
   */
  static detectBrowser() {
    const ua = navigator.userAgent;
    const platform = navigator.platform;
    const isIOS = /iPad|iPhone|iPod/.test(ua) || platform === "MacIntel" && navigator.maxTouchPoints > 1;
    const isSafari2 = /^((?!chrome|chromium|crios|android).)*safari/i.test(ua);
    const isMacOSSafari = isSafari2 && !isIOS && /Mac/.test(platform);
    const isWebKit = "WebkitAppearance" in document.documentElement.style && !window.chrome;
    const isPlaywrightWebKit = isWebKit && // Method 1: Platform mismatch (Mac UA but Win32 platform)
    (/Macintosh/.test(ua) && platform === "Win32" || // Method 2: Missing Safari-specific features
    isSafari2 && typeof window.safari === "undefined");
    const isIOSChrome = /CriOS/.test(ua);
    return {
      isSafari: isSafari2,
      isIOS,
      isWebKit,
      isIOSChrome,
      isMacOSSafari,
      isPlaywrightWebKit,
      // NEW: Detect Playwright specifically
      // Helper flag for any WebKit-based browser
      isWebKitBased: isSafari2 || isIOS || isIOSChrome
    };
  }
  /**
   * Detect device performance capabilities
   * @returns {Object} Performance detection results
   */
  static detectPerformanceCapabilities() {
    var _a;
    const ua = navigator.userAgent.toLowerCase();
    const hasMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
      ua
    );
    const isIPadPro = navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
    const screenWidth = window.screen.width;
    const screenHeight = window.screen.height;
    const isLargeScreen = Math.min(screenWidth, screenHeight) > 768;
    const isMobile2 = hasMobileUA || isIPadPro || // Only consider touch support on small screens
    ("ontouchstart" in window || navigator.maxTouchPoints > 0) && !isLargeScreen;
    const cores = navigator.hardwareConcurrency || 4;
    const memory = navigator.deviceMemory || 4;
    const connection = ((_a = navigator.connection) == null ? void 0 : _a.effectiveType) || "4g";
    const isLowEnd = cores <= 2 || memory <= 2 || connection === "slow-2g" || connection === "2g" || connection === "3g";
    const shouldUseCanvas2D = isMobile2 || isLowEnd && cores <= 4;
    return {
      isMobile: isMobile2,
      isLowEnd,
      cores,
      memory,
      connection,
      shouldUseCanvas2D,
      // Additional context for debugging
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      pixelRatio: window.devicePixelRatio || 1
    };
  }
  /**
   * Force a specific overlay type (useful for testing)
   * @param {string} type - 'css' or 'canvas2d'
   * @returns {boolean} Success status
   */
  static setPreference(type) {
    if (type === "css" || type === "canvas2d") {
      localStorage.setItem("overlayType", type);
      console.log(`Overlay preference set to: ${type}`);
      return true;
    }
    console.warn(`Invalid overlay type: ${type}. Use 'css' or 'canvas2d'.`);
    return false;
  }
  /**
   * Clear overlay preference to use auto-detection
   */
  static clearPreference() {
    localStorage.removeItem("overlayType");
    console.log("Overlay preference cleared - will use auto-detection");
  }
  /**
   * Get current overlay type (from URL params or localStorage)
   * @returns {string|null} Forced overlay type or null for auto-detection
   */
  static getCurrentType() {
    const urlParams = new URLSearchParams(window.location.search);
    const overlayType = urlParams.get("overlay");
    if (overlayType === "css" || overlayType === "canvas2d") {
      console.log(`Overlay type forced via URL: ${overlayType}`);
      return overlayType;
    }
    const preference = localStorage.getItem("overlayType");
    if (preference === "css" || preference === "canvas2d") {
      console.log(`Overlay type from preference: ${preference}`);
      return preference;
    }
    return null;
  }
  /**
   * Create overlay manager with preference override support
   * @param {Object} viewer - OpenSeadragon viewer instance
   * @param {Object} colorScheme - Optional color scheme for Safari borders
   * @returns {CSSOverlayManager|Canvas2DOverlayManager} The appropriate overlay manager
   */
  static createWithOverride(viewer, colorScheme = null) {
    const browserInfo = this.detectBrowser();
    const performanceInfo = this.detectPerformanceCapabilities();
    if (!performanceInfo.isMobile && !browserInfo.isSafari && !browserInfo.isWebKit) {
      const currentPref = localStorage.getItem("overlayType");
      if (currentPref === "canvas2d") {
        console.log(
          "CLEANUP: Removing invalid canvas2d preference for desktop Chrome/Firefox"
        );
        localStorage.removeItem("overlayType");
      }
    }
    const forcedType = this.getCurrentType();
    if (forcedType === "css") {
      console.log("Creating CSSOverlayManager (forced)");
      return new CSSOverlayManager(viewer);
    } else if (forcedType === "canvas2d") {
      console.log("Creating Canvas2DOverlayManager (forced)");
      return new Canvas2DOverlayManager(viewer);
    }
    return this.create(viewer, colorScheme);
  }
}
if (typeof window !== "undefined") {
  window.OverlayManagerFactory = OverlayManagerFactory;
  window.clearOverlayPreference = () => {
    localStorage.removeItem("overlayType");
    console.log("Overlay preference cleared - will use auto-detection on next reload");
  };
  console.log("Debug: Use window.clearOverlayPreference() to reset overlay type");
}
function useViewerState() {
  var _a, _b, _c, _d, _e, _f, _g;
  const [isLoading, setIsLoading] = createSignal(true);
  const [viewerReady, setViewerReady] = createSignal(false);
  const [previewLoaded, setPreviewLoaded] = createSignal(false);
  console.log("[useViewerState] Initializing state:", {
    isLoading: isLoading(),
    viewerReady: viewerReady(),
    previewLoaded: previewLoaded()
  });
  const [hoveredHotspot, setHoveredHotspot] = createSignal(null);
  const [selectedHotspot, setSelectedHotspot] = createSignal(null);
  const [currentMediaHotspot, setCurrentMediaHotspot] = createSignal(null);
  const [showExpandButton, setShowExpandButton] = createSignal(false);
  const [expandButtonFading, setExpandButtonFading] = createSignal(false);
  const [isFullscreen, setIsFullscreen] = createSignal(false);
  const [showMediaButton, setShowMediaButton] = createSignal(false);
  const [mediaButtonPosition, setMediaButtonPosition] = createSignal({ x: 0, y: 0 });
  const [isZoomingToHotspot, setIsZoomingToHotspot] = createSignal(false);
  const [isExpandingToFullView, setIsExpandingToFullView] = createSignal(false);
  const [components, setComponents] = createSignal({});
  const [modeStateManager, setModeStateManager] = createSignal(null);
  const [debugLevel, setDebugLevel] = createSignal(
    parseInt(localStorage.getItem("debugLevel") ?? "1")
  );
  const [zoomSpeedMultiplier, setZoomSpeedMultiplier] = createSignal(
    parseFloat(localStorage.getItem("zoomSpeedMultiplier") || "1.0")
  );
  const [circleMultiplierValue, setCircleMultiplierValue] = createSignal(
    ((_a = window.safariTuning) == null ? void 0 : _a.circleMultiplier) || (isMobile() ? 0.8 : 1.2)
  );
  const [ellipseXValue, setEllipseXValue] = createSignal(
    ((_b = window.safariTuning) == null ? void 0 : _b.ellipseMultiplierX) || (isMobile() ? 0.8 : 1.15)
  );
  const [ellipseYValue, setEllipseYValue] = createSignal(
    ((_c = window.safariTuning) == null ? void 0 : _c.ellipseMultiplierY) || (isMobile() ? 0.8 : 1.15)
  );
  const [gradientSpreadValue, setGradientSpreadValue] = createSignal(
    ((_d = window.safariTuning) == null ? void 0 : _d.gradientMultiplier) || (isMobile() ? 1 : 1.5)
  );
  const [offsetXValue, setOffsetXValue] = createSignal(((_e = window.safariTuning) == null ? void 0 : _e.offsetX) || 0);
  const [offsetYValue, setOffsetYValue] = createSignal(((_f = window.safariTuning) == null ? void 0 : _f.offsetY) || 0);
  const [smoothingFactorValue, setSmoothingFactorValue] = createSignal(0.8);
  const [interpolationEnabled, setInterpolationEnabled] = createSignal(true);
  const [autoDeselectThreshold, setAutoDeselectThreshold] = createSignal(0.5);
  const [panDeselectThreshold, setPanDeselectThreshold] = createSignal(0.3);
  const [showFloatingPanel, setShowFloatingPanel] = createSignal(false);
  const [panelPosition, setPanelPosition] = createSignal({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = createSignal(false);
  const [dragStart, setDragStart] = createSignal({ x: 0, y: 0 });
  const [tapCount, setTapCount] = createSignal(0);
  const [tapTimeout, setTapTimeout] = createSignal(null);
  const getValidatedState = (key, defaultValue, validValues, forceDefault = false) => {
    if (forceDefault) {
      return defaultValue;
    }
    const stored = localStorage.getItem(key);
    if (stored && validValues.includes(stored)) {
      return stored;
    }
    if (stored) {
      console.warn(
        `[useViewerState] Invalid ${key} value: "${stored}". Using default: ${defaultValue}`
      );
      localStorage.removeItem(key);
    }
    return defaultValue;
  };
  const getRevealTypeForMobile = () => {
    if (!isMobile()) {
      return getValidatedState("revealType", "single", ["single", "border-radial"], false);
    }
    const hasSetRevealPreference = localStorage.getItem("hasSetRevealPreference");
    localStorage.getItem("revealType");
    if (!hasSetRevealPreference) {
      console.log(
        "[useViewerState] Mobile first visit or no preference set - defaulting to single"
      );
      return "single";
    }
    return getValidatedState(
      "revealType",
      "single",
      ["single", "refined", "refined2", "border-radial"],
      false
    );
  };
  const [interactionMode, setInteractionModeSignal] = createSignal(
    getValidatedState("interactionMode", isMobile() ? "temporal" : "direct", [
      "direct",
      "temporal"
    ])
  );
  const [revealType, setRevealTypeSignal] = createSignal(getRevealTypeForMobile());
  const setInteractionMode = (mode) => {
    setInteractionModeSignal(mode);
    localStorage.setItem("interactionMode", mode);
    if (window.modeStateManager) {
      window.modeStateManager.setMode(mode);
      console.log(`[useViewerState] Synced interaction mode to ModeStateManager: ${mode}`);
    }
    if (window.eventCoordinator) {
      window.eventCoordinator.currentMode = mode;
      console.log(`[useViewerState] Updated EventCoordinator mode: ${mode}`);
    }
  };
  const setRevealType = (type) => {
    console.log(`[useViewerState] setRevealType called with: ${type}`);
    setRevealTypeSignal(type);
    localStorage.setItem("revealType", type);
    localStorage.setItem("hasSetRevealPreference", "true");
    console.log(`[useViewerState] User preference saved: ${type}`);
    if (window.temporalEchoController) {
      window.temporalEchoController.setRevealType(type);
      console.log(`[useViewerState] Updated TemporalEchoController reveal type: ${type}`);
      console.log(
        `[useViewerState] Controller config now:`,
        window.temporalEchoController.config.revealType
      );
    } else {
      console.log(
        "[useViewerState] TemporalEchoController not found yet. Mode saved in localStorage and will be applied when controller initializes."
      );
    }
  };
  const [revealStyle, setRevealStyle] = createSignal(
    localStorage.getItem("revealStyle") || "invert"
  );
  const [borderStyle, setBorderStyle] = createSignal(
    localStorage.getItem("borderStyle") || "default"
  );
  const [performanceMetrics, setPerformanceMetrics] = createSignal({});
  const [safariHybridMetrics, setSafariHybridMetrics] = createSignal(null);
  const [performanceStatus, setPerformanceStatus] = createSignal(null);
  const [currentPalette, setCurrentPalette] = createSignal(
    ((_g = window.nativeHotspotRenderer) == null ? void 0 : _g.currentPalette) || "tech"
  );
  const [currentOverlayType, setCurrentOverlayType] = createSignal(
    OverlayManagerFactory.getCurrentType() || (OverlayManagerFactory.detectBrowser().isWebKitBased ? "safari" : "css")
  );
  const updateRevealStyle = (style2) => {
    setRevealStyle(style2);
    localStorage.setItem("revealStyle", style2);
    if (window.updateRevealStyle) {
      window.updateRevealStyle(style2);
    }
  };
  const updateBorderStyle = (style2) => {
    setBorderStyle(style2);
    localStorage.setItem("borderStyle", style2);
    if (window.updateBorderStyle) {
      window.updateBorderStyle(style2);
    }
  };
  const wrappedSetIsLoading = (value) => {
    console.log(`[useViewerState] setIsLoading called with: ${value}`);
    setIsLoading(value);
  };
  const wrappedSetViewerReady = (value) => {
    console.log(`[useViewerState] setViewerReady called with: ${value}`);
    setViewerReady(value);
  };
  return {
    // Loading states
    isLoading,
    setIsLoading: wrappedSetIsLoading,
    viewerReady,
    setViewerReady: wrappedSetViewerReady,
    previewLoaded,
    setPreviewLoaded,
    // Hotspot states
    hoveredHotspot,
    setHoveredHotspot,
    selectedHotspot,
    setSelectedHotspot,
    currentMediaHotspot,
    setCurrentMediaHotspot,
    // UI states
    showExpandButton,
    setShowExpandButton,
    expandButtonFading,
    setExpandButtonFading,
    isFullscreen,
    setIsFullscreen,
    showMediaButton,
    setShowMediaButton,
    mediaButtonPosition,
    setMediaButtonPosition,
    // Animation states
    isZoomingToHotspot,
    setIsZoomingToHotspot,
    isExpandingToFullView,
    setIsExpandingToFullView,
    // Component systems
    components,
    setComponents,
    modeStateManager,
    setModeStateManager,
    // Debug states
    debugLevel,
    setDebugLevel,
    zoomSpeedMultiplier,
    setZoomSpeedMultiplier,
    // Safari tuning states
    circleMultiplierValue,
    setCircleMultiplierValue,
    ellipseXValue,
    setEllipseXValue,
    ellipseYValue,
    setEllipseYValue,
    gradientSpreadValue,
    setGradientSpreadValue,
    offsetXValue,
    setOffsetXValue,
    offsetYValue,
    setOffsetYValue,
    // Canvas2D tuning states
    smoothingFactorValue,
    setSmoothingFactorValue,
    interpolationEnabled,
    setInterpolationEnabled,
    autoDeselectThreshold,
    setAutoDeselectThreshold,
    panDeselectThreshold,
    setPanDeselectThreshold,
    // Floating panel states
    showFloatingPanel,
    setShowFloatingPanel,
    panelPosition,
    setPanelPosition,
    isDragging,
    setIsDragging,
    dragStart,
    setDragStart,
    // Triple tap states
    tapCount,
    setTapCount,
    tapTimeout,
    setTapTimeout,
    // Interaction mode
    interactionMode,
    setInteractionMode,
    // Reveal type
    revealType,
    setRevealType,
    // Reveal style
    revealStyle,
    setRevealStyle,
    updateRevealStyle,
    // Border style
    borderStyle,
    setBorderStyle,
    updateBorderStyle,
    // Performance metrics
    performanceMetrics,
    setPerformanceMetrics,
    safariHybridMetrics,
    setSafariHybridMetrics,
    performanceStatus,
    setPerformanceStatus,
    // Palette state
    currentPalette,
    setCurrentPalette,
    // Overlay type
    currentOverlayType,
    setCurrentOverlayType
  };
}
const calculateHotspotBounds = (hotspot, viewer, isMobile2) => {
  let bounds;
  if (hotspot.coordinates) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const processCoords = (coords) => {
      if (Array.isArray(coords[0]) && typeof coords[0][0] === "number") {
        coords.forEach(([x2, y]) => {
          minX = Math.min(minX, x2);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x2);
          maxY = Math.max(maxY, y);
        });
      } else {
        coords.forEach((polygon) => {
          polygon.forEach(([x2, y]) => {
            minX = Math.min(minX, x2);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x2);
            maxY = Math.max(maxY, y);
          });
        });
      }
    };
    processCoords(hotspot.coordinates);
    bounds = { minX, minY, maxX, maxY };
  } else {
    return null;
  }
  const tiledImage = viewer.world.getItemAt(0);
  tiledImage.getContentSize();
  const topLeft = viewer.viewport.imageToViewportCoordinates(
    new OpenSeadragon.Point(bounds.minX, bounds.minY)
  );
  const bottomRight = viewer.viewport.imageToViewportCoordinates(
    new OpenSeadragon.Point(bounds.maxX, bounds.maxY)
  );
  const width = bottomRight.x - topLeft.x;
  const height = bottomRight.y - topLeft.y;
  const centerX = topLeft.x + width / 2;
  const centerY = topLeft.y + height / 2;
  const viewportAspectRatio = viewer.viewport.getAspectRatio();
  const hotspotAspectRatio = width / height;
  const paddingFactor = isMobile2 ? 0.85 : 0.8;
  let finalWidth, finalHeight;
  if (hotspotAspectRatio > viewportAspectRatio) {
    finalWidth = width / paddingFactor;
    finalHeight = finalWidth / viewportAspectRatio;
  } else {
    finalHeight = height / paddingFactor;
    finalWidth = finalHeight * viewportAspectRatio;
  }
  const zoomBounds = new OpenSeadragon.Rect(
    centerX - finalWidth / 2,
    centerY - finalHeight / 2,
    finalWidth,
    finalHeight
  );
  console.log("Hotspot zoom calculation:", {
    hotspotId: hotspot.id,
    originalBounds: bounds,
    viewportCoords: { topLeft, bottomRight },
    center: { x: centerX, y: centerY },
    dimensions: { width: finalWidth, height: finalHeight },
    aspectRatios: {
      hotspot: hotspotAspectRatio.toFixed(2),
      viewport: viewportAspectRatio.toFixed(2)
    },
    paddingFactor,
    zoomBounds
  });
  return zoomBounds;
};
let levelCache = /* @__PURE__ */ new Map();
let lastCacheZoom = null;
let cacheTimeout = null;
let cinematicModeActive = false;
let originalGetLevelsInterval = null;
let originalUpdateLevels = null;
let fixApplied = false;
function applyTileCascadeFix(OpenSeadragon2) {
  console.log("=== APPLYING ENHANCED TILE CASCADE FIX ===");
  if (!OpenSeadragon2) {
    console.error("OpenSeadragon not provided - cannot apply tile cascade fix");
    return;
  }
  if (fixApplied) {
    console.log("TileCascadeFix already applied - skipping to prevent recursion");
    return;
  }
  if (!originalGetLevelsInterval) {
    originalGetLevelsInterval = OpenSeadragon2.TiledImage.prototype._getLevelsInterval;
  }
  if (!originalUpdateLevels) {
    originalUpdateLevels = OpenSeadragon2.TiledImage.prototype._updateLevels;
  }
  if (!originalGetLevelsInterval) {
    console.error("_getLevelsInterval method not found - cannot apply fix");
    return;
  }
  OpenSeadragon2.TiledImage.prototype._getLevelsInterval = function() {
    const zoom = this.viewer.viewport.getZoom();
    if (cinematicModeActive) {
      return originalGetLevelsInterval.call(this);
    }
    if (lastCacheZoom !== null && Math.abs(zoom - lastCacheZoom) < 0.01 && levelCache.has(this)) {
      return levelCache.get(this);
    }
    const levels = originalGetLevelsInterval.call(this);
    if (!levels || typeof levels.lowestLevel === "undefined") {
      return levels;
    }
    let result = levels;
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
    if (zoom < 3 && !isIOS) {
      const isMobile2 = /Android|iPhone|iPad/i.test(navigator.userAgent);
      const optimalLevel = Math.floor(Math.log2(zoom * 1024 / 256));
      const centerLevel = Math.max(8, Math.min(12, optimalLevel + 11));
      const maxLevels = cinematicModeActive ? 4 : isMobile2 ? 2 : 2;
      result = {
        lowestLevel: Math.max(8, centerLevel - Math.floor(maxLevels / 2)),
        highestLevel: Math.min(14, centerLevel + Math.floor(maxLevels / 2))
      };
      if (result.highestLevel - result.lowestLevel > maxLevels - 1) {
        result.lowestLevel = result.highestLevel - (maxLevels - 1);
      }
    }
    levelCache.set(this, result);
    lastCacheZoom = zoom;
    if (cacheTimeout) clearTimeout(cacheTimeout);
    cacheTimeout = setTimeout(() => {
      levelCache.clear();
      lastCacheZoom = null;
    }, 100);
    return result;
  };
  if (originalUpdateLevels) {
    OpenSeadragon2.TiledImage.prototype._updateLevels = function() {
      if (this.viewer.isAnimating() || cinematicModeActive) {
        return originalUpdateLevels.call(this);
      }
      const result = originalUpdateLevels.call(this);
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
      const zoom = this.viewer.viewport.getZoom();
      if (zoom < 3 && this._tilesToDraw && !cinematicModeActive && !isIOS) {
        const allowedLevels = this._getLevelsInterval();
        this._tilesToDraw = this._tilesToDraw.filter(
          (tile) => tile.level >= allowedLevels.lowestLevel && tile.level <= allowedLevels.highestLevel
        );
      }
      return result;
    };
  }
  fixApplied = true;
  console.log("=== ENHANCED TILE CASCADE FIX APPLIED ===");
}
function setCinematicMode(enabled) {
  cinematicModeActive = enabled;
  if (enabled) {
    levelCache.clear();
    lastCacheZoom = null;
  }
  console.log(`TileCascadeFix: Cinematic mode ${enabled ? "ENABLED" : "DISABLED"}`);
}
function removeTileCascadeFix(OpenSeadragon2) {
  levelCache.clear();
  lastCacheZoom = null;
  cinematicModeActive = false;
  if (cacheTimeout) clearTimeout(cacheTimeout);
  if (fixApplied && OpenSeadragon2 && originalGetLevelsInterval) {
    OpenSeadragon2.TiledImage.prototype._getLevelsInterval = originalGetLevelsInterval;
  }
  if (fixApplied && OpenSeadragon2 && originalUpdateLevels) {
    OpenSeadragon2.TiledImage.prototype._updateLevels = originalUpdateLevels;
  }
  fixApplied = false;
  console.log("=== TILE CASCADE FIX REMOVED ===");
}
function useViewerAnimations(viewer, state, components) {
  const {
    isZoomingToHotspot,
    setIsZoomingToHotspot,
    isExpandingToFullView,
    setIsExpandingToFullView,
    setShowExpandButton,
    zoomSpeedMultiplier
  } = state;
  const isHotspotWellFramed = (hotspot, bounds) => {
    if (!viewer || !bounds) return false;
    const currentBounds = viewer.viewport.getBounds();
    viewer.viewport.getZoom();
    const hotspotViewportBounds = viewer.viewport.imageToViewportRectangle(
      bounds.x,
      bounds.y,
      bounds.width,
      bounds.height
    );
    const intersection = currentBounds.intersection(hotspotViewportBounds);
    if (!intersection) return false;
    const hotspotArea = hotspotViewportBounds.width * hotspotViewportBounds.height;
    const intersectionArea = intersection.width * intersection.height;
    const overlapRatio = intersectionArea / hotspotArea;
    const hotspotCenter = hotspotViewportBounds.getCenter();
    const viewportCenter = currentBounds.getCenter();
    const centerDistance = Math.sqrt(
      Math.pow(hotspotCenter.x - viewportCenter.x, 2) + Math.pow(hotspotCenter.y - viewportCenter.y, 2)
    );
    const isWellFramed = overlapRatio > 0.8 && centerDistance < 0.1;
    console.log("Well-framed check:", {
      overlapRatio,
      centerDistance,
      isWellFramed
    });
    return isWellFramed;
  };
  const zoomToHotspot = async (hotspot) => {
    console.log("🎯 Starting stabilized cinematic zoom", {
      hotspotId: hotspot.id,
      isZoomingToHotspot: isZoomingToHotspot()
    });
    if (!viewer || isZoomingToHotspot() || isExpandingToFullView()) {
      return;
    }
    const bounds = calculateHotspotBounds(hotspot, viewer, isMobile());
    if (!bounds) return;
    setIsZoomingToHotspot(true);
    const cinematicManager = components().cinematicZoomManager;
    if (!cinematicManager) {
      console.error("CinematicZoomManager not initialized");
      setIsZoomingToHotspot(false);
      return;
    }
    setCinematicMode(true);
    const zoomOptions = {
      useSpringPhysics: true,
      // Fallback option
      onComplete: () => {
        var _a;
        console.log("✅ Cinematic zoom completed");
        setIsZoomingToHotspot(false);
        setShowExpandButton(true);
        if (((_a = components().overlayManager) == null ? void 0 : _a.constructor.name) === "Canvas2DOverlayManager" && components().overlayManager.updateSelectionZoom) {
          components().overlayManager.updateSelectionZoom();
        }
        setCinematicMode(false);
        viewer.forceRedraw();
        if (components().renderer) {
          if (isMobile()) {
            components().renderer.showOverlay();
          }
          setTimeout(() => {
            components().renderer.resumeUpdates();
            components().renderer.updateVisibility();
            if (components().renderer.styleManager && components().renderer.styleManager.animationsPaused) {
              console.log(
                "[useViewerAnimations] 🚨 Force resuming stuck animations after zoom"
              );
              components().renderer.styleManager.resumeAllAnimations();
            }
          }, 100);
        }
      }
    };
    try {
      if (components().renderer) {
        components().renderer.pauseUpdates();
        if (isMobile()) {
          components().renderer.hideOverlay();
        }
      }
      if (components().overlayManager && components().overlayManager.startZoomAnimation) {
        components().overlayManager.startZoomAnimation();
      }
      await cinematicManager.performZoom(bounds, zoomOptions);
    } catch (error) {
      console.error("Cinematic zoom failed:", error);
      setIsZoomingToHotspot(false);
      setCinematicMode(false);
    }
  };
  const cleanupExpandAnimation = () => {
    if (window.expandToFullViewTimeouts) {
      window.expandToFullViewTimeouts.forEach((timeout) => clearTimeout(timeout));
      window.expandToFullViewTimeouts = [];
    }
  };
  const expandToFullView = async () => {
    console.log("expandToFullView with stabilized zoom");
    if (!viewer || isExpandingToFullView()) return;
    if (isZoomingToHotspot()) {
      setIsZoomingToHotspot(false);
    }
    setShowExpandButton(false);
    setIsExpandingToFullView(true);
    if (components().renderer && components().renderer.deselectHotspot) {
      console.log("Calling renderer.deselectHotspot() to properly reset visual states");
      components().renderer.deselectHotspot();
    }
    if (window.artworkViewerHandleHotspotClick) {
      console.log(
        "Clearing selected hotspot for full view expansion using handleHotspotClick"
      );
      window.artworkViewerHandleHotspotClick(null);
    }
    const tiledImage = viewer.world.getItemAt(0);
    if (!tiledImage) {
      setIsExpandingToFullView(false);
      return;
    }
    const imageBounds = tiledImage.getBounds();
    const cinematicManager = components().cinematicZoomManager;
    if (!cinematicManager) {
      console.error("CinematicZoomManager not initialized");
      setIsExpandingToFullView(false);
      return;
    }
    setCinematicMode(true);
    const expandOptions = {
      animationTime: isMobile() ? 0.7 : 0.9,
      springStiffness: isMobile() ? 9 : 7,
      onComplete: () => {
        console.log("✅ Full view expansion completed");
        setIsExpandingToFullView(false);
        setCinematicMode(false);
        viewer.forceRedraw();
        if (components().renderer) {
          if (isMobile()) {
            components().renderer.showOverlay();
          }
          setTimeout(() => {
            components().renderer.resumeUpdates();
            components().renderer.updateVisibility();
            if (components().renderer.styleManager && components().renderer.styleManager.animationsPaused) {
              console.log(
                "[useViewerAnimations] 🚨 Force resuming stuck animations after zoom"
              );
              components().renderer.styleManager.resumeAllAnimations();
            }
          }, 100);
        }
      }
    };
    try {
      if (components().renderer) {
        components().renderer.pauseUpdates();
        if (isMobile()) {
          components().renderer.hideOverlay();
        }
      }
      await cinematicManager.performCinematicZoom(imageBounds, expandOptions);
    } catch (error) {
      console.error("Full view expansion failed:", error);
      setIsExpandingToFullView(false);
      setCinematicMode(false);
    }
  };
  return {
    isHotspotWellFramed,
    zoomToHotspot,
    cleanupExpandAnimation,
    expandToFullView
  };
}
delegateEvents(["click"]);
function addGlassButtonEffects(event, button) {
  if (navigator.vibrate) {
    try {
      navigator.vibrate(50);
    } catch (e) {
    }
  }
  if (button && event) {
    const ripple = document.createElement("span");
    ripple.className = "ripple";
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    const x2 = clientX - rect.left - size / 2;
    const y = clientY - rect.top - size / 2;
    ripple.style.width = ripple.style.height = size + "px";
    ripple.style.left = x2 + "px";
    ripple.style.top = y + "px";
    button.appendChild(ripple);
    setTimeout(() => ripple.remove(), 600);
  }
  if (button) {
    button.classList.add("tapped");
    setTimeout(() => button.classList.remove("tapped"), 200);
  }
}
const CACHE_VERSION_KEY = "app_cache_version";
const CURRENT_VERSION = "1.0.2";
class CacheManager {
  constructor() {
    this.storageAvailable = this.checkStorageAvailability();
    if (this.storageAvailable) {
      this.checkVersion();
    } else {
      console.warn("[CacheManager] Storage not available (private browsing or disabled)");
    }
  }
  checkStorageAvailability() {
    try {
      const testKey = "__cache_test__";
      localStorage.setItem(testKey, "test");
      localStorage.removeItem(testKey);
      return true;
    } catch (e) {
      return false;
    }
  }
  checkVersion() {
    if (!this.storageAvailable) return;
    try {
      const storedVersion = localStorage.getItem(CACHE_VERSION_KEY);
      const revealType = localStorage.getItem("revealType");
      if (revealType === "refined" || revealType === "refined2") {
        console.log(`[CacheManager] Migrating revealType from '${revealType}' to 'single'`);
        localStorage.setItem("revealType", "single");
      }
      if (storedVersion !== CURRENT_VERSION) {
        console.log(
          `[CacheManager] Version mismatch (stored: ${storedVersion}, current: ${CURRENT_VERSION}). Clearing cache...`
        );
        this.clearAll();
        localStorage.setItem(CACHE_VERSION_KEY, CURRENT_VERSION);
      }
    } catch (e) {
      console.error("[CacheManager] Error checking version:", e);
    }
  }
  clearAll() {
    if (!this.storageAvailable) return;
    try {
      const preserveKeys = [CACHE_VERSION_KEY];
      const preserved = {};
      preserveKeys.forEach((key) => {
        const value = localStorage.getItem(key);
        if (value !== null) {
          preserved[key] = value;
        }
      });
      localStorage.clear();
      sessionStorage.clear();
      Object.entries(preserved).forEach(([key, value]) => {
        localStorage.setItem(key, value);
      });
      console.log("[CacheManager] Cache cleared successfully");
    } catch (e) {
      console.error("[CacheManager] Error clearing cache:", e);
    }
  }
  // Development mode: clear on each reload
  initDevelopmentMode() {
    if (!this.storageAvailable || true) return;
  }
  clearStaleData() {
    if (!this.storageAvailable) return;
    try {
      const problematicKeys = [
        "debugTuningValues",
        "rendererState",
        "modeState",
        "viewer_state",
        "hotspot_state",
        "animation_state",
        // Animation-related keys that were missing
        "revealStyle",
        "revealType",
        "hasSetRevealPreference",
        // Keep user's explicit preference flag
        "borderStyle",
        "interactionMode",
        "temporalRevealStyle",
        "performanceMode"
      ];
      problematicKeys.forEach((key) => {
        localStorage.removeItem(key);
      });
    } catch (e) {
      console.error("[CacheManager] Error clearing stale data:", e);
    }
  }
  // Manual clear function for debugging
  forceReset() {
    console.log("[CacheManager] Force reset triggered");
    this.clearAll();
    window.location.reload();
  }
}
const cacheManager = new CacheManager();
cacheManager.initDevelopmentMode();
var _tmpl$$5 = /* @__PURE__ */ template(`<div class=debug-stats-classic><div class=debug-stat-row><span class=debug-stat-label>Hovered</span><span class=debug-stat-value></span></div><div class=debug-stat-row><span class=debug-stat-label>Selected</span><span class=debug-stat-value></span></div><div class=debug-stat-row><span class=debug-stat-label>Type</span><span class=debug-stat-value>`), _tmpl$2$4 = /* @__PURE__ */ template(`<div class=debug-stat-row style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.1);"><span class=debug-stat-label style=color:#00ffff;>Safari Hybrid</span><span class=debug-stat-value style=color:#00ffff;>Active`), _tmpl$3$3 = /* @__PURE__ */ template(`<div class=debug-stat-row><span class=debug-stat-label>Render Time</span><span class=debug-stat-value>ms`), _tmpl$4$3 = /* @__PURE__ */ template(`<div class=debug-stat-row><span class=debug-stat-label>Visible/Total</span><span class=debug-stat-value>/`), _tmpl$5$3 = /* @__PURE__ */ template(`<div class=debug-stats-classic><div class=debug-stat-row><span class=debug-stat-label>FPS</span><span class=debug-stat-value><span style=opacity:0.7;font-size:10px> (avg: <!>)</span></span></div><div class=debug-stat-row><span class=debug-stat-label>Status</span><span class=debug-stat-value></span></div><div class=debug-stat-row><span class=debug-stat-label>Memory</span><span class=debug-stat-value>MB</span></div><div class=debug-stat-row><span class=debug-stat-label>Frame Time</span><span class=debug-stat-value>ms</span></div><div class=debug-stat-row><span class=debug-stat-label>Zoom</span><span class=debug-stat-value>x`), _tmpl$6$3 = /* @__PURE__ */ template(`<div class=debug-control><label class=debug-control-label>Zoom Animation Speed<span class=debug-control-value>x</span></label><input type=range class=debug-slider min=0.5 max=2.5 step=0.1><p class=debug-control-description>How fast the artwork zooms when you click on elements`), _tmpl$7$3 = /* @__PURE__ */ template(`<div class=debug-control><label class=debug-control-label>Color Theme<span class=debug-help-icon title="Changes the highlight colors">?</span></label><div class=debug-toggle-group><button type=button>Cyan Tech</button><button type=button>Golden Magic</button><button type=button>Blue Moon</button></div><div class=debug-toggle-group style=margin-top:8px;><button type=button>Pure White</button><button type=button>Soft White</button><button type=button>Dark Mode`), _tmpl$8$3 = /* @__PURE__ */ template(`<div class=debug-control><label class=debug-control-label>Stroke Animation Speed</label><div style=display:flex;align-items:center;gap:12px;><span style=font-size:11px;color:#888;min-width:30px;>Fast</span><input type=range min=0.3 max=4.0 step=0.1 style=flex:1;cursor:pointer;><span style=font-size:11px;color:#888;min-width:30px;text-align:right;>Slow</span></div><p class=debug-control-description style=margin-top:8px;text-align:center;><span style=color:#666;font-size:10px;>`), _tmpl$9$3 = /* @__PURE__ */ template(`<div class=debug-control><label class=debug-control-label>Hotspot Reveal Mode</label><div class=debug-toggle-group><button type=button>Focus</button><button type=button>Ripple (experimental)</button></div><p class=debug-control-description>`), _tmpl$0$3 = /* @__PURE__ */ template(`<div class=debug-stats-classic><div class=debug-stat-row><span class=debug-stat-label>Cache Version</span><span class=debug-stat-value>1.0.2</span></div><div class=debug-stat-row><span class=debug-stat-label>Status</span><span class=debug-stat-value>Active</span></div><div class=debug-stat-row><span class=debug-stat-label>localStorage Size</span><span class=debug-stat-value>`), _tmpl$1$2 = /* @__PURE__ */ template(`<div class=debug-control style=margin-top:16px;><button class=debug-toggle-option>🗑️ Clear Cache & Reload</button><p class=debug-control-description>Fixes stuck animations and broken hover states`), _tmpl$10$2 = /* @__PURE__ */ template(`<span class=debug-mobile-compact-fps> FPS`), _tmpl$11$1 = /* @__PURE__ */ template(`<div class="debug-mobile-compact glass-button"><div class=debug-mobile-compact-content><span class=debug-mobile-compact-icon><svg width=16 height=16 viewBox="0 0 20 20"fill=none><path d="M4 4v12M10 2v4M10 14v4M16 8v8M10 8.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM16 5.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM10 14.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round></path></svg></span><span class=debug-mobile-compact-label>Debug`), _tmpl$12$1 = /* @__PURE__ */ template(`<div class=debug-stats-classic><div class=debug-stat-row><span class=debug-stat-label>Cache Version</span><span class=debug-stat-value>1.0.2</span></div><div class=debug-stat-row><span class=debug-stat-label>Status</span><span class=debug-stat-value style=color:#4CAF50>Active</span></div><div style=margin-top:20px;><button class=glass-button>🗑️ Clear Cache & Reload</button><p style=margin-top:10px;font-size:11px;opacity:0.6;text-align:center;>Clears localStorage, sessionStorage and reloads the app`), _tmpl$13$1 = /* @__PURE__ */ template(`<div><div><div class=debug-mobile-sheet-handle><div class=debug-mobile-sheet-handle-bar></div></div><div class=debug-mobile-sheet-header><h3 class=debug-mobile-sheet-title><svg width=18 height=18 viewBox="0 0 20 20"fill=none><path d="M4 4v12M10 2v4M10 14v4M16 8v8M10 8.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM16 5.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM10 14.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round></path></svg>Artwork Controls</h3></div><div class=debug-mobile-tabs></div><div class=debug-mobile-content>`), _tmpl$14$1 = /* @__PURE__ */ template(`<button><span class=debug-mobile-tab-icon></span><span class=debug-mobile-tab-label>`), _tmpl$15$1 = /* @__PURE__ */ template(`<span style=margin-left:8px;>Artwork Controls`), _tmpl$16$1 = /* @__PURE__ */ template(`<button title="Minimize panel"><svg viewBox="0 0 20 20"><rect x=11 y=15 width=14 height=2>`), _tmpl$17$1 = /* @__PURE__ */ template(`<div><div class=debug-panel-header><h3 class=debug-panel-title style="margin:0;display:'flex';alignItems:'center';"><svg viewBox="0 0 20 20"fill=none><path d="M4 4v12M10 2v4M10 14v4M16 8v8M10 8.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM16 5.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM10 14.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round>`), _tmpl$18$1 = /* @__PURE__ */ template(`<div><div class=debug-section-header><div class=debug-section-title><span class=debug-section-icon></span><span></span></div><span class=debug-section-chevron>▼</span></div><div class=debug-section-content><div class=debug-section-body>`);
function DebugPanel(props) {
  const [isMinimized, setIsMinimized] = createSignal(true);
  const [expandedSections, setExpandedSections] = createSignal({
    artwork: false,
    performance: false,
    visual: false,
    navigation: false,
    overlay: false,
    easing: false,
    cache: false,
    osrsAudio: false,
    audioPlayerTest: false
  });
  const [position, setPosition] = createSignal({
    x: null,
    y: null
  });
  const [isDragging, setIsDragging] = createSignal(false);
  const [dragStart, setDragStart] = createSignal({
    x: 0,
    y: 0,
    elementX: 0,
    elementY: 0
  });
  createSignal(0);
  if (!window.animationSpeedMultiplier) {
    window.animationSpeedMultiplier = 0.8;
  }
  const [animationSpeed, setAnimationSpeed] = createSignal(window.animationSpeedMultiplier);
  const [mobileExpanded, setMobileExpanded] = createSignal(false);
  const [activeTab, setActiveTab] = createSignal(0);
  const [isClosing, setIsClosing] = createSignal(false);
  const closeBottomSheet = () => {
    setIsClosing(true);
    setTimeout(() => {
      setMobileExpanded(false);
      setIsClosing(false);
    }, 300);
  };
  let bottomSheetRef;
  let touchStartY = 0;
  let currentTranslateY = 0;
  const handleTouchStart = (e) => {
    touchStartY = e.touches[0].clientY;
    currentTranslateY = 0;
  };
  const handleTouchMove = (e) => {
    if (!mobileExpanded() || !bottomSheetRef) return;
    const touchY = e.touches[0].clientY;
    const deltaY = touchY - touchStartY;
    if (deltaY > 0) {
      currentTranslateY = deltaY;
      bottomSheetRef.style.transform = `translateY(${deltaY}px)`;
    }
  };
  const handleTouchEnd = () => {
    if (!bottomSheetRef) return;
    if (currentTranslateY > 100) {
      closeBottomSheet();
    }
    bottomSheetRef.style.transform = "";
    currentTranslateY = 0;
  };
  const sections = [
    {
      id: "artwork",
      icon: "🔍",
      title: "Active Element",
      content: () => (() => {
        var _el$ = _tmpl$$5(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$2.nextSibling, _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling, _el$8 = _el$5.nextSibling, _el$9 = _el$8.firstChild, _el$0 = _el$9.nextSibling;
        insert(_el$4, () => {
          var _a;
          return ((_a = props.hoveredHotspot()) == null ? void 0 : _a.id) || "none";
        });
        insert(_el$7, () => {
          var _a;
          return ((_a = props.selectedHotspot()) == null ? void 0 : _a.id) || "none";
        });
        insert(_el$0, () => {
          var _a, _b;
          return ((_a = props.hoveredHotspot()) == null ? void 0 : _a.type) || ((_b = props.selectedHotspot()) == null ? void 0 : _b.type) || "none";
        });
        return _el$;
      })()
    },
    {
      id: "performance",
      icon: "📊",
      title: "Performance",
      content: () => {
        return (() => {
          var _el$1 = _tmpl$5$3(), _el$10 = _el$1.firstChild, _el$11 = _el$10.firstChild, _el$12 = _el$11.nextSibling, _el$13 = _el$12.firstChild, _el$14 = _el$13.firstChild, _el$17 = _el$14.nextSibling;
          _el$17.nextSibling;
          var _el$18 = _el$10.nextSibling, _el$19 = _el$18.firstChild, _el$20 = _el$19.nextSibling, _el$21 = _el$18.nextSibling, _el$22 = _el$21.firstChild, _el$23 = _el$22.nextSibling, _el$24 = _el$23.firstChild, _el$25 = _el$21.nextSibling, _el$26 = _el$25.firstChild, _el$27 = _el$26.nextSibling, _el$28 = _el$27.firstChild, _el$29 = _el$25.nextSibling, _el$30 = _el$29.firstChild, _el$31 = _el$30.nextSibling, _el$32 = _el$31.firstChild;
          insert(_el$12, () => {
            var _a, _b;
            return ((_b = (_a = props.performanceMetrics) == null ? void 0 : _a.currentFPS) == null ? void 0 : _b.toFixed(0)) || "60";
          }, _el$13);
          insert(_el$13, () => {
            var _a;
            return ((_a = props.performanceMetrics) == null ? void 0 : _a.averageFPS) || "60";
          }, _el$17);
          insert(_el$20, () => {
            var _a;
            return ((_a = props.performanceMetrics) == null ? void 0 : _a.performanceLevel) || "excellent";
          });
          insert(_el$23, () => {
            var _a, _b;
            return ((_b = (_a = props.performanceMetrics) == null ? void 0 : _a.memoryUsage) == null ? void 0 : _b.toFixed(0)) || "0";
          }, _el$24);
          insert(_el$27, () => {
            var _a;
            return ((_a = props.performanceMetrics) == null ? void 0 : _a.frameTime) || "16.67";
          }, _el$28);
          insert(_el$31, () => {
            var _a;
            return ((_a = props.performanceMetrics) == null ? void 0 : _a.zoomLevel) || "1.00";
          }, _el$32);
          insert(_el$1, createComponent(Show, {
            get when() {
              return props.safariHybridMetrics;
            },
            get children() {
              return [_tmpl$2$4(), (() => {
                var _el$34 = _tmpl$3$3(), _el$35 = _el$34.firstChild, _el$36 = _el$35.nextSibling, _el$37 = _el$36.firstChild;
                insert(_el$36, () => {
                  var _a;
                  return ((_a = props.safariHybridMetrics.renderTime) == null ? void 0 : _a.toFixed(2)) || "0.00";
                }, _el$37);
                createRenderEffect((_$p) => (_$p = props.safariHybridMetrics.renderTime > 16.67 ? "#FF9800" : "#4CAF50") != null ? _el$36.style.setProperty("color", _$p) : _el$36.style.removeProperty("color"));
                return _el$34;
              })(), (() => {
                var _el$38 = _tmpl$4$3(), _el$39 = _el$38.firstChild, _el$40 = _el$39.nextSibling, _el$41 = _el$40.firstChild;
                insert(_el$40, () => props.safariHybridMetrics.visibleHotspots || "0", _el$41);
                insert(_el$40, () => props.safariHybridMetrics.hotspotCount || "0", null);
                return _el$38;
              })()];
            }
          }), null);
          createRenderEffect((_p$) => {
            var _a, _b, _c, _d, _e;
            var _v$ = (((_a = props.performanceMetrics) == null ? void 0 : _a.currentFPS) || 60) < 55 ? "#FF9800" : "#4CAF50", _v$2 = {
              excellent: "#4CAF50",
              good: "#8BC34A",
              acceptable: "#FFC107",
              poor: "#FF9800",
              critical: "#F44336"
            }[((_b = props.performanceMetrics) == null ? void 0 : _b.performanceLevel) || "excellent"], _v$3 = (((_c = props.performanceMetrics) == null ? void 0 : _c.memoryUsage) || 0) > 250 ? "#FF9800" : "#4CAF50", _v$4 = parseFloat(((_d = props.performanceMetrics) == null ? void 0 : _d.frameTime) || 16.67) > 33 ? "#F44336" : parseFloat(((_e = props.performanceMetrics) == null ? void 0 : _e.frameTime) || 16.67) > 20 ? "#FF9800" : "#4CAF50";
            _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$12.style.setProperty("color", _v$) : _el$12.style.removeProperty("color"));
            _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$20.style.setProperty("color", _v$2) : _el$20.style.removeProperty("color"));
            _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$23.style.setProperty("color", _v$3) : _el$23.style.removeProperty("color"));
            _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$27.style.setProperty("color", _v$4) : _el$27.style.removeProperty("color"));
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0
          });
          return _el$1;
        })();
      }
    },
    {
      id: "visual",
      icon: "🎨",
      title: "Viewer Preferences",
      content: () => [(() => {
        var _el$42 = _tmpl$6$3(), _el$43 = _el$42.firstChild, _el$44 = _el$43.firstChild, _el$45 = _el$44.nextSibling, _el$46 = _el$45.firstChild, _el$47 = _el$43.nextSibling;
        insert(_el$45, () => props.zoomSpeed().toFixed(1), _el$46);
        _el$47.$$input = (e) => props.setZoomSpeed(parseFloat(e.target.value));
        createRenderEffect(() => _el$47.value = props.zoomSpeed());
        return _el$42;
      })(), (() => {
        var _el$48 = _tmpl$7$3(), _el$49 = _el$48.firstChild, _el$50 = _el$49.nextSibling, _el$51 = _el$50.firstChild, _el$52 = _el$51.nextSibling, _el$53 = _el$52.nextSibling, _el$54 = _el$50.nextSibling, _el$55 = _el$54.firstChild, _el$56 = _el$55.nextSibling, _el$57 = _el$56.nextSibling;
        _el$51.$$click = () => {
          console.log("Setting palette to tech");
          props.setPalette("tech");
        };
        _el$52.$$click = () => {
          console.log("Setting palette to enchantedJournal");
          props.setPalette("enchantedJournal");
        };
        _el$53.$$click = () => {
          console.log("Setting palette to moonlitManuscript");
          props.setPalette("moonlitManuscript");
        };
        _el$55.$$click = () => {
          console.log("Setting palette to pureWhiteHigh");
          props.setPalette("pureWhiteHigh");
        };
        _el$56.$$click = () => {
          console.log("Setting palette to pureWhiteBalanced");
          props.setPalette("pureWhiteBalanced");
        };
        _el$57.$$click = () => {
          console.log("Setting palette to blackOnBlack");
          props.setPalette("blackOnBlack");
        };
        createRenderEffect((_p$) => {
          var _v$5 = `debug-toggle-option ${props.currentPalette() === "tech" ? "active" : ""}`, _v$6 = `debug-toggle-option ${props.currentPalette() === "enchantedJournal" ? "active" : ""}`, _v$7 = `debug-toggle-option ${props.currentPalette() === "moonlitManuscript" ? "active" : ""}`, _v$8 = `debug-toggle-option ${props.currentPalette() === "pureWhiteHigh" ? "active" : ""}`, _v$9 = `debug-toggle-option ${props.currentPalette() === "pureWhiteBalanced" ? "active" : ""}`, _v$0 = `debug-toggle-option ${props.currentPalette() === "blackOnBlack" ? "active" : ""}`;
          _v$5 !== _p$.e && className(_el$51, _p$.e = _v$5);
          _v$6 !== _p$.t && className(_el$52, _p$.t = _v$6);
          _v$7 !== _p$.a && className(_el$53, _p$.a = _v$7);
          _v$8 !== _p$.o && className(_el$55, _p$.o = _v$8);
          _v$9 !== _p$.i && className(_el$56, _p$.i = _v$9);
          _v$0 !== _p$.n && className(_el$57, _p$.n = _v$0);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0,
          i: void 0,
          n: void 0
        });
        return _el$48;
      })()]
    },
    // Desktop only - Hover Animation Speed
    ...!isMobile() ? [{
      id: "easing",
      icon: "✏️",
      title: "Hover Animation Speed",
      content: () => (() => {
        var _el$58 = _tmpl$8$3(), _el$59 = _el$58.firstChild, _el$60 = _el$59.nextSibling, _el$61 = _el$60.firstChild, _el$62 = _el$61.nextSibling, _el$63 = _el$60.nextSibling, _el$64 = _el$63.firstChild;
        _el$62.$$input = (e) => {
          const value = parseFloat(e.target.value);
          window.animationSpeedMultiplier = value;
          setAnimationSpeed(value);
          console.log(`[Animation Speed] Set to ${value}x (${value < 1 ? "faster" : value > 1 ? "slower" : "normal"})`);
        };
        insert(_el$63, () => `${animationSpeed().toFixed(1)}x speed`, _el$64);
        insert(_el$64, (() => {
          var _c$ = memo(() => animationSpeed() < 1);
          return () => _c$() ? " (faster)" : animationSpeed() > 1 ? " (slower)" : " (normal)";
        })());
        createRenderEffect(() => _el$62.value = animationSpeed());
        return _el$58;
      })()
    }] : [],
    // Mobile only - Reveal Type section
    ...isMobile() ? [{
      id: "revealType",
      icon: "👁️",
      title: "Reveal Type",
      content: () => (() => {
        var _el$65 = _tmpl$9$3(), _el$66 = _el$65.firstChild, _el$67 = _el$66.nextSibling, _el$68 = _el$67.firstChild, _el$69 = _el$68.nextSibling, _el$70 = _el$67.nextSibling;
        _el$68.$$click = () => {
          var _a;
          return (_a = props.setRevealType) == null ? void 0 : _a.call(props, "focus");
        };
        _el$69.$$click = () => {
          var _a;
          return (_a = props.setRevealType) == null ? void 0 : _a.call(props, "ripple");
        };
        insert(_el$70, (() => {
          var _c$2 = memo(() => {
            var _a;
            return ((_a = props.revealType) == null ? void 0 : _a.call(props)) === "focus";
          });
          return () => {
            var _a;
            return _c$2() ? "Reveals only the closest hotspot on tap" : ((_a = props.revealType) == null ? void 0 : _a.call(props)) === "ripple" ? "Experimental: Ripple effect reveals neighboring zones in expanding wave" : "Reveals only the closest hotspot on tap";
          };
        })());
        createRenderEffect((_p$) => {
          var _a, _b;
          var _v$1 = `debug-toggle-option ${((_a = props.revealType) == null ? void 0 : _a.call(props)) === "focus" || !props.revealType ? "active" : ""}`, _v$10 = `debug-toggle-option ${((_b = props.revealType) == null ? void 0 : _b.call(props)) === "ripple" ? "active" : ""}`;
          _v$1 !== _p$.e && className(_el$68, _p$.e = _v$1);
          _v$10 !== _p$.t && className(_el$69, _p$.t = _v$10);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$65;
      })()
    }] : [],
    {
      id: "cache",
      icon: "🗑️",
      title: "Cache Management",
      content: () => [(() => {
        var _el$71 = _tmpl$0$3(), _el$72 = _el$71.firstChild, _el$73 = _el$72.nextSibling, _el$74 = _el$73.firstChild, _el$75 = _el$74.nextSibling, _el$76 = _el$73.nextSibling, _el$77 = _el$76.firstChild, _el$78 = _el$77.nextSibling;
        _el$75.style.setProperty("color", "#4CAF50");
        insert(_el$78, () => {
          let size = 0;
          for (let key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
              size += localStorage[key].length + key.length;
            }
          }
          return (size / 1024).toFixed(1) + " KB";
        });
        return _el$71;
      })(), (() => {
        var _el$79 = _tmpl$1$2(), _el$80 = _el$79.firstChild;
        _el$80.$$click = () => {
          if (confirm("Clear all cached data and reload? This will fix any stuck animations or broken state.")) {
            cacheManager.forceReset();
          }
        };
        _el$80.style.setProperty("width", "100%");
        _el$80.style.setProperty("background", "rgba(255, 87, 34, 0.08)");
        _el$80.style.setProperty("border", "1px solid rgba(255, 87, 34, 0.2)");
        _el$80.style.setProperty("color", "#FF5722");
        return _el$79;
      })()]
    }
  ];
  if (isMobile()) {
    const tabs = [{
      id: "reveal",
      label: "Reveal",
      icon: "👁️"
    }, {
      id: "cache",
      label: "Cache",
      icon: "🗑️"
    }];
    return [(() => {
      var _el$81 = _tmpl$11$1(), _el$82 = _el$81.firstChild, _el$83 = _el$82.firstChild;
      _el$83.nextSibling;
      _el$81.$$click = (e) => {
        addGlassButtonEffects(e, e.currentTarget);
        setMobileExpanded(true);
      };
      _el$81.style.setProperty("position", "fixed");
      _el$81.style.setProperty("bottom", "20px");
      _el$81.style.setProperty("left", "20px");
      _el$81.style.setProperty("transform", "none");
      _el$81.style.setProperty("zIndex", "1000");
      insert(_el$82, createComponent(Show, {
        get when() {
          var _a;
          return (_a = props.performanceMetrics) == null ? void 0 : _a.currentFPS;
        },
        get children() {
          var _el$85 = _tmpl$10$2(), _el$86 = _el$85.firstChild;
          insert(_el$85, () => {
            var _a, _b;
            return (_b = (_a = props.performanceMetrics) == null ? void 0 : _a.currentFPS) == null ? void 0 : _b.toFixed(0);
          }, _el$86);
          createRenderEffect((_$p) => {
            var _a;
            return (_$p = (((_a = props.performanceMetrics) == null ? void 0 : _a.currentFPS) || 60) < 45 ? "#FF9800" : "#4CAF50") != null ? _el$85.style.setProperty("color", _$p) : _el$85.style.removeProperty("color");
          });
          return _el$85;
        }
      }), null);
      createRenderEffect((_$p) => (_$p = mobileExpanded() ? "none" : "flex") != null ? _el$81.style.setProperty("display", _$p) : _el$81.style.removeProperty("display"));
      return _el$81;
    })(), createComponent(Show, {
      get when() {
        return mobileExpanded();
      },
      get children() {
        var _el$87 = _tmpl$13$1(), _el$88 = _el$87.firstChild, _el$89 = _el$88.firstChild, _el$90 = _el$89.nextSibling, _el$91 = _el$90.firstChild, _el$92 = _el$90.nextSibling, _el$93 = _el$92.nextSibling;
        _el$87.$$click = (e) => {
          if (e.target === e.currentTarget) {
            closeBottomSheet();
          }
        };
        _el$88.$$pointerdown = (e) => e.stopPropagation();
        _el$88.$$click = (e) => e.stopPropagation();
        _el$88.$$touchend = handleTouchEnd;
        _el$88.$$touchmove = handleTouchMove;
        _el$88.$$touchstart = handleTouchStart;
        var _ref$ = bottomSheetRef;
        typeof _ref$ === "function" ? use(_ref$, _el$88) : bottomSheetRef = _el$88;
        _el$88.style.setProperty("position", "fixed");
        _el$88.style.setProperty("bottom", "0");
        _el$88.style.setProperty("left", "50%");
        _el$88.style.setProperty("transform", "translateX(-50%)");
        _el$88.style.setProperty("transition", "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)");
        _el$88.style.setProperty("willChange", "transform");
        _el$88.style.setProperty("width", "90%");
        _el$88.style.setProperty("maxWidth", "500px");
        _el$88.style.setProperty("minHeight", "60vh");
        _el$88.style.setProperty("maxHeight", "85vh");
        _el$88.style.setProperty("display", "flex");
        _el$88.style.setProperty("flexDirection", "column");
        _el$89.style.setProperty("padding", "8px");
        _el$90.style.setProperty("padding", "12px 20px");
        _el$91.style.setProperty("fontSize", "14px");
        _el$91.style.setProperty("margin", "0");
        _el$91.style.setProperty("display", "flex");
        _el$91.style.setProperty("alignItems", "center");
        _el$91.style.setProperty("gap", "8px");
        insert(_el$92, createComponent(For, {
          each: tabs,
          children: (tab, index) => (() => {
            var _el$99 = _tmpl$14$1(), _el$100 = _el$99.firstChild, _el$101 = _el$100.nextSibling;
            _el$99.$$click = () => setActiveTab(index());
            insert(_el$100, () => tab.icon);
            insert(_el$101, () => tab.label);
            createRenderEffect(() => className(_el$99, `debug-mobile-tab ${activeTab() === index() ? "active" : ""}`));
            return _el$99;
          })()
        }));
        _el$93.style.setProperty("flex", "1");
        _el$93.style.setProperty("overflowY", "auto");
        _el$93.style.setProperty("WebkitOverflowScrolling", "touch");
        _el$93.style.setProperty("padding", "32px 24px 40px");
        _el$93.style.setProperty("minHeight", "300px");
        insert(_el$93, createComponent(Switch, {
          get children() {
            return [createComponent(Match, {
              get when() {
                return activeTab() === 0;
              },
              get children() {
                var _a;
                return (_a = sections.find((s) => s.id === "revealType")) == null ? void 0 : _a.content();
              }
            }), createComponent(Match, {
              get when() {
                return activeTab() === 1;
              },
              get children() {
                var _el$94 = _tmpl$12$1(), _el$95 = _el$94.firstChild, _el$96 = _el$95.nextSibling, _el$97 = _el$96.nextSibling, _el$98 = _el$97.firstChild;
                _el$98.$$click = () => {
                  if (confirm("Clear all cached data and reload?")) {
                    cacheManager.forceReset();
                  }
                };
                _el$98.style.setProperty("width", "100%");
                _el$98.style.setProperty("padding", "12px");
                _el$98.style.setProperty("background", "rgba(255, 87, 34, 0.1)");
                _el$98.style.setProperty("border", "1px solid rgba(255, 87, 34, 0.3)");
                _el$98.style.setProperty("color", "#FF5722");
                return _el$94;
              }
            }), createComponent(Match, {
              get when() {
                return activeTab() === 3;
              },
              get children() {
                var _a;
                return (_a = sections.find((s) => s.id === "minimalistAudio")) == null ? void 0 : _a.content();
              }
            }), createComponent(Match, {
              get when() {
                return activeTab() === 4;
              },
              get children() {
                var _a;
                return (_a = sections.find((s) => s.id === "audioPlayerTest")) == null ? void 0 : _a.content();
              }
            })];
          }
        }));
        createRenderEffect((_p$) => {
          var _v$11 = `debug-mobile-backdrop ${isClosing() ? "closing" : ""}`, _v$12 = `debug-mobile-sheet ${isClosing() ? "closing" : "expanded"}`;
          _v$11 !== _p$.e && className(_el$87, _p$.e = _v$11);
          _v$12 !== _p$.t && className(_el$88, _p$.t = _v$12);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$87;
      }
    })];
  }
  const handleMouseDown = (e) => {
    if (!e.target.closest(".debug-panel-header") || isMinimized()) return;
    e.preventDefault();
    setIsDragging(true);
    const panelElement = e.currentTarget;
    const rect = panelElement.getBoundingClientRect();
    let actualLeft = rect.left;
    if (position().x === null && !isMinimized()) {
      actualLeft = rect.left;
    } else if (position().x !== null) {
      actualLeft = position().x;
    }
    setDragStart({
      x: e.clientX,
      y: e.clientY,
      elementX: actualLeft,
      elementY: position().y !== null ? position().y : rect.top
    });
  };
  const handleMouseMove = (e) => {
    if (!isDragging()) return;
    const deltaX = e.clientX - dragStart().x;
    const deltaY = e.clientY - dragStart().y;
    setPosition({
      x: dragStart().elementX + deltaX,
      y: dragStart().elementY + deltaY
    });
  };
  const handleMouseUp = () => {
    setIsDragging(false);
  };
  onMount(() => {
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  });
  onCleanup(() => {
    document.removeEventListener("mousemove", handleMouseMove);
    document.removeEventListener("mouseup", handleMouseUp);
  });
  onMount(() => {
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    if (isMinimized()) {
      const panelElement = document.querySelector(".debug-panel.glass-button");
      if (panelElement) {
        addGlassButtonEffects(panelElement);
      }
    }
  });
  const toggleSection = (section) => {
    setExpandedSections((prev) => ({
      ...prev,
      [section]: !prev[section]
    }));
  };
  return (() => {
    var _el$102 = _tmpl$17$1(), _el$103 = _el$102.firstChild, _el$104 = _el$103.firstChild, _el$105 = _el$104.firstChild;
    _el$102.$$mousedown = handleMouseDown;
    _el$103.$$click = () => {
      if (isMinimized()) {
        setIsMinimized(false);
      }
    };
    _el$105.style.setProperty("transition", "all 0.3s");
    _el$105.style.setProperty("color", "rgba(255, 255, 255, 0.9)");
    insert(_el$104, createComponent(Show, {
      get when() {
        return !isMinimized();
      },
      get children() {
        return _tmpl$15$1();
      }
    }), null);
    insert(_el$103, createComponent(Show, {
      get when() {
        return !isMinimized();
      },
      get children() {
        var _el$107 = _tmpl$16$1(), _el$108 = _el$107.firstChild;
        _el$107.addEventListener("mouseleave", (e) => {
          e.currentTarget.style.background = "rgba(255,255,255,0.08)";
          e.currentTarget.style.borderColor = "rgba(255,255,255,0.12)";
          e.currentTarget.style.color = "rgba(255,255,255,0.5)";
        });
        _el$107.addEventListener("mouseenter", (e) => {
          e.currentTarget.style.background = "rgba(255,255,255,0.12)";
          e.currentTarget.style.borderColor = "rgba(255,255,255,0.2)";
          e.currentTarget.style.color = "rgba(255,255,255,0.8)";
        });
        _el$107.$$click = (e) => {
          e.stopPropagation();
          setIsMinimized(!isMinimized());
        };
        _el$107.style.setProperty("position", "absolute");
        _el$107.style.setProperty("top", "12px");
        _el$107.style.setProperty("right", "12px");
        _el$107.style.setProperty("background", "rgba(255,255,255,0.08)");
        _el$107.style.setProperty("border", "1px solid rgba(255,255,255,0.12)");
        _el$107.style.setProperty("color", "rgba(255,255,255,0.5)");
        _el$107.style.setProperty("fontSize", "14px");
        _el$107.style.setProperty("lineHeight", "1");
        _el$107.style.setProperty("cursor", "pointer");
        _el$107.style.setProperty("padding", "0");
        _el$107.style.setProperty("width", "28px");
        _el$107.style.setProperty("height", "28px");
        _el$107.style.setProperty("display", "flex");
        _el$107.style.setProperty("alignItems", "center");
        _el$107.style.setProperty("justifyContent", "center");
        _el$107.style.setProperty("borderRadius", "8px");
        _el$107.style.setProperty("transition", "all 0.2s");
        _el$108.style.setProperty("width", "16px");
        _el$108.style.setProperty("height", "16px");
        _el$108.style.setProperty("fill", "currentColor");
        return _el$107;
      }
    }), null);
    insert(_el$102, createComponent(Show, {
      get when() {
        return !isMinimized();
      },
      get children() {
        return createComponent(For, {
          each: sections,
          children: (section) => (() => {
            var _el$109 = _tmpl$18$1(), _el$110 = _el$109.firstChild, _el$111 = _el$110.firstChild, _el$112 = _el$111.firstChild, _el$113 = _el$112.nextSibling, _el$114 = _el$110.nextSibling, _el$115 = _el$114.firstChild;
            _el$110.$$click = () => toggleSection(section.id);
            insert(_el$112, () => section.icon);
            insert(_el$113, () => section.title);
            insert(_el$115, () => section.content());
            createRenderEffect(() => className(_el$109, `debug-section ${expandedSections()[section.id] ? "expanded" : ""}`));
            return _el$109;
          })()
        });
      }
    }), null);
    createRenderEffect((_p$) => {
      var _a, _b, _c;
      var _v$13 = `debug-panel ${isMinimized() ? "glass-button" : ""}`, _v$14 = {
        ...position().x !== null && !isMinimized() ? {
          // When dragging, use absolute positioning
          position: "fixed",
          left: `${position().x}px`,
          top: `${position().y}px`,
          transform: "none",
          // Remove transform when using absolute positioning
          width: ((_a = props.style) == null ? void 0 : _a.width) || "320px",
          maxWidth: ((_b = props.style) == null ? void 0 : _b.maxWidth) || "320px",
          zIndex: ((_c = props.style) == null ? void 0 : _c.zIndex) || 1e3
        } : !isMinimized() ? {
          // When not dragging and expanded, position at top-left
          position: "fixed",
          top: "20px",
          left: "20px",
          transform: "none",
          width: "320px",
          maxWidth: "320px",
          maxHeight: "calc(100vh - 100px)",
          // Dynamic height based on viewport
          zIndex: 1e3,
          ...props.style || {}
        } : {
          // When minimized
          position: "fixed",
          bottom: "20px",
          left: "20px",
          zIndex: 1e3,
          width: "44px",
          minWidth: "44px",
          height: "44px",
          borderRadius: "50%"
          // Changed to circle like Full View button
        },
        cursor: isDragging() ? "grabbing" : "default",
        transition: isDragging() ? "none" : "all 0.2s"
        // Remove transition during drag
      }, _v$15 = {
        cursor: isMinimized() ? "pointer" : "grab",
        ...isMinimized() ? {
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: 0
        } : {}
      }, _v$16 = isMinimized() ? "20" : "18", _v$17 = isMinimized() ? "20" : "18";
      _v$13 !== _p$.e && className(_el$102, _p$.e = _v$13);
      _p$.t = style(_el$102, _v$14, _p$.t);
      _p$.a = style(_el$103, _v$15, _p$.a);
      _v$16 !== _p$.o && setAttribute(_el$105, "width", _p$.o = _v$16);
      _v$17 !== _p$.i && setAttribute(_el$105, "height", _p$.i = _v$17);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    return _el$102;
  })();
}
delegateEvents(["input", "click", "touchstart", "touchmove", "touchend", "pointerdown", "mousedown"]);
var _tmpl$$4 = /* @__PURE__ */ template(`<span class=thermal-icon>`), _tmpl$2$3 = /* @__PURE__ */ template(`<div class=performance-indicator><span class=fps-value> FPS</span><span class=quality-icon>`);
function PerformanceIndicator(props) {
  const getStatusColor = () => {
    if (!props.status) return "#666";
    const fps = props.status.fps;
    if (fps >= 30) return "#4CAF50";
    if (fps >= 25) return "#FFC107";
    if (fps >= 20) return "#FF9800";
    return "#F44336";
  };
  const getQualityIcon = (quality) => {
    switch (quality) {
      case "high":
        return "⚡";
      case "medium":
        return "⚡";
      case "low":
        return "🔋";
      case "ultra-low":
        return "🔋";
      default:
        return "⚡";
    }
  };
  const getThermalIcon = (thermal) => {
    switch (thermal) {
      case "normal":
        return "";
      case "warm":
        return "🌡️";
      case "hot":
        return "🔥";
      case "critical":
        return "🔥🔥";
      default:
        return "";
    }
  };
  return createComponent(Show, {
    get when() {
      return props.visible && props.status;
    },
    get children() {
      var _el$ = _tmpl$2$3(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$2.nextSibling;
      insert(_el$2, () => props.status.fps, _el$3);
      insert(_el$4, () => getQualityIcon(props.status.quality));
      insert(_el$, createComponent(Show, {
        get when() {
          return props.status.thermal !== "normal";
        },
        get children() {
          var _el$5 = _tmpl$$4();
          insert(_el$5, () => getThermalIcon(props.status.thermal));
          return _el$5;
        }
      }), null);
      createRenderEffect((_$p) => (_$p = getStatusColor()) != null ? _el$.style.setProperty("color", _$p) : _el$.style.removeProperty("color"));
      return _el$;
    }
  });
}
let debugTuningState = {
  // Core OpenSeadragon settings for artifact elimination
  blendTime: {
    value: 0,
    // Start with research-recommended 0 for PNG transparency
    min: 0,
    max: 0.5,
    step: 0.01,
    description: "Tile blending duration - 0 eliminates transparency artifacts"
  },
  maxTilesPerFrame: {
    value: 1,
    // Research shows 1 prevents tile cascade
    min: 1,
    max: 6,
    step: 1,
    description: "Max concurrent tiles - lower prevents cascade artifacts"
  },
  animationTime: {
    value: 1.2,
    // Research optimal for smooth mouse wheel
    min: 0.1,
    max: 3,
    step: 0.1,
    description: "Zoom animation duration - affects smoothness"
  },
  springStiffness: {
    value: 6.5,
    // Research optimal for artifact-free zoom
    min: 1,
    max: 20,
    step: 0.5,
    description: "Animation responsiveness - affects zoom feel"
  },
  immediateRender: {
    value: false,
    // Research shows false reduces tile pop-in
    description: "Force immediate tile rendering"
  },
  imageLoaderLimit: {
    value: 2,
    // Research optimal for preventing cascade
    min: 1,
    max: 8,
    step: 1,
    description: "Concurrent image loading limit"
  },
  // Progressive quality settings
  enableProgressiveQuality: {
    value: true,
    description: "Reduce quality during zoom for smoother animation"
  },
  qualityReductionThreshold: {
    value: 2,
    // Start reducing quality below this zoom
    min: 0.5,
    max: 5,
    step: 0.1,
    description: "Zoom level to start quality reduction"
  },
  minQualityLevel: {
    value: 0.6,
    // Minimum quality during zoom
    min: 0.1,
    max: 1,
    step: 0.05,
    description: "Lowest quality during animation (0.1-1.0)"
  },
  // Mouse wheel smoothing
  enableMouseWheelSmoothing: {
    value: true,
    description: "Smooth discrete mouse wheel events"
  },
  wheelEventThrottleMs: {
    value: 16,
    // 60 FPS throttling
    min: 8,
    max: 100,
    step: 4,
    description: "Mouse wheel event throttling (ms)"
  },
  wheelZoomStep: {
    value: 0.02,
    // Small steps for smooth zoom
    min: 0.01,
    max: 0.2,
    step: 0.01,
    description: "Zoom increment per wheel tick"
  },
  // Tile cascade prevention
  enableTileCascadePrevention: {
    value: true,
    description: "Prevent multiple pyramid levels simultaneously"
  },
  maxTileLevels: {
    value: 3,
    // Research optimal for cascade prevention
    min: 1,
    max: 5,
    step: 1,
    description: "Maximum tile pyramid levels at low zoom"
  },
  cascadePreventionZoom: {
    value: 3,
    // Apply prevention below this zoom
    min: 1,
    max: 10,
    step: 0.5,
    description: "Zoom threshold for cascade prevention"
  },
  // Browser-specific optimizations
  forceSafariCanvas: {
    value: true,
    description: "Force Canvas renderer on Safari (40-50% performance boost)"
  },
  disableWebGLOnMobile: {
    value: true,
    description: "Disable WebGL on mobile devices (research shows 15 FPS improvement)"
  },
  // Tile overlap for seam prevention
  tileOverlap: {
    value: 1,
    // Research shows 1px prevents seams
    min: 0,
    max: 4,
    step: 1,
    description: "Tile overlap in pixels (prevents seams)"
  },
  // Mouse wheel smoothing parameters (added for debug tuning)
  wheelEventThrottleMs: {
    value: 16,
    // 60 FPS throttling
    min: 8,
    max: 100,
    step: 4,
    description: "Mouse wheel event throttling (ms)"
  },
  wheelZoomStep: {
    value: 0.02,
    // Small steps for smooth zoom
    min: 0.01,
    max: 0.2,
    step: 0.01,
    description: "Zoom increment per wheel tick"
  }
};
function applyTuningToViewer(viewer, performanceConfig) {
  if (!viewer || !performanceConfig) return;
  const state = debugTuningState;
  viewer.blendTime = state.blendTime.value;
  viewer.animationTime = state.animationTime.value;
  viewer.springStiffness = state.springStiffness.value;
  performanceConfig.viewer.blendTime = state.blendTime.value;
  performanceConfig.viewer.maxTilesPerFrame = state.maxTilesPerFrame.value;
  performanceConfig.viewer.animationTime = state.animationTime.value;
  performanceConfig.viewer.springStiffness = state.springStiffness.value;
  performanceConfig.viewer.immediateRender = state.immediateRender.value;
  performanceConfig.viewer.imageLoaderLimit = state.imageLoaderLimit.value;
  if (performanceConfig.viewer.artifactElimination) {
    performanceConfig.viewer.artifactElimination.enableTileCascadePrevention = state.enableTileCascadePrevention.value;
    performanceConfig.viewer.artifactElimination.enableBlendingOptimization = state.blendTime.value === 0;
    performanceConfig.viewer.artifactElimination.enableMouseWheelSmoothing = state.enableMouseWheelSmoothing.value;
    performanceConfig.viewer.artifactElimination.enableProgressiveQuality = state.enableProgressiveQuality.value;
  }
  if (viewer.forceRedraw) {
    viewer.forceRedraw();
  }
  console.log("Applied debug tuning values:", {
    blendTime: state.blendTime.value,
    maxTilesPerFrame: state.maxTilesPerFrame.value,
    animationTime: state.animationTime.value,
    springStiffness: state.springStiffness.value
  });
}
function updateTuningParameter(key, value) {
  if (debugTuningState[key]) {
    if (typeof debugTuningState[key].value === "boolean") {
      debugTuningState[key].value = Boolean(value);
    } else {
      debugTuningState[key].value = Number(value);
    }
    localStorage.setItem(`debugTuning_${key}`, String(debugTuningState[key].value));
    if (window.viewer) {
      applyTuningToViewer(window.viewer, window.performanceConfig);
    }
    console.log(`Updated tuning parameter ${key}:`, debugTuningState[key].value);
  }
}
function loadSavedTuningValues() {
  Object.keys(debugTuningState).forEach((key) => {
    const savedValue = localStorage.getItem(`debugTuning_${key}`);
    if (savedValue !== null) {
      if (typeof debugTuningState[key].value === "boolean") {
        debugTuningState[key].value = savedValue === "true";
      } else {
        debugTuningState[key].value = Number(savedValue);
      }
    }
  });
  console.log("Loaded saved tuning values:", debugTuningState);
}
function resetTuningToDefaults() {
  const defaults = {
    blendTime: 0,
    // Eliminate transparency artifacts
    maxTilesPerFrame: 1,
    // Prevent cascade
    animationTime: 1.2,
    // Optimal smoothness
    springStiffness: 6.5,
    // Balanced responsiveness
    immediateRender: false,
    // Reduce pop-in
    imageLoaderLimit: 2,
    // Prevent cascade
    enableProgressiveQuality: true,
    qualityReductionThreshold: 2,
    minQualityLevel: 0.6,
    enableMouseWheelSmoothing: true,
    wheelEventThrottleMs: 16,
    wheelZoomStep: 0.02,
    enableTileCascadePrevention: true,
    maxTileLevels: 3,
    cascadePreventionZoom: 3,
    forceSafariCanvas: true,
    disableWebGLOnMobile: true,
    tileOverlap: 1,
    wheelEventThrottleMs: 16,
    wheelZoomStep: 0.02
  };
  Object.keys(defaults).forEach((key) => {
    if (debugTuningState[key]) {
      debugTuningState[key].value = defaults[key];
      localStorage.setItem(`debugTuning_${key}`, String(defaults[key]));
    }
  });
  if (window.viewer) {
    applyTuningToViewer(window.viewer, window.performanceConfig);
  }
  console.log("Reset tuning to research-based defaults");
}
function exportTuningConfig() {
  const config = {};
  Object.keys(debugTuningState).forEach((key) => {
    config[key] = debugTuningState[key].value;
  });
  const configString = JSON.stringify(config, null, 2);
  if (navigator.clipboard) {
    navigator.clipboard.writeText(configString);
    console.log("Tuning config copied to clipboard:", config);
  }
  return config;
}
function getTuningState() {
  return debugTuningState;
}
function initializeDebugTuning() {
  loadSavedTuningValues();
  window.debugTuning = {
    state: debugTuningState,
    update: updateTuningParameter,
    reset: resetTuningToDefaults,
    export: exportTuningConfig,
    apply: applyTuningToViewer
  };
}
class FullscreenManager {
  constructor() {
    this.support = this.detectSupport();
  }
  /**
   * Detect available fullscreen API with vendor prefixes
   */
  detectSupport() {
    const element = document.documentElement;
    if (element.requestFullscreen) {
      return {
        request: "requestFullscreen",
        exit: "exitFullscreen",
        element: "fullscreenElement",
        enabled: "fullscreenEnabled",
        change: "fullscreenchange",
        error: "fullscreenerror"
      };
    } else if (element.webkitRequestFullscreen) {
      return {
        request: "webkitRequestFullscreen",
        exit: "webkitExitFullscreen",
        element: "webkitFullscreenElement",
        enabled: "webkitFullscreenEnabled",
        change: "webkitfullscreenchange",
        error: "webkitfullscreenerror"
      };
    } else if (element.webkitRequestFullScreen) {
      return {
        request: "webkitRequestFullScreen",
        exit: "webkitCancelFullScreen",
        element: "webkitCurrentFullScreenElement",
        enabled: "webkitFullScreenEnabled",
        change: "webkitfullscreenchange",
        error: "webkitfullscreenerror"
      };
    } else if (element.mozRequestFullScreen) {
      return {
        request: "mozRequestFullScreen",
        exit: "mozCancelFullScreen",
        element: "mozFullScreenElement",
        enabled: "mozFullScreenEnabled",
        change: "mozfullscreenchange",
        error: "mozfullscreenerror"
      };
    } else if (element.msRequestFullscreen) {
      return {
        request: "msRequestFullscreen",
        exit: "msExitFullscreen",
        element: "msFullscreenElement",
        enabled: "msFullscreenEnabled",
        change: "MSFullscreenChange",
        error: "MSFullscreenError"
      };
    }
    return null;
  }
  /**
   * Check if fullscreen is supported
   */
  isSupported() {
    return this.support !== null;
  }
  /**
   * Check if fullscreen is enabled (not blocked by iframe, etc.)
   */
  isEnabled() {
    if (!this.support) return false;
    return document[this.support.enabled] === true;
  }
  /**
   * Request fullscreen for an element
   */
  async requestFullscreen(element = document.documentElement) {
    if (!this.support) {
      console.warn("Fullscreen API not supported");
      return false;
    }
    try {
      const promise = element[this.support.request]();
      if (promise && typeof promise.then === "function") {
        await promise;
      }
      return true;
    } catch (error) {
      console.error("Fullscreen request failed:", error);
      return false;
    }
  }
  /**
   * Exit fullscreen
   */
  async exitFullscreen() {
    if (!this.support) return false;
    try {
      const promise = document[this.support.exit]();
      if (promise && typeof promise.then === "function") {
        await promise;
      }
      return true;
    } catch (error) {
      console.error("Exit fullscreen failed:", error);
      return false;
    }
  }
  /**
   * Toggle fullscreen
   */
  async toggleFullscreen(element = document.documentElement) {
    if (this.isFullscreen()) {
      return await this.exitFullscreen();
    } else {
      return await this.requestFullscreen(element);
    }
  }
  /**
   * Check if currently in fullscreen
   */
  isFullscreen() {
    if (!this.support) return false;
    return !!document[this.support.element];
  }
  /**
   * Get the current fullscreen element
   */
  getFullscreenElement() {
    if (!this.support) return null;
    return document[this.support.element];
  }
  /**
   * Add fullscreen change event listener
   */
  addChangeListener(callback) {
    if (!this.support) return () => {
    };
    document.addEventListener(this.support.change, callback);
    return () => document.removeEventListener(this.support.change, callback);
  }
  /**
   * Add fullscreen error event listener
   */
  addErrorListener(callback) {
    if (!this.support) return () => {
    };
    document.addEventListener(this.support.error, callback);
    return () => document.removeEventListener(this.support.error, callback);
  }
}
const fullscreenManager = new FullscreenManager();
var _tmpl$$3 = /* @__PURE__ */ template(`<img class=preview-image alt="Loading preview">`), _tmpl$2$2 = /* @__PURE__ */ template(`<div class=viewer-loading><p>Loading high-resolution artwork...</p><p style=font-size:12px;margin-top:10px;opacity:0.7;>Debug: isLoading=<!>, viewerReady=`), _tmpl$3$2 = /* @__PURE__ */ template(`<div style=margin-bottom:16px;><div style=display:flex;align-items:center;justify-content:space-between;><label style=font-size:11px;color:rgba(255,255,255,0.8);>Smooth Interpolation</label><button></button></div><div style=font-size:10px;color:rgba(255,255,255,0.5);margin-top:4px;>OFF = Perfect sync, ON = Smooth movement`), _tmpl$4$2 = /* @__PURE__ */ template(`<div style=margin-bottom:12px;><label style=font-size:11px;color:rgba(255,255,255,0.8);display:block;margin-bottom:6px;>Smoothing: </label><input type=range min=0.1 max=1.0 step=0.05><div style=font-size:10px;color:rgba(255,255,255,0.5);margin-top:4px;>Lower = smoother, Higher = more responsive`), _tmpl$5$2 = /* @__PURE__ */ template(`<div style=margin-bottom:12px;><label style=font-size:11px;color:rgba(255,255,255,0.8);display:block;margin-bottom:6px;>Zoom fade distance: <!>%</label><input type=range min=0.1 max=1.0 step=0.05><div style=font-size:10px;color:rgba(255,255,255,0.5);margin-top:4px;>Darkness gradually fades when zooming below this level`), _tmpl$6$2 = /* @__PURE__ */ template(`<div style=margin-bottom:12px;><label style=font-size:11px;color:rgba(255,255,255,0.8);display:block;margin-bottom:6px;>Pan fade distance: <!>%</label><input type=range min=0.1 max=1.0 step=0.05><div style=font-size:10px;color:rgba(255,255,255,0.5);margin-top:4px;>Darkness gradually fades as you pan away this distance`), _tmpl$7$2 = /* @__PURE__ */ template(`<div><div><div style=font-size:12px;color:#FFFFFF;font-weight:600;letter-spacing:0.5px;text-align:center;>SPOTLIGHT FINE-TUNING</div><button>✕</button></div><div class=floating-panel-scrollable><div style=margin-bottom:12px;><label style=font-size:11px;color:rgba(255,255,255,0.8);display:block;margin-bottom:6px;>Circle Size: </label><input type=range max=3.0 step=0.05>`), _tmpl$8$2 = /* @__PURE__ */ template(`<button aria-label="Expand to Full View"><svg width=24 height=24 viewBox="0 0 24 24"fill=none><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round>`), _tmpl$9$2 = /* @__PURE__ */ template(`<div class=fullscreen-button-container><button class="fullscreen-button glass-button">`), _tmpl$0$2 = /* @__PURE__ */ template(`<div class=viewer-container><div class=openseadragon-viewer>`), _tmpl$1$1 = /* @__PURE__ */ template(`<svg width=20 height=20 viewBox="0 0 20 20"fill=none><path d="M5 1v4H1M15 1v4h4M5 19v-4H1M15 19v-4h4"stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round>`), _tmpl$10$1 = /* @__PURE__ */ template(`<svg width=20 height=20 viewBox="0 0 20 20"fill=none><path d="M1 5V1h4M19 5V1h-4M1 15v4h4M19 15v4h-4"stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round>`);
let hotspotData = [];
function ArtworkViewer(props) {
  let viewerRef;
  const [viewer, setViewer] = createSignal(null);
  let intervals = {};
  const state = useViewerState();
  const [animations, setAnimations] = createSignal(null);
  const recreateOverlayManager = (newType) => {
    console.log(`Switching overlay system to: ${newType}`);
    try {
      state.setCurrentOverlayType(newType);
      if (state.components().overlayManager && typeof state.components().overlayManager.destroy === "function") {
        console.log("Destroying old overlay manager");
        state.components().overlayManager.destroy();
      }
      OverlayManagerFactory.setPreference(newType);
      console.log("Creating new overlay manager with type:", newType);
      const newOverlayManager = OverlayManagerFactory.createWithOverride(viewer());
      newOverlayManager.initialize();
      if (newType === "canvas2d" && newOverlayManager.setAutoDeselectThreshold) {
        const threshold = state.autoDeselectThreshold();
        newOverlayManager.setAutoDeselectThreshold(threshold);
        console.log("Set auto-deselect threshold on new Canvas2D manager:", threshold);
      }
      state.setComponents((prev) => ({
        ...prev,
        overlayManager: newOverlayManager
      }));
      window.overlayManager = newOverlayManager;
      if (state.selectedHotspot()) {
        console.log("Re-selecting hotspot after overlay switch:", state.selectedHotspot().id);
        setTimeout(() => {
          newOverlayManager.selectHotspot(state.selectedHotspot());
        }, 100);
      }
      console.log("Overlay system switch completed successfully");
    } catch (error) {
      console.error("Error switching overlay system:", error);
      alert("Error switching overlay system. Please refresh the page to continue.");
    }
  };
  const cleanup = () => {
    if (intervals.handleKeyPress) {
      window.removeEventListener("keydown", intervals.handleKeyPress);
    }
    if (intervals.fullscreenCleanup) {
      intervals.fullscreenCleanup();
    }
    Object.values(intervals).forEach((interval) => {
      if (typeof interval === "number") clearInterval(interval);
    });
    if (intervals.performanceUpdate) {
      clearInterval(intervals.performanceUpdate);
    }
    if (state.components().resizeObserver && viewerRef) {
      state.components().resizeObserver.disconnect();
    }
    Object.values(state.components()).forEach((component) => {
      if (component && typeof component.destroy === "function") {
        component.destroy();
      }
    });
    if (state.components().unifiedPerformanceMonitor) {
      state.components().unifiedPerformanceMonitor.destroy();
    }
    if (viewer()) viewer().destroy();
    ["performanceMonitor", "viewer", "tileOptimizer", "lowZoomOptimizer", "safariPerformanceOptimizer", "unifiedPerformanceMonitor"].forEach((prop) => {
      if (window[prop] === state.components()[prop] || window[prop] === viewer()) {
        delete window[prop];
      }
    });
  };
  const handleHotspotClick = async (hotspot) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    console.log("handleHotspotClick called in ArtworkViewer", {
      hotspotId: hotspot ? hotspot.id : "null (deselecting)",
      isZoomingToHotspot: state.isZoomingToHotspot(),
      isExpandingToFullView: state.isExpandingToFullView(),
      timestamp: Date.now()
    });
    if (state.isZoomingToHotspot()) {
      console.log("🔧 FORCE RESET: Clearing stuck isZoomingToHotspot state");
      state.setIsZoomingToHotspot(false);
      if (state.components().renderOptimizer) {
        state.components().renderOptimizer.endCinematicZoom();
      }
      if (state.components().renderer) {
        state.components().renderer.resumeUpdates();
        if (isMobile()) {
          state.components().renderer.showOverlay();
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 16));
    }
    console.log("Components available?", !!state.components());
    console.log("OverlayManager available?", !!((_a = state.components()) == null ? void 0 : _a.overlayManager));
    console.log("OverlayManager type:", (_c = (_b = state.components()) == null ? void 0 : _b.overlayManager) == null ? void 0 : _c.constructor.name);
    console.log("OverlayManager initialized?", (_e = (_d = state.components()) == null ? void 0 : _d.overlayManager) == null ? void 0 : _e.isInitialized);
    if (!hotspot) {
      state.setSelectedHotspot(null);
      state.setShowMediaButton(false);
      state.setCurrentMediaHotspot(null);
      if (state.components().overlayManager) {
        console.log("Calling overlayManager.clearSelection()");
        state.components().overlayManager.clearSelection();
      } else {
        console.error("No overlay manager available for clearSelection!");
      }
      return;
    }
    if (state.isExpandingToFullView()) {
      console.log("Interrupting Full View animation for hotspot click");
      (_f = viewer()) == null ? void 0 : _f.viewport.stopAnimation();
      (_g = animations()) == null ? void 0 : _g.cleanupExpandAnimation();
      state.setIsExpandingToFullView(false);
      if (state.components().renderOptimizer) {
        state.components().renderOptimizer.endCinematicZoom();
      }
      if (state.components().renderer) {
        state.components().renderer.resumeUpdates();
        if (isMobile()) {
          state.components().renderer.showOverlay();
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
    if (state.isZoomingToHotspot()) {
      console.log("WARNING: isZoomingToHotspot was still true, forcing reset");
      state.setIsZoomingToHotspot(false);
    }
    state.setShowMediaButton(false);
    state.setSelectedHotspot(hotspot);
    console.log("🔍 Checking renderer for setVisualSelectedState:", {
      hasRenderer: !!state.components().renderer,
      hasMethod: !!(state.components().renderer && state.components().renderer.setVisualSelectedState),
      rendererType: (_i = (_h = state.components().renderer) == null ? void 0 : _h.constructor) == null ? void 0 : _i.name
    });
    if (state.components().renderer && state.components().renderer.setVisualSelectedState) {
      console.log("🎯 Setting visual selected state for:", hotspot.id);
      state.components().renderer.setVisualSelectedState(hotspot);
    } else {
      console.warn("⚠️ Cannot set visual selected state - renderer or method not available");
    }
    if ((_j = state.components()) == null ? void 0 : _j.overlayManager) {
      console.log("Calling overlayManager.selectHotspot with:", (hotspot == null ? void 0 : hotspot.id) || "null");
      console.log("Hotspot data being passed:", hotspot);
      console.log("OverlayManager method exists?", typeof state.components().overlayManager.selectHotspot);
      try {
        const renderer = state.components().renderer;
        let animationParams = {};
        if (renderer && hotspot) {
          const duration = renderer.getAnimationDuration ? renderer.getAnimationDuration(hotspot.id) : 0.8;
          const easing = renderer.timingEasing || "cubic-bezier(0.25, 0.40, 0.40, 0.90)";
          animationParams = {
            duration,
            timingEasing: easing
          };
          console.log("Animation params for Safari:", animationParams);
        }
        state.components().overlayManager.selectHotspot(hotspot, animationParams);
        console.log("selectHotspot call completed");
      } catch (error) {
        console.error("Error calling selectHotspot:", error);
      }
    } else {
      console.error("No overlay manager available in components!");
      console.error("Components object:", state.components());
    }
    const hasImage = hotspot.image_url_1 || ((_k = state.components().imageOverlayManager) == null ? void 0 : _k.getOverlay(hotspot.id));
    if (hasImage) {
      if (state.components().imageOverlayManager.shouldAutoReveal(hotspot.id)) {
        handleMediaButtonClick(hotspot.id);
      } else if (state.components().imageOverlayManager.shouldShowButton(hotspot.id)) ;
    }
    console.log("🎯 FIXED: Guaranteed zoom to hotspot:", hotspot.id);
    try {
      await ((_l = animations()) == null ? void 0 : _l.zoomToHotspot(hotspot));
    } catch (error) {
      console.error("Zoom failed, forcing state reset:", error);
      state.setIsZoomingToHotspot(false);
    }
  };
  const handleMediaButtonClick = (hotspotId) => {
    console.log("Media button clicked for:", hotspotId);
    state.setShowMediaButton(false);
    if (state.components().imageOverlayManager) {
      state.components().imageOverlayManager.openOverlay(hotspotId);
    }
  };
  const toggleFullscreen = async () => {
    try {
      const success = await fullscreenManager.toggleFullscreen();
      if (!success) {
        console.log("Fullscreen toggle failed or not supported");
      }
    } catch (err) {
      console.error("Error toggling fullscreen:", err);
    }
  };
  const handleFullscreenClick = (event) => {
    const button = event.currentTarget;
    addGlassButtonEffects(event, button);
    toggleFullscreen();
  };
  window.artworkViewerHandleHotspotClick = handleHotspotClick;
  onMount(async () => {
    initializeDebugTuning();
    try {
      const response = await fetch(`/data/hotspots.json?t=${Date.now()}`);
      hotspotData = await response.json();
      console.log(`Loaded ${hotspotData.length} hotspots`);
    } catch (error) {
      console.error("Failed to load hotspots:", error);
      hotspotData = [];
    }
    const previewImg = new Image();
    previewImg.onload = () => state.setPreviewLoaded(true);
    previewImg.src = `/images/tiles/${props.artworkId}_1024/preview.jpg`;
    console.log("About to import and initialize viewer...");
    const {
      initializeViewer
    } = await __vitePreload(async () => {
      const {
        initializeViewer: initializeViewer2
      } = await import("./viewerSetup-B6gRBkjn.js").then((n) => n.v);
      return {
        initializeViewer: initializeViewer2
      };
    }, true ? [] : void 0);
    const stateRefs = {
      setIsLoading: state.setIsLoading,
      setViewerReady: state.setViewerReady
    };
    const result = await initializeViewer(viewerRef, props, state, handleHotspotClick);
    console.log("Viewer initialization result:", result);
    setViewer(result.viewer);
    intervals = result.intervals;
    result.homeViewport;
    console.log("Viewer assigned:", !!result.viewer);
    const animationHooks = useViewerAnimations(result.viewer, state, state.components);
    setAnimations(animationHooks);
    window.animations = animationHooks;
    console.log("Animation hooks set:", !!animationHooks);
    const failsafeTimer = setTimeout(() => {
      var _a;
      if (state.isLoading()) {
        console.warn("⚠️ Failsafe: Force hiding loading screen after 5 seconds");
        stateRefs.setIsLoading(false);
        stateRefs.setViewerReady(true);
        if (result.viewer && ((_a = result.viewer.world) == null ? void 0 : _a.getItemCount()) > 0) {
          console.log("Viewer has items, forcing ready state");
        }
      }
    }, 5e3);
    if (isMobile() && state.currentOverlayType() !== "canvas2d") {
      console.log("Setting Canvas2D overlay manager for mobile performance optimization");
      recreateOverlayManager("canvas2d");
    }
    setTimeout(() => {
      var _a, _b;
      if ((_a = state.components().overlayManager) == null ? void 0 : _a.setAutoDeselectThreshold) {
        const threshold = state.autoDeselectThreshold();
        state.components().overlayManager.setAutoDeselectThreshold(threshold);
        console.log("ArtworkViewer: Set auto-deselect threshold after mount:", threshold);
      }
      if ((_b = state.components().overlayManager) == null ? void 0 : _b.state) {
        const panThreshold = state.panDeselectThreshold();
        state.components().overlayManager.state.panThreshold = panThreshold;
        console.log("ArtworkViewer: Set pan threshold after mount:", panThreshold);
      }
    }, 500);
    const handleFullscreenChange = () => {
      state.setIsFullscreen(fullscreenManager.isFullscreen());
    };
    const removeListener = fullscreenManager.addChangeListener(handleFullscreenChange);
    intervals.fullscreenCleanup = removeListener;
    const handleMove = (e) => {
      if (state.isDragging()) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        state.setPanelPosition({
          x: clientX - state.dragStart().x,
          y: clientY - state.dragStart().y
        });
      }
    };
    const handleTouchMove = (e) => {
      if (state.isDragging()) {
        e.preventDefault();
        handleMove(e);
      }
    };
    const handleEnd = () => {
      state.setIsDragging(false);
    };
    window.addEventListener("mousemove", handleMove);
    window.addEventListener("mouseup", handleEnd, {
      passive: true
    });
    window.addEventListener("touchmove", handleTouchMove, {
      passive: false
    });
    window.addEventListener("touchend", handleEnd, {
      passive: true
    });
    onCleanup(() => {
      window.removeEventListener("mousemove", handleMove);
      window.removeEventListener("mouseup", handleEnd);
      window.removeEventListener("touchmove", handleTouchMove);
      window.removeEventListener("touchend", handleEnd);
      clearTimeout(failsafeTimer);
      if (typeof cleanup === "function") {
        cleanup();
      }
    });
  });
  return (() => {
    var _el$ = _tmpl$0$2(), _el$3 = _el$.firstChild;
    insert(_el$, createComponent(Show, {
      get when() {
        return memo(() => !!state.previewLoaded())() && !state.viewerReady();
      },
      get children() {
        var _el$2 = _tmpl$$3();
        createRenderEffect(() => setAttribute(_el$2, "src", `/images/tiles/${props.artworkId}_1024/preview.jpg`));
        return _el$2;
      }
    }), _el$3);
    use((el) => {
      viewerRef = el;
      console.log("ViewerRef assigned:", !!el);
    }, _el$3);
    insert(_el$, createComponent(Show, {
      get when() {
        return state.isLoading();
      },
      get children() {
        var _el$4 = _tmpl$2$2(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling, _el$7 = _el$6.firstChild, _el$9 = _el$7.nextSibling;
        _el$9.nextSibling;
        insert(_el$6, () => String(state.isLoading()), _el$9);
        insert(_el$6, () => String(state.viewerReady()), null);
        return _el$4;
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return state.viewerReady();
      },
      get children() {
        return [createComponent(PerformanceIndicator, {
          get visible() {
            return isMobile();
          },
          get status() {
            return state.performanceStatus();
          }
        }), createComponent(DebugPanel, {
          get style() {
            return {
              position: "fixed",
              top: "10px",
              right: "10px",
              width: isMobile() ? "90%" : "320px",
              maxWidth: "320px",
              zIndex: 1e3
            };
          },
          get selectedHotspot() {
            return state.selectedHotspot;
          },
          get hoveredHotspot() {
            return state.hoveredHotspot;
          },
          get totalHotspots() {
            return hotspotData.length;
          },
          get visibleHotspotCount() {
            var _a, _b;
            return (_b = (_a = state.components().renderer) == null ? void 0 : _a.visibleOverlays) == null ? void 0 : _b.size;
          },
          get revealStyle() {
            return state.revealStyle;
          },
          get setRevealStyle() {
            return state.updateRevealStyle;
          },
          get revealType() {
            return state.revealType;
          },
          get setRevealType() {
            return state.setRevealType;
          },
          get borderStyle() {
            return state.borderStyle;
          },
          get updateBorderStyle() {
            return state.updateBorderStyle;
          },
          get performanceMetrics() {
            return state.performanceMetrics();
          },
          get zoomSpeed() {
            return state.zoomSpeedMultiplier;
          },
          get setZoomSpeed() {
            return state.setZoomSpeedMultiplier;
          },
          get setDebugLevel() {
            return state.setDebugLevel;
          },
          get currentPalette() {
            return state.currentPalette;
          },
          setPalette: (palette) => {
            var _a;
            if (window.setHotspotPalette) {
              window.setHotspotPalette(palette);
              state.setCurrentPalette(palette);
              (_a = viewer()) == null ? void 0 : _a.forceRedraw();
            }
          },
          get interactionMode() {
            return state.interactionMode;
          },
          setInteractionMode: (mode) => {
            var _a;
            state.setInteractionMode(mode);
            localStorage.setItem("interactionMode", mode);
            if ((_a = state.components().renderer) == null ? void 0 : _a.modeStateManager) {
              state.components().renderer.modeStateManager.setMode(mode);
            }
          },
          get overlayType() {
            return state.currentOverlayType();
          },
          toggleOverlay: (newType) => {
            console.log("DebugPanel requesting overlay switch to:", newType);
            recreateOverlayManager(newType);
          },
          get safariOptimizerState() {
            var _a, _b;
            return (_b = (_a = state.components().safariPerformanceOptimizer) == null ? void 0 : _a.getState) == null ? void 0 : _b.call(_a);
          },
          get safariHybridMetrics() {
            return state.safariHybridMetrics();
          },
          debugMetrics: () => {
            var _a, _b, _c, _d, _e, _f;
            const cinematicManager = window.cinematicZoomManager;
            if (!cinematicManager) return {};
            if (!((_a = cinematicManager.adaptiveRenderer) == null ? void 0 : _a.isInitialized)) {
              console.log("🔄 Initializing adaptive renderer for metrics...");
              (_b = cinematicManager.adaptiveRenderer) == null ? void 0 : _b.initialize().then(() => {
                console.log("✅ Adaptive renderer initialized");
                state.setPerformanceMetrics((prev) => ({
                  ...prev,
                  _forceUpdate: Date.now()
                }));
              }).catch((err) => {
                console.error("❌ Failed to initialize adaptive renderer:", err);
              });
              return {
                tier: "initializing...",
                targetFPS: "...",
                effects: [],
                gpu: "detecting..."
              };
            }
            if (cinematicManager.adaptiveRenderer) {
              const metrics = cinematicManager.adaptiveRenderer.getMetrics();
              return {
                tier: metrics.tier,
                targetFPS: (_c = metrics.settings) == null ? void 0 : _c.targetFPS,
                effects: (_d = metrics.settings) == null ? void 0 : _d.effects,
                gpu: ((_f = (_e = metrics.capabilities) == null ? void 0 : _e.gpu) == null ? void 0 : _f.tier) || "unknown"
              };
            }
            return {};
          },
          isMobile: () => isMobile(),
          get showFloatingPanel() {
            return state.showFloatingPanel;
          },
          get setShowFloatingPanel() {
            return state.setShowFloatingPanel;
          }
        })];
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return state.showFloatingPanel() && false;
      },
      get children() {
        var _el$0 = _tmpl$7$2(), _el$1 = _el$0.firstChild, _el$10 = _el$1.firstChild, _el$11 = _el$10.nextSibling, _el$12 = _el$1.nextSibling, _el$13 = _el$12.firstChild, _el$14 = _el$13.firstChild;
        _el$14.firstChild;
        var _el$16 = _el$14.nextSibling;
        _el$0.style.setProperty("position", "fixed");
        _el$0.style.setProperty("width", "220px");
        _el$0.style.setProperty("background", "rgba(20,20,20,0.85)");
        _el$0.style.setProperty("border", "1px solid rgba(255,255,255,0.2)");
        _el$0.style.setProperty("borderRadius", "12px");
        _el$0.style.setProperty("boxShadow", "0 8px 32px rgba(0,0,0,0.6)");
        _el$0.style.setProperty("zIndex", "10000");
        _el$0.style.setProperty("userSelect", "none");
        _el$0.style.setProperty("backdropFilter", "blur(20px)");
        _el$0.style.setProperty("-webkit-backdrop-filter", "blur(20px)");
        _el$0.style.setProperty("display", "flex");
        _el$0.style.setProperty("flexDirection", "column");
        _el$0.style.setProperty("overflowY", "auto");
        _el$0.style.setProperty("overflowX", "hidden");
        _el$1.$$touchstart = (e) => {
          const touch = e.touches[0];
          state.setIsDragging(true);
          state.setDragStart({
            x: touch.clientX - state.panelPosition().x,
            y: touch.clientY - state.panelPosition().y
          });
        };
        _el$1.$$mousedown = (e) => {
          state.setIsDragging(true);
          state.setDragStart({
            x: e.clientX - state.panelPosition().x,
            y: e.clientY - state.panelPosition().y
          });
        };
        _el$1.style.setProperty("position", "relative");
        _el$1.style.setProperty("padding", "12px 40px 12px 16px");
        _el$1.style.setProperty("borderBottom", "1px solid rgba(255,255,255,0.1)");
        _el$1.style.setProperty("cursor", "grab");
        _el$1.style.setProperty("background", "rgba(255,255,255,0.03)");
        _el$1.style.setProperty("borderRadius", "12px 12px 0 0");
        _el$11.$$click = () => state.setShowFloatingPanel(false);
        _el$11.addEventListener("mouseleave", (e) => {
          e.target.style.background = "transparent";
          e.target.style.color = "rgba(255,255,255,0.5)";
        });
        _el$11.addEventListener("mouseenter", (e) => {
          e.target.style.background = "rgba(255,255,255,0.1)";
          e.target.style.color = "rgba(255,255,255,0.8)";
        });
        _el$11.style.setProperty("position", "absolute");
        _el$11.style.setProperty("top", "8px");
        _el$11.style.setProperty("right", "8px");
        _el$11.style.setProperty("background", "transparent");
        _el$11.style.setProperty("border", "none");
        _el$11.style.setProperty("color", "rgba(255,255,255,0.5)");
        _el$11.style.setProperty("fontSize", "16px");
        _el$11.style.setProperty("cursor", "pointer");
        _el$11.style.setProperty("padding", "4px");
        _el$11.style.setProperty("width", "24px");
        _el$11.style.setProperty("height", "24px");
        _el$11.style.setProperty("display", "flex");
        _el$11.style.setProperty("alignItems", "center");
        _el$11.style.setProperty("justifyContent", "center");
        _el$11.style.setProperty("borderRadius", "4px");
        _el$11.style.setProperty("transition", "all 0.2s");
        _el$12.style.setProperty("padding", "16px");
        _el$12.style.setProperty("overflowY", "auto");
        _el$12.style.setProperty("overflowX", "hidden");
        _el$12.style.setProperty("flex", "1");
        _el$12.style.setProperty("WebkitOverflowScrolling", "touch");
        _el$12.style.setProperty("scrollbarWidth", "thin");
        _el$12.style.setProperty("scrollbarColor", "rgba(255, 255, 255, 0.2) rgba(255, 255, 255, 0.05)");
        insert(_el$14, () => state.circleMultiplierValue().toFixed(2), null);
        _el$16.$$input = (e) => {
          const value = parseFloat(e.target.value);
          state.setCircleMultiplierValue(value);
          if (window.safariTuning) {
            window.safariTuning.circleMultiplier = value;
            if (state.components().overlayManager && state.selectedHotspot()) {
              state.components().overlayManager.forceRecalculation();
            }
          }
        };
        _el$16.style.setProperty("width", "100%");
        _el$16.style.setProperty("height", "20px");
        _el$16.style.setProperty("background", "rgba(255,255,255,0.1)");
        _el$16.style.setProperty("borderRadius", "10px");
        _el$16.style.setProperty("outline", "none");
        _el$16.style.setProperty("appearance", "none");
        _el$16.style.setProperty("WebkitAppearance", "none");
        insert(_el$12, createComponent(Show, {
          get when() {
            return state.currentOverlayType() === "canvas2d";
          },
          get children() {
            return [(() => {
              var _el$17 = _tmpl$3$2(), _el$18 = _el$17.firstChild, _el$19 = _el$18.firstChild, _el$20 = _el$19.nextSibling;
              _el$20.$$click = () => {
                var _a, _b, _c;
                const newValue = !(((_a = state.interpolationEnabled) == null ? void 0 : _a.call(state)) ?? true);
                (_b = state.setInterpolationEnabled) == null ? void 0 : _b.call(state, newValue);
                if ((_c = state.components().overlayManager) == null ? void 0 : _c.setInterpolation) {
                  state.components().overlayManager.setInterpolation(newValue);
                }
              };
              _el$20.style.setProperty("border", "none");
              _el$20.style.setProperty("borderRadius", "12px");
              _el$20.style.setProperty("padding", "4px 12px");
              _el$20.style.setProperty("fontSize", "10px");
              _el$20.style.setProperty("color", "white");
              _el$20.style.setProperty("cursor", "pointer");
              _el$20.style.setProperty("transition", "background 0.2s");
              insert(_el$20, () => {
                var _a;
                return ((_a = state.interpolationEnabled) == null ? void 0 : _a.call(state)) ?? true ? "ON" : "OFF";
              });
              createRenderEffect((_$p) => {
                var _a;
                return (_$p = ((_a = state.interpolationEnabled) == null ? void 0 : _a.call(state)) ?? true ? "rgba(76, 175, 80, 0.8)" : "rgba(255,255,255,0.2)") != null ? _el$20.style.setProperty("background", _$p) : _el$20.style.removeProperty("background");
              });
              return _el$17;
            })(), createComponent(Show, {
              get when() {
                var _a;
                return ((_a = state.interpolationEnabled) == null ? void 0 : _a.call(state)) ?? true;
              },
              get children() {
                var _el$21 = _tmpl$4$2(), _el$22 = _el$21.firstChild;
                _el$22.firstChild;
                var _el$24 = _el$22.nextSibling;
                insert(_el$22, () => {
                  var _a;
                  return ((_a = state.smoothingFactorValue) == null ? void 0 : _a.call(state)) || 0.8;
                }, null);
                _el$24.$$input = (e) => {
                  var _a, _b;
                  const value = parseFloat(e.target.value);
                  (_a = state.setSmoothingFactorValue) == null ? void 0 : _a.call(state, value);
                  if ((_b = state.components().overlayManager) == null ? void 0 : _b.setSmoothingFactor) {
                    state.components().overlayManager.setSmoothingFactor(value);
                  }
                };
                _el$24.style.setProperty("width", "100%");
                _el$24.style.setProperty("height", "20px");
                _el$24.style.setProperty("background", "rgba(255,255,255,0.1)");
                _el$24.style.setProperty("borderRadius", "10px");
                _el$24.style.setProperty("outline", "none");
                _el$24.style.setProperty("appearance", "none");
                _el$24.style.setProperty("WebkitAppearance", "none");
                createRenderEffect(() => {
                  var _a;
                  return _el$24.value = ((_a = state.smoothingFactorValue) == null ? void 0 : _a.call(state)) || 0.8;
                });
                return _el$21;
              }
            }), (() => {
              var _el$25 = _tmpl$5$2(), _el$26 = _el$25.firstChild, _el$27 = _el$26.firstChild, _el$29 = _el$27.nextSibling;
              _el$29.nextSibling;
              var _el$30 = _el$26.nextSibling;
              insert(_el$26, () => Math.round(state.autoDeselectThreshold() * 100), _el$29);
              _el$30.$$input = (e) => {
                var _a;
                const value = parseFloat(e.target.value);
                state.setAutoDeselectThreshold(value);
                if ((_a = state.components().overlayManager) == null ? void 0 : _a.setAutoDeselectThreshold) {
                  state.components().overlayManager.setAutoDeselectThreshold(value);
                }
              };
              _el$30.style.setProperty("width", "100%");
              _el$30.style.setProperty("height", "20px");
              _el$30.style.setProperty("background", "rgba(255,255,255,0.1)");
              _el$30.style.setProperty("borderRadius", "10px");
              _el$30.style.setProperty("outline", "none");
              _el$30.style.setProperty("appearance", "none");
              _el$30.style.setProperty("WebkitAppearance", "none");
              createRenderEffect(() => _el$30.value = state.autoDeselectThreshold());
              return _el$25;
            })(), (() => {
              var _el$31 = _tmpl$6$2(), _el$32 = _el$31.firstChild, _el$33 = _el$32.firstChild, _el$35 = _el$33.nextSibling;
              _el$35.nextSibling;
              var _el$36 = _el$32.nextSibling;
              insert(_el$32, () => Math.round(state.panDeselectThreshold() * 100), _el$35);
              _el$36.$$input = (e) => {
                var _a;
                const value = parseFloat(e.target.value);
                state.setPanDeselectThreshold(value);
                if ((_a = state.components().overlayManager) == null ? void 0 : _a.state) {
                  state.components().overlayManager.state.panThreshold = value;
                  console.log(`Set pan threshold to ${value}`);
                }
              };
              _el$36.style.setProperty("width", "100%");
              _el$36.style.setProperty("height", "20px");
              _el$36.style.setProperty("background", "rgba(255,255,255,0.1)");
              _el$36.style.setProperty("borderRadius", "10px");
              _el$36.style.setProperty("outline", "none");
              _el$36.style.setProperty("appearance", "none");
              _el$36.style.setProperty("WebkitAppearance", "none");
              createRenderEffect(() => _el$36.value = state.panDeselectThreshold());
              return _el$31;
            })()];
          }
        }), null);
        createRenderEffect((_p$) => {
          var _v$ = `${state.panelPosition().x}px`, _v$2 = `${state.panelPosition().y}px`, _v$3 = state.isDragging() ? "grabbing" : "default", _v$4 = isMobile() ? "80vh" : "none", _v$5 = isMobile() ? "0.2" : "0.1";
          _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$0.style.setProperty("left", _v$) : _el$0.style.removeProperty("left"));
          _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$0.style.setProperty("top", _v$2) : _el$0.style.removeProperty("top"));
          _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$0.style.setProperty("cursor", _v$3) : _el$0.style.removeProperty("cursor"));
          _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$0.style.setProperty("maxHeight", _v$4) : _el$0.style.removeProperty("maxHeight"));
          _v$5 !== _p$.i && setAttribute(_el$16, "min", _p$.i = _v$5);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0,
          i: void 0
        });
        createRenderEffect(() => _el$16.value = state.circleMultiplierValue());
        return _el$0;
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return state.showExpandButton();
      },
      get children() {
        var _el$37 = _tmpl$8$2();
        _el$37.$$click = () => {
          var _a;
          return (_a = animations()) == null ? void 0 : _a.expandToFullView();
        };
        createRenderEffect(() => className(_el$37, `expand-button glass-button ${state.expandButtonFading() ? "fade-out" : ""}`));
        return _el$37;
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return memo(() => !!(state.viewerReady() && !isIPhone()))() && fullscreenManager.isSupported();
      },
      get children() {
        var _el$38 = _tmpl$9$2(), _el$39 = _el$38.firstChild;
        _el$39.$$click = handleFullscreenClick;
        insert(_el$39, (() => {
          var _c$ = memo(() => !!state.isFullscreen());
          return () => _c$() ? (
            // Exit fullscreen icon
            _tmpl$1$1()
          ) : (
            // Enter fullscreen icon
            _tmpl$10$1()
          );
        })());
        createRenderEffect(() => setAttribute(_el$39, "aria-label", state.isFullscreen() ? "Exit fullscreen" : "Enter fullscreen"));
        return _el$38;
      }
    }), null);
    return _el$;
  })();
}
delegateEvents(["mousedown", "touchstart", "click", "input"]);
const getDefaultsFromPostinstall = () => void 0;
var define_process_env_default = {};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
};
const byteArrayToString = function(bytes) {
  const out = [];
  let pos = 0, c = 0;
  while (pos < bytes.length) {
    const c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      const c4 = bytes[pos++];
      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
      out[c++] = String.fromCharCode(55296 + (u >> 10));
      out[c++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join("");
};
const base64 = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    const output = [];
    for (let i = 0; i < input.length; i += 3) {
      const byte1 = input[i];
      const haveByte2 = i + 1 < input.length;
      const byte2 = haveByte2 ? input[i + 1] : 0;
      const haveByte3 = i + 2 < input.length;
      const byte3 = haveByte3 ? input[i + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(input, webSafe) {
    this.init_();
    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    const output = [];
    for (let i = 0; i < input.length; ) {
      const byte1 = charToByteMap[input.charAt(i++)];
      const haveByte2 = i < input.length;
      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;
      const haveByte3 = i < input.length;
      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      const haveByte4 = i < input.length;
      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw new DecodeBase64StringError();
      }
      const outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          const outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (let i = 0; i < this.ENCODED_VALS.length; i++) {
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
        this.charToByteMap_[this.byteToCharMap_[i]] = i;
        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
        if (i >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
        }
      }
    }
  }
};
class DecodeBase64StringError extends Error {
  constructor() {
    super(...arguments);
    this.name = "DecodeBase64StringError";
  }
}
const base64Encode = function(str) {
  const utf8Bytes = stringToByteArray$1(str);
  return base64.encodeByteArray(utf8Bytes, true);
};
const base64urlEncodeWithoutPadding = function(str) {
  return base64Encode(str).replace(/\./g, "");
};
const base64Decode = function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
const getDefaultsFromEnvVariable = () => {
  if (typeof process === "undefined" || typeof define_process_env_default === "undefined") {
    return;
  }
  const defaultsJsonString = define_process_env_default.__FIREBASE_DEFAULTS__;
  if (defaultsJsonString) {
    return JSON.parse(defaultsJsonString);
  }
};
const getDefaultsFromCookie = () => {
  if (typeof document === "undefined") {
    return;
  }
  let match;
  try {
    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch (e) {
    return;
  }
  const decoded = match && base64Decode(match[1]);
  return decoded && JSON.parse(decoded);
};
const getDefaults = () => {
  try {
    return getDefaultsFromPostinstall() || getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
  } catch (e) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
    return;
  }
};
const getDefaultEmulatorHost = (productName) => {
  var _a, _b;
  return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];
};
const getDefaultEmulatorHostnameAndPort = (productName) => {
  const host = getDefaultEmulatorHost(productName);
  if (!host) {
    return void 0;
  }
  const separatorIndex = host.lastIndexOf(":");
  if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
    throw new Error(`Invalid host ${host} with no separate hostname and port!`);
  }
  const port = parseInt(host.substring(separatorIndex + 1), 10);
  if (host[0] === "[") {
    return [host.substring(1, separatorIndex - 1), port];
  } else {
    return [host.substring(0, separatorIndex), port];
  }
};
const getDefaultAppConfig = () => {
  var _a;
  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
  constructor() {
    this.reject = () => {
    };
    this.resolve = () => {
    };
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  /**
   * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(callback) {
    return (error, value) => {
      if (error) {
        this.reject(error);
      } else {
        this.resolve(value);
      }
      if (typeof callback === "function") {
        this.promise.catch(() => {
        });
        if (callback.length === 1) {
          callback(error);
        } else {
          callback(error, value);
        }
      }
    };
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isCloudWorkstation(url) {
  try {
    const host = url.startsWith("http://") || url.startsWith("https://") ? new URL(url).hostname : url;
    return host.endsWith(".cloudworkstations.dev");
  } catch (_a) {
    return false;
  }
}
async function pingServer(endpoint) {
  const result = await fetch(endpoint, {
    credentials: "include"
  });
  return result.ok;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createMockUserToken(token, projectId) {
  if (token.uid) {
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  }
  const header = {
    alg: "none",
    type: "JWT"
  };
  const project = projectId || "demo-project";
  const iat = token.iat || 0;
  const sub = token.sub || token.user_id;
  if (!sub) {
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  }
  const payload = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${project}`,
    aud: project,
    iat,
    exp: iat + 3600,
    auth_time: iat,
    sub,
    user_id: sub,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, token);
  const signature = "";
  return [
    base64urlEncodeWithoutPadding(JSON.stringify(header)),
    base64urlEncodeWithoutPadding(JSON.stringify(payload)),
    signature
  ].join(".");
}
const emulatorStatus = {};
function getEmulatorSummary() {
  const summary = {
    prod: [],
    emulator: []
  };
  for (const key of Object.keys(emulatorStatus)) {
    if (emulatorStatus[key]) {
      summary.emulator.push(key);
    } else {
      summary.prod.push(key);
    }
  }
  return summary;
}
function getOrCreateEl(id) {
  let parentDiv = document.getElementById(id);
  let created = false;
  if (!parentDiv) {
    parentDiv = document.createElement("div");
    parentDiv.setAttribute("id", id);
    created = true;
  }
  return { created, element: parentDiv };
}
let previouslyDismissed = false;
function updateEmulatorBanner(name2, isRunningEmulator) {
  if (typeof window === "undefined" || typeof document === "undefined" || !isCloudWorkstation(window.location.host) || emulatorStatus[name2] === isRunningEmulator || emulatorStatus[name2] || // If already set to use emulator, can't go back to prod.
  previouslyDismissed) {
    return;
  }
  emulatorStatus[name2] = isRunningEmulator;
  function prefixedId(id) {
    return `__firebase__banner__${id}`;
  }
  const bannerId = "__firebase__banner";
  const summary = getEmulatorSummary();
  const showError = summary.prod.length > 0;
  function tearDown() {
    const element = document.getElementById(bannerId);
    if (element) {
      element.remove();
    }
  }
  function setupBannerStyles(bannerEl) {
    bannerEl.style.display = "flex";
    bannerEl.style.background = "#7faaf0";
    bannerEl.style.position = "fixed";
    bannerEl.style.bottom = "5px";
    bannerEl.style.left = "5px";
    bannerEl.style.padding = ".5em";
    bannerEl.style.borderRadius = "5px";
    bannerEl.style.alignItems = "center";
  }
  function setupIconStyles(prependIcon, iconId) {
    prependIcon.setAttribute("width", "24");
    prependIcon.setAttribute("id", iconId);
    prependIcon.setAttribute("height", "24");
    prependIcon.setAttribute("viewBox", "0 0 24 24");
    prependIcon.setAttribute("fill", "none");
    prependIcon.style.marginLeft = "-6px";
  }
  function setupCloseBtn() {
    const closeBtn = document.createElement("span");
    closeBtn.style.cursor = "pointer";
    closeBtn.style.marginLeft = "16px";
    closeBtn.style.fontSize = "24px";
    closeBtn.innerHTML = " &times;";
    closeBtn.onclick = () => {
      previouslyDismissed = true;
      tearDown();
    };
    return closeBtn;
  }
  function setupLinkStyles(learnMoreLink, learnMoreId) {
    learnMoreLink.setAttribute("id", learnMoreId);
    learnMoreLink.innerText = "Learn more";
    learnMoreLink.href = "https://firebase.google.com/docs/studio/preview-apps#preview-backend";
    learnMoreLink.setAttribute("target", "__blank");
    learnMoreLink.style.paddingLeft = "5px";
    learnMoreLink.style.textDecoration = "underline";
  }
  function setupDom() {
    const banner = getOrCreateEl(bannerId);
    const firebaseTextId = prefixedId("text");
    const firebaseText = document.getElementById(firebaseTextId) || document.createElement("span");
    const learnMoreId = prefixedId("learnmore");
    const learnMoreLink = document.getElementById(learnMoreId) || document.createElement("a");
    const prependIconId = prefixedId("preprendIcon");
    const prependIcon = document.getElementById(prependIconId) || document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (banner.created) {
      const bannerEl = banner.element;
      setupBannerStyles(bannerEl);
      setupLinkStyles(learnMoreLink, learnMoreId);
      const closeBtn = setupCloseBtn();
      setupIconStyles(prependIcon, prependIconId);
      bannerEl.append(prependIcon, firebaseText, learnMoreLink, closeBtn);
      document.body.appendChild(bannerEl);
    }
    if (showError) {
      firebaseText.innerText = `Preview backend disconnected.`;
      prependIcon.innerHTML = `<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`;
    } else {
      prependIcon.innerHTML = `<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`;
      firebaseText.innerText = "Preview backend running in this workspace.";
    }
    firebaseText.setAttribute("id", firebaseTextId);
  }
  if (document.readyState === "loading") {
    window.addEventListener("DOMContentLoaded", setupDom);
  } else {
    setupDom();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
function isNode() {
  var _a;
  const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;
  if (forceEnvironment === "node") {
    return true;
  } else if (forceEnvironment === "browser") {
    return false;
  }
  try {
    return Object.prototype.toString.call(global.process) === "[object process]";
  } catch (e) {
    return false;
  }
}
function isSafari() {
  return !isNode() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
}
function isIndexedDBAvailable() {
  try {
    return typeof indexedDB === "object";
  } catch (e) {
    return false;
  }
}
function validateIndexedDBOpenable() {
  return new Promise((resolve, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a;
        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || "");
      };
    } catch (error) {
      reject(error);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_NAME = "FirebaseError";
class FirebaseError extends Error {
  constructor(code, message, customData) {
    super(message);
    this.code = code;
    this.customData = customData;
    this.name = ERROR_NAME;
    Object.setPrototypeOf(this, FirebaseError.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
  }
}
class ErrorFactory {
  constructor(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  create(code, ...data) {
    const customData = data[0] || {};
    const fullCode = `${this.service}/${code}`;
    const template2 = this.errors[code];
    const message = template2 ? replaceTemplate(template2, customData) : "Error";
    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
    const error = new FirebaseError(fullCode, fullMessage, customData);
    return error;
  }
}
function replaceTemplate(template2, data) {
  return template2.replace(PATTERN, (_, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
}
const PATTERN = /\{\$([^}]+)}/g;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  for (const k2 of aKeys) {
    if (!bKeys.includes(k2)) {
      return false;
    }
    const aProp = a[k2];
    const bProp = b[k2];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k2 of bKeys) {
    if (!aKeys.includes(k2)) {
      return false;
    }
  }
  return true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
class Component {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(name2, instanceFactory, type) {
    this.name = name2;
    this.instanceFactory = instanceFactory;
    this.type = type;
    this.multipleInstances = false;
    this.serviceProps = {};
    this.instantiationMode = "LAZY";
    this.onInstanceCreated = null;
  }
  setInstantiationMode(mode) {
    this.instantiationMode = mode;
    return this;
  }
  setMultipleInstances(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  }
  setServiceProps(props) {
    this.serviceProps = props;
    return this;
  }
  setInstanceCreatedCallback(callback) {
    this.onInstanceCreated = callback;
    return this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Provider {
  constructor(name2, container) {
    this.name = name2;
    this.container = container;
    this.component = null;
    this.instances = /* @__PURE__ */ new Map();
    this.instancesDeferred = /* @__PURE__ */ new Map();
    this.instancesOptions = /* @__PURE__ */ new Map();
    this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide multiple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(identifier) {
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      const deferred = new Deferred();
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e) {
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  }
  getImmediate(options) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e) {
        if (optional) {
          return null;
        } else {
          throw e;
        }
      }
    } else {
      if (optional) {
        return null;
      } else {
        throw Error(`Service ${this.name} is not available`);
      }
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(component) {
    if (component.name !== this.name) {
      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
    }
    if (this.component) {
      throw Error(`Component for ${this.name} has already been provided`);
    }
    this.component = component;
    if (!this.shouldAutoInitialize()) {
      return;
    }
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
      } catch (e) {
      }
    }
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      try {
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
        instanceDeferred.resolve(instance);
      } catch (e) {
      }
    }
  }
  clearInstance(identifier = DEFAULT_ENTRY_NAME$1) {
    this.instancesDeferred.delete(identifier);
    this.instancesOptions.delete(identifier);
    this.instances.delete(identifier);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const services = Array.from(this.instances.values());
    await Promise.all([
      ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
      ...services.filter((service) => "_delete" in service).map((service) => service._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(identifier = DEFAULT_ENTRY_NAME$1) {
    return this.instances.has(identifier);
  }
  getOptions(identifier = DEFAULT_ENTRY_NAME$1) {
    return this.instancesOptions.get(identifier) || {};
  }
  initialize(opts = {}) {
    const { options = {} } = opts;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
    }
    if (!this.isComponentSet()) {
      throw Error(`Component ${this.name} has not been registered yet`);
    }
    const instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options
    });
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (normalizedIdentifier === normalizedDeferredIdentifier) {
        instanceDeferred.resolve(instance);
      }
    }
    return instance;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(callback, identifier) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set();
    existingCallbacks.add(callback);
    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
    const existingInstance = this.instances.get(normalizedIdentifier);
    if (existingInstance) {
      callback(existingInstance, normalizedIdentifier);
    }
    return () => {
      existingCallbacks.delete(callback);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(instance, identifier) {
    const callbacks = this.onInitCallbacks.get(identifier);
    if (!callbacks) {
      return;
    }
    for (const callback of callbacks) {
      try {
        callback(instance, identifier);
      } catch (_a) {
      }
    }
  }
  getOrInitializeService({ instanceIdentifier, options = {} }) {
    let instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options
      });
      this.instances.set(instanceIdentifier, instance);
      this.instancesOptions.set(instanceIdentifier, options);
      this.invokeOnInitCallbacks(instance, instanceIdentifier);
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_a) {
        }
      }
    }
    return instance || null;
  }
  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME$1) {
    if (this.component) {
      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
    } else {
      return identifier;
    }
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME$1 ? void 0 : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ComponentContainer {
  constructor(name2) {
    this.name = name2;
    this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
    }
    provider.setComponent(component);
  }
  addOrOverwriteComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(name2) {
    if (this.providers.has(name2)) {
      return this.providers.get(name2);
    }
    const provider = new Provider(name2, this);
    this.providers.set(name2, provider);
    return provider;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
  "debug": LogLevel.DEBUG,
  "verbose": LogLevel.VERBOSE,
  "info": LogLevel.INFO,
  "warn": LogLevel.WARN,
  "error": LogLevel.ERROR,
  "silent": LogLevel.SILENT
};
const defaultLogLevel = LogLevel.INFO;
const ConsoleMethod = {
  [LogLevel.DEBUG]: "log",
  [LogLevel.VERBOSE]: "log",
  [LogLevel.INFO]: "info",
  [LogLevel.WARN]: "warn",
  [LogLevel.ERROR]: "error"
};
const defaultLogHandler = (instance, logType, ...args) => {
  if (logType < instance.logLevel) {
    return;
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const method = ConsoleMethod[logType];
  if (method) {
    console[method](`[${now}]  ${instance.name}:`, ...args);
  } else {
    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
  }
};
class Logger2 {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(name2) {
    this.name = name2;
    this._logLevel = defaultLogLevel;
    this._logHandler = defaultLogHandler;
    this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(val) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(val) {
    this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(val) {
    if (typeof val !== "function") {
      throw new TypeError("Value assigned to `logHandler` must be a function");
    }
    this._logHandler = val;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(val) {
    this._userLogHandler = val;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
    this._logHandler(this, LogLevel.DEBUG, ...args);
  }
  log(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
    this._logHandler(this, LogLevel.VERBOSE, ...args);
  }
  info(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
    this._logHandler(this, LogLevel.INFO, ...args);
  }
  warn(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
    this._logHandler(this, LogLevel.WARN, ...args);
  }
  error(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
    this._logHandler(this, LogLevel.ERROR, ...args);
  }
}
const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db2) => {
    if (terminated)
      db2.addEventListener("close", () => terminated());
    if (blocking) {
      db2.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
  constructor(container) {
    this.container = container;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    return providers.map((provider) => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter((logString) => logString).join(" ");
  }
}
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
const name$q = "@firebase/app";
const version$1 = "0.13.2";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger2("@firebase/app");
const name$p = "@firebase/app-compat";
const name$o = "@firebase/analytics-compat";
const name$n = "@firebase/analytics";
const name$m = "@firebase/app-check-compat";
const name$l = "@firebase/app-check";
const name$k = "@firebase/auth";
const name$j = "@firebase/auth-compat";
const name$i = "@firebase/database";
const name$h = "@firebase/data-connect";
const name$g = "@firebase/database-compat";
const name$f = "@firebase/functions";
const name$e = "@firebase/functions-compat";
const name$d = "@firebase/installations";
const name$c = "@firebase/installations-compat";
const name$b = "@firebase/messaging";
const name$a = "@firebase/messaging-compat";
const name$9 = "@firebase/performance";
const name$8 = "@firebase/performance-compat";
const name$7 = "@firebase/remote-config";
const name$6 = "@firebase/remote-config-compat";
const name$5 = "@firebase/storage";
const name$4 = "@firebase/storage-compat";
const name$3 = "@firebase/firestore";
const name$2 = "@firebase/ai";
const name$1 = "@firebase/firestore-compat";
const name$r = "firebase";
const version$2 = "11.10.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = "[DEFAULT]";
const PLATFORM_LOG_STRING = {
  [name$q]: "fire-core",
  [name$p]: "fire-core-compat",
  [name$n]: "fire-analytics",
  [name$o]: "fire-analytics-compat",
  [name$l]: "fire-app-check",
  [name$m]: "fire-app-check-compat",
  [name$k]: "fire-auth",
  [name$j]: "fire-auth-compat",
  [name$i]: "fire-rtdb",
  [name$h]: "fire-data-connect",
  [name$g]: "fire-rtdb-compat",
  [name$f]: "fire-fn",
  [name$e]: "fire-fn-compat",
  [name$d]: "fire-iid",
  [name$c]: "fire-iid-compat",
  [name$b]: "fire-fcm",
  [name$a]: "fire-fcm-compat",
  [name$9]: "fire-perf",
  [name$8]: "fire-perf-compat",
  [name$7]: "fire-rc",
  [name$6]: "fire-rc-compat",
  [name$5]: "fire-gcs",
  [name$4]: "fire-gcs-compat",
  [name$3]: "fire-fst",
  [name$1]: "fire-fst-compat",
  [name$2]: "fire-vertex",
  "fire-js": "fire-js",
  // Platform identifier for JS SDK.
  [name$r]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _apps = /* @__PURE__ */ new Map();
const _serverApps = /* @__PURE__ */ new Map();
const _components = /* @__PURE__ */ new Map();
function _addComponent(app2, component) {
  try {
    app2.container.addComponent(component);
  } catch (e) {
    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app2.name}`, e);
  }
}
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app2 of _apps.values()) {
    _addComponent(app2, component);
  }
  for (const serverApp of _serverApps.values()) {
    _addComponent(serverApp, component);
  }
  return true;
}
function _getProvider(app2, name2) {
  const heartbeatController = app2.container.getProvider("heartbeat").getImmediate({ optional: true });
  if (heartbeatController) {
    void heartbeatController.triggerHeartbeat();
  }
  return app2.container.getProvider(name2);
}
function _isFirebaseServerApp(obj) {
  if (obj === null || obj === void 0) {
    return false;
  }
  return obj.settings !== void 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
  [
    "no-app"
    /* AppError.NO_APP */
  ]: "No Firebase App '{$appName}' has been created - call initializeApp() first",
  [
    "bad-app-name"
    /* AppError.BAD_APP_NAME */
  ]: "Illegal App name: '{$appName}'",
  [
    "duplicate-app"
    /* AppError.DUPLICATE_APP */
  ]: "Firebase App named '{$appName}' already exists with different options or config",
  [
    "app-deleted"
    /* AppError.APP_DELETED */
  ]: "Firebase App named '{$appName}' already deleted",
  [
    "server-app-deleted"
    /* AppError.SERVER_APP_DELETED */
  ]: "Firebase Server App has been deleted",
  [
    "no-options"
    /* AppError.NO_OPTIONS */
  ]: "Need to provide options, when not being deployed to hosting via source.",
  [
    "invalid-app-argument"
    /* AppError.INVALID_APP_ARGUMENT */
  ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  [
    "invalid-log-argument"
    /* AppError.INVALID_LOG_ARGUMENT */
  ]: "First argument to `onLog` must be null or a function.",
  [
    "idb-open"
    /* AppError.IDB_OPEN */
  ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-get"
    /* AppError.IDB_GET */
  ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-set"
    /* AppError.IDB_WRITE */
  ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-delete"
    /* AppError.IDB_DELETE */
  ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "finalization-registry-not-supported"
    /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */
  ]: "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  [
    "invalid-server-app-environment"
    /* AppError.INVALID_SERVER_APP_ENVIRONMENT */
  ]: "FirebaseServerApp is not for use in browser environments."
};
const ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
  constructor(options, config, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options);
    this._config = Object.assign({}, config);
    this._name = config.name;
    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new Component(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get config() {
    this.checkDestroyed();
    return this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY.create("app-deleted", { appName: this._name });
    }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SDK_VERSION = version$2;
function initializeApp(_options, rawConfig = {}) {
  let options = _options;
  if (typeof rawConfig !== "object") {
    const name3 = rawConfig;
    rawConfig = { name: name3 };
  }
  const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: true }, rawConfig);
  const name2 = config.name;
  if (typeof name2 !== "string" || !name2) {
    throw ERROR_FACTORY.create("bad-app-name", {
      appName: String(name2)
    });
  }
  options || (options = getDefaultAppConfig());
  if (!options) {
    throw ERROR_FACTORY.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  }
  const existingApp = _apps.get(name2);
  if (existingApp) {
    if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY.create("duplicate-app", { appName: name2 });
    }
  }
  const container = new ComponentContainer(name2);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl(options, config, container);
  _apps.set(name2, newApp);
  return newApp;
}
function getApp(name2 = DEFAULT_ENTRY_NAME) {
  const app2 = _apps.get(name2);
  if (!app2 && name2 === DEFAULT_ENTRY_NAME && getDefaultAppConfig()) {
    return initializeApp();
  }
  if (!app2) {
    throw ERROR_FACTORY.create("no-app", { appName: name2 });
  }
  return app2;
}
function registerVersion(libraryKeyOrName, version2, variant) {
  var _a;
  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version2.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version2}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version2}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(
    `${library}-version`,
    () => ({ library, version: version2 }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = "firebase-heartbeat-database";
const DB_VERSION = 1;
const STORE_NAME = "firebase-heartbeat-store";
let dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade: (db2, oldVersion) => {
        switch (oldVersion) {
          case 0:
            try {
              db2.createObjectStore(STORE_NAME);
            } catch (e) {
              console.warn(e);
            }
        }
      }
    }).catch((e) => {
      throw ERROR_FACTORY.create("idb-open", {
        originalErrorMessage: e.message
      });
    });
  }
  return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app2) {
  try {
    const db2 = await getDbPromise();
    const tx = db2.transaction(STORE_NAME);
    const result = await tx.objectStore(STORE_NAME).get(computeKey(app2));
    await tx.done;
    return result;
  } catch (e) {
    if (e instanceof FirebaseError) {
      logger.warn(e.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-get", {
        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
async function writeHeartbeatsToIndexedDB(app2, heartbeatObject) {
  try {
    const db2 = await getDbPromise();
    const tx = db2.transaction(STORE_NAME, "readwrite");
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app2));
    await tx.done;
  } catch (e) {
    if (e instanceof FirebaseError) {
      logger.warn(e.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-set", {
        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
function computeKey(app2) {
  return `${app2.name}!${app2.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
const MAX_NUM_STORED_HEARTBEATS = 30;
class HeartbeatServiceImpl {
  constructor(container) {
    this.container = container;
    this._heartbeatsCache = null;
    const app2 = this.container.getProvider("app").getImmediate();
    this._storage = new HeartbeatStorageImpl(app2);
    this._heartbeatsCachePromise = this._storage.read().then((result) => {
      this._heartbeatsCache = result;
      return result;
    });
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var _a, _b;
    try {
      const platformLogger = this.container.getProvider("platform-logger").getImmediate();
      const agent = platformLogger.getPlatformInfoString();
      const date = getUTCDateString();
      if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {
        this._heartbeatsCache = await this._heartbeatsCachePromise;
        if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {
          return;
        }
      }
      if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {
        return;
      } else {
        this._heartbeatsCache.heartbeats.push({ date, agent });
        if (this._heartbeatsCache.heartbeats.length > MAX_NUM_STORED_HEARTBEATS) {
          const earliestHeartbeatIdx = getEarliestHeartbeatIdx(this._heartbeatsCache.heartbeats);
          this._heartbeatsCache.heartbeats.splice(earliestHeartbeatIdx, 1);
        }
      }
      return this._storage.overwrite(this._heartbeatsCache);
    } catch (e) {
      logger.warn(e);
    }
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var _a;
    try {
      if (this._heartbeatsCache === null) {
        await this._heartbeatsCachePromise;
      }
      if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) {
        return "";
      }
      const date = getUTCDateString();
      const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
      const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
      this._heartbeatsCache.lastSentHeartbeatDate = date;
      if (unsentEntries.length > 0) {
        this._heartbeatsCache.heartbeats = unsentEntries;
        await this._storage.overwrite(this._heartbeatsCache);
      } else {
        this._heartbeatsCache.heartbeats = [];
        void this._storage.overwrite(this._heartbeatsCache);
      }
      return headerString;
    } catch (e) {
      logger.warn(e);
      return "";
    }
  }
}
function getUTCDateString() {
  const today = /* @__PURE__ */ new Date();
  return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  const heartbeatsToSend = [];
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    const heartbeatEntry = heartbeatsToSend.find((hb) => hb.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
}
class HeartbeatStorageImpl {
  constructor(app2) {
    this.app = app2;
    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    if (!isIndexedDBAvailable()) {
      return false;
    } else {
      return validateIndexedDBOpenable().then(() => true).catch(() => false);
    }
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return { heartbeats: [] };
    } else {
      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
      if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {
        return idbHeartbeatObject;
      } else {
        return { heartbeats: [] };
      }
    }
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: heartbeatsObject.heartbeats
      });
    }
  }
  // add heartbeats
  async add(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: [
          ...existingHeartbeatsObject.heartbeats,
          ...heartbeatsObject.heartbeats
        ]
      });
    }
  }
}
function countBytes(heartbeatsCache) {
  return base64urlEncodeWithoutPadding(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })
  ).length;
}
function getEarliestHeartbeatIdx(heartbeats) {
  if (heartbeats.length === 0) {
    return -1;
  }
  let earliestHeartbeatIdx = 0;
  let earliestHeartbeatDate = heartbeats[0].date;
  for (let i = 1; i < heartbeats.length; i++) {
    if (heartbeats[i].date < earliestHeartbeatDate) {
      earliestHeartbeatDate = heartbeats[i].date;
      earliestHeartbeatIdx = i;
    }
  }
  return earliestHeartbeatIdx;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
  _registerComponent(new Component(
    "platform-logger",
    (container) => new PlatformLoggerServiceImpl(container),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  _registerComponent(new Component(
    "heartbeat",
    (container) => new HeartbeatServiceImpl(container),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  registerVersion(name$q, version$1, variant);
  registerVersion(name$q, version$1, "esm2017");
  registerVersion("fire-js", "");
}
registerCoreComponents("");
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var Integer;
var Md5;
(function() {
  var h;
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  function k2(f, a) {
    function c() {
    }
    c.prototype = a.prototype;
    f.D = a.prototype;
    f.prototype = new c();
    f.prototype.constructor = f;
    f.C = function(d, e, g) {
      for (var b = Array(arguments.length - 2), r = 2; r < arguments.length; r++) b[r - 2] = arguments[r];
      return a.prototype[e].apply(d, b);
    };
  }
  function l() {
    this.blockSize = -1;
  }
  function m() {
    this.blockSize = -1;
    this.blockSize = 64;
    this.g = Array(4);
    this.B = Array(this.blockSize);
    this.o = this.h = 0;
    this.s();
  }
  k2(m, l);
  m.prototype.s = function() {
    this.g[0] = 1732584193;
    this.g[1] = 4023233417;
    this.g[2] = 2562383102;
    this.g[3] = 271733878;
    this.o = this.h = 0;
  };
  function n(f, a, c) {
    c || (c = 0);
    var d = Array(16);
    if ("string" === typeof a) for (var e = 0; 16 > e; ++e) d[e] = a.charCodeAt(c++) | a.charCodeAt(c++) << 8 | a.charCodeAt(c++) << 16 | a.charCodeAt(c++) << 24;
    else for (e = 0; 16 > e; ++e) d[e] = a[c++] | a[c++] << 8 | a[c++] << 16 | a[c++] << 24;
    a = f.g[0];
    c = f.g[1];
    e = f.g[2];
    var g = f.g[3];
    var b = a + (g ^ c & (e ^ g)) + d[0] + 3614090360 & 4294967295;
    a = c + (b << 7 & 4294967295 | b >>> 25);
    b = g + (e ^ a & (c ^ e)) + d[1] + 3905402710 & 4294967295;
    g = a + (b << 12 & 4294967295 | b >>> 20);
    b = e + (c ^ g & (a ^ c)) + d[2] + 606105819 & 4294967295;
    e = g + (b << 17 & 4294967295 | b >>> 15);
    b = c + (a ^ e & (g ^ a)) + d[3] + 3250441966 & 4294967295;
    c = e + (b << 22 & 4294967295 | b >>> 10);
    b = a + (g ^ c & (e ^ g)) + d[4] + 4118548399 & 4294967295;
    a = c + (b << 7 & 4294967295 | b >>> 25);
    b = g + (e ^ a & (c ^ e)) + d[5] + 1200080426 & 4294967295;
    g = a + (b << 12 & 4294967295 | b >>> 20);
    b = e + (c ^ g & (a ^ c)) + d[6] + 2821735955 & 4294967295;
    e = g + (b << 17 & 4294967295 | b >>> 15);
    b = c + (a ^ e & (g ^ a)) + d[7] + 4249261313 & 4294967295;
    c = e + (b << 22 & 4294967295 | b >>> 10);
    b = a + (g ^ c & (e ^ g)) + d[8] + 1770035416 & 4294967295;
    a = c + (b << 7 & 4294967295 | b >>> 25);
    b = g + (e ^ a & (c ^ e)) + d[9] + 2336552879 & 4294967295;
    g = a + (b << 12 & 4294967295 | b >>> 20);
    b = e + (c ^ g & (a ^ c)) + d[10] + 4294925233 & 4294967295;
    e = g + (b << 17 & 4294967295 | b >>> 15);
    b = c + (a ^ e & (g ^ a)) + d[11] + 2304563134 & 4294967295;
    c = e + (b << 22 & 4294967295 | b >>> 10);
    b = a + (g ^ c & (e ^ g)) + d[12] + 1804603682 & 4294967295;
    a = c + (b << 7 & 4294967295 | b >>> 25);
    b = g + (e ^ a & (c ^ e)) + d[13] + 4254626195 & 4294967295;
    g = a + (b << 12 & 4294967295 | b >>> 20);
    b = e + (c ^ g & (a ^ c)) + d[14] + 2792965006 & 4294967295;
    e = g + (b << 17 & 4294967295 | b >>> 15);
    b = c + (a ^ e & (g ^ a)) + d[15] + 1236535329 & 4294967295;
    c = e + (b << 22 & 4294967295 | b >>> 10);
    b = a + (e ^ g & (c ^ e)) + d[1] + 4129170786 & 4294967295;
    a = c + (b << 5 & 4294967295 | b >>> 27);
    b = g + (c ^ e & (a ^ c)) + d[6] + 3225465664 & 4294967295;
    g = a + (b << 9 & 4294967295 | b >>> 23);
    b = e + (a ^ c & (g ^ a)) + d[11] + 643717713 & 4294967295;
    e = g + (b << 14 & 4294967295 | b >>> 18);
    b = c + (g ^ a & (e ^ g)) + d[0] + 3921069994 & 4294967295;
    c = e + (b << 20 & 4294967295 | b >>> 12);
    b = a + (e ^ g & (c ^ e)) + d[5] + 3593408605 & 4294967295;
    a = c + (b << 5 & 4294967295 | b >>> 27);
    b = g + (c ^ e & (a ^ c)) + d[10] + 38016083 & 4294967295;
    g = a + (b << 9 & 4294967295 | b >>> 23);
    b = e + (a ^ c & (g ^ a)) + d[15] + 3634488961 & 4294967295;
    e = g + (b << 14 & 4294967295 | b >>> 18);
    b = c + (g ^ a & (e ^ g)) + d[4] + 3889429448 & 4294967295;
    c = e + (b << 20 & 4294967295 | b >>> 12);
    b = a + (e ^ g & (c ^ e)) + d[9] + 568446438 & 4294967295;
    a = c + (b << 5 & 4294967295 | b >>> 27);
    b = g + (c ^ e & (a ^ c)) + d[14] + 3275163606 & 4294967295;
    g = a + (b << 9 & 4294967295 | b >>> 23);
    b = e + (a ^ c & (g ^ a)) + d[3] + 4107603335 & 4294967295;
    e = g + (b << 14 & 4294967295 | b >>> 18);
    b = c + (g ^ a & (e ^ g)) + d[8] + 1163531501 & 4294967295;
    c = e + (b << 20 & 4294967295 | b >>> 12);
    b = a + (e ^ g & (c ^ e)) + d[13] + 2850285829 & 4294967295;
    a = c + (b << 5 & 4294967295 | b >>> 27);
    b = g + (c ^ e & (a ^ c)) + d[2] + 4243563512 & 4294967295;
    g = a + (b << 9 & 4294967295 | b >>> 23);
    b = e + (a ^ c & (g ^ a)) + d[7] + 1735328473 & 4294967295;
    e = g + (b << 14 & 4294967295 | b >>> 18);
    b = c + (g ^ a & (e ^ g)) + d[12] + 2368359562 & 4294967295;
    c = e + (b << 20 & 4294967295 | b >>> 12);
    b = a + (c ^ e ^ g) + d[5] + 4294588738 & 4294967295;
    a = c + (b << 4 & 4294967295 | b >>> 28);
    b = g + (a ^ c ^ e) + d[8] + 2272392833 & 4294967295;
    g = a + (b << 11 & 4294967295 | b >>> 21);
    b = e + (g ^ a ^ c) + d[11] + 1839030562 & 4294967295;
    e = g + (b << 16 & 4294967295 | b >>> 16);
    b = c + (e ^ g ^ a) + d[14] + 4259657740 & 4294967295;
    c = e + (b << 23 & 4294967295 | b >>> 9);
    b = a + (c ^ e ^ g) + d[1] + 2763975236 & 4294967295;
    a = c + (b << 4 & 4294967295 | b >>> 28);
    b = g + (a ^ c ^ e) + d[4] + 1272893353 & 4294967295;
    g = a + (b << 11 & 4294967295 | b >>> 21);
    b = e + (g ^ a ^ c) + d[7] + 4139469664 & 4294967295;
    e = g + (b << 16 & 4294967295 | b >>> 16);
    b = c + (e ^ g ^ a) + d[10] + 3200236656 & 4294967295;
    c = e + (b << 23 & 4294967295 | b >>> 9);
    b = a + (c ^ e ^ g) + d[13] + 681279174 & 4294967295;
    a = c + (b << 4 & 4294967295 | b >>> 28);
    b = g + (a ^ c ^ e) + d[0] + 3936430074 & 4294967295;
    g = a + (b << 11 & 4294967295 | b >>> 21);
    b = e + (g ^ a ^ c) + d[3] + 3572445317 & 4294967295;
    e = g + (b << 16 & 4294967295 | b >>> 16);
    b = c + (e ^ g ^ a) + d[6] + 76029189 & 4294967295;
    c = e + (b << 23 & 4294967295 | b >>> 9);
    b = a + (c ^ e ^ g) + d[9] + 3654602809 & 4294967295;
    a = c + (b << 4 & 4294967295 | b >>> 28);
    b = g + (a ^ c ^ e) + d[12] + 3873151461 & 4294967295;
    g = a + (b << 11 & 4294967295 | b >>> 21);
    b = e + (g ^ a ^ c) + d[15] + 530742520 & 4294967295;
    e = g + (b << 16 & 4294967295 | b >>> 16);
    b = c + (e ^ g ^ a) + d[2] + 3299628645 & 4294967295;
    c = e + (b << 23 & 4294967295 | b >>> 9);
    b = a + (e ^ (c | ~g)) + d[0] + 4096336452 & 4294967295;
    a = c + (b << 6 & 4294967295 | b >>> 26);
    b = g + (c ^ (a | ~e)) + d[7] + 1126891415 & 4294967295;
    g = a + (b << 10 & 4294967295 | b >>> 22);
    b = e + (a ^ (g | ~c)) + d[14] + 2878612391 & 4294967295;
    e = g + (b << 15 & 4294967295 | b >>> 17);
    b = c + (g ^ (e | ~a)) + d[5] + 4237533241 & 4294967295;
    c = e + (b << 21 & 4294967295 | b >>> 11);
    b = a + (e ^ (c | ~g)) + d[12] + 1700485571 & 4294967295;
    a = c + (b << 6 & 4294967295 | b >>> 26);
    b = g + (c ^ (a | ~e)) + d[3] + 2399980690 & 4294967295;
    g = a + (b << 10 & 4294967295 | b >>> 22);
    b = e + (a ^ (g | ~c)) + d[10] + 4293915773 & 4294967295;
    e = g + (b << 15 & 4294967295 | b >>> 17);
    b = c + (g ^ (e | ~a)) + d[1] + 2240044497 & 4294967295;
    c = e + (b << 21 & 4294967295 | b >>> 11);
    b = a + (e ^ (c | ~g)) + d[8] + 1873313359 & 4294967295;
    a = c + (b << 6 & 4294967295 | b >>> 26);
    b = g + (c ^ (a | ~e)) + d[15] + 4264355552 & 4294967295;
    g = a + (b << 10 & 4294967295 | b >>> 22);
    b = e + (a ^ (g | ~c)) + d[6] + 2734768916 & 4294967295;
    e = g + (b << 15 & 4294967295 | b >>> 17);
    b = c + (g ^ (e | ~a)) + d[13] + 1309151649 & 4294967295;
    c = e + (b << 21 & 4294967295 | b >>> 11);
    b = a + (e ^ (c | ~g)) + d[4] + 4149444226 & 4294967295;
    a = c + (b << 6 & 4294967295 | b >>> 26);
    b = g + (c ^ (a | ~e)) + d[11] + 3174756917 & 4294967295;
    g = a + (b << 10 & 4294967295 | b >>> 22);
    b = e + (a ^ (g | ~c)) + d[2] + 718787259 & 4294967295;
    e = g + (b << 15 & 4294967295 | b >>> 17);
    b = c + (g ^ (e | ~a)) + d[9] + 3951481745 & 4294967295;
    f.g[0] = f.g[0] + a & 4294967295;
    f.g[1] = f.g[1] + (e + (b << 21 & 4294967295 | b >>> 11)) & 4294967295;
    f.g[2] = f.g[2] + e & 4294967295;
    f.g[3] = f.g[3] + g & 4294967295;
  }
  m.prototype.u = function(f, a) {
    void 0 === a && (a = f.length);
    for (var c = a - this.blockSize, d = this.B, e = this.h, g = 0; g < a; ) {
      if (0 == e) for (; g <= c; ) n(this, f, g), g += this.blockSize;
      if ("string" === typeof f) for (; g < a; ) {
        if (d[e++] = f.charCodeAt(g++), e == this.blockSize) {
          n(this, d);
          e = 0;
          break;
        }
      }
      else for (; g < a; ) if (d[e++] = f[g++], e == this.blockSize) {
        n(this, d);
        e = 0;
        break;
      }
    }
    this.h = e;
    this.o += a;
  };
  m.prototype.v = function() {
    var f = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
    f[0] = 128;
    for (var a = 1; a < f.length - 8; ++a) f[a] = 0;
    var c = 8 * this.o;
    for (a = f.length - 8; a < f.length; ++a) f[a] = c & 255, c /= 256;
    this.u(f);
    f = Array(16);
    for (a = c = 0; 4 > a; ++a) for (var d = 0; 32 > d; d += 8) f[c++] = this.g[a] >>> d & 255;
    return f;
  };
  function p(f, a) {
    var c = q2;
    return Object.prototype.hasOwnProperty.call(c, f) ? c[f] : c[f] = a(f);
  }
  function t(f, a) {
    this.h = a;
    for (var c = [], d = true, e = f.length - 1; 0 <= e; e--) {
      var g = f[e] | 0;
      d && g == a || (c[e] = g, d = false);
    }
    this.g = c;
  }
  var q2 = {};
  function u(f) {
    return -128 <= f && 128 > f ? p(f, function(a) {
      return new t([a | 0], 0 > a ? -1 : 0);
    }) : new t([f | 0], 0 > f ? -1 : 0);
  }
  function v(f) {
    if (isNaN(f) || !isFinite(f)) return w;
    if (0 > f) return x2(v(-f));
    for (var a = [], c = 1, d = 0; f >= c; d++) a[d] = f / c | 0, c *= 4294967296;
    return new t(a, 0);
  }
  function y(f, a) {
    if (0 == f.length) throw Error("number format error: empty string");
    a = a || 10;
    if (2 > a || 36 < a) throw Error("radix out of range: " + a);
    if ("-" == f.charAt(0)) return x2(y(f.substring(1), a));
    if (0 <= f.indexOf("-")) throw Error('number format error: interior "-" character');
    for (var c = v(Math.pow(a, 8)), d = w, e = 0; e < f.length; e += 8) {
      var g = Math.min(8, f.length - e), b = parseInt(f.substring(e, e + g), a);
      8 > g ? (g = v(Math.pow(a, g)), d = d.j(g).add(v(b))) : (d = d.j(c), d = d.add(v(b)));
    }
    return d;
  }
  var w = u(0), z2 = u(1), A = u(16777216);
  h = t.prototype;
  h.m = function() {
    if (B2(this)) return -x2(this).m();
    for (var f = 0, a = 1, c = 0; c < this.g.length; c++) {
      var d = this.i(c);
      f += (0 <= d ? d : 4294967296 + d) * a;
      a *= 4294967296;
    }
    return f;
  };
  h.toString = function(f) {
    f = f || 10;
    if (2 > f || 36 < f) throw Error("radix out of range: " + f);
    if (C(this)) return "0";
    if (B2(this)) return "-" + x2(this).toString(f);
    for (var a = v(Math.pow(f, 6)), c = this, d = ""; ; ) {
      var e = D(c, a).g;
      c = F2(c, e.j(a));
      var g = ((0 < c.g.length ? c.g[0] : c.h) >>> 0).toString(f);
      c = e;
      if (C(c)) return g + d;
      for (; 6 > g.length; ) g = "0" + g;
      d = g + d;
    }
  };
  h.i = function(f) {
    return 0 > f ? 0 : f < this.g.length ? this.g[f] : this.h;
  };
  function C(f) {
    if (0 != f.h) return false;
    for (var a = 0; a < f.g.length; a++) if (0 != f.g[a]) return false;
    return true;
  }
  function B2(f) {
    return -1 == f.h;
  }
  h.l = function(f) {
    f = F2(this, f);
    return B2(f) ? -1 : C(f) ? 0 : 1;
  };
  function x2(f) {
    for (var a = f.g.length, c = [], d = 0; d < a; d++) c[d] = ~f.g[d];
    return new t(c, ~f.h).add(z2);
  }
  h.abs = function() {
    return B2(this) ? x2(this) : this;
  };
  h.add = function(f) {
    for (var a = Math.max(this.g.length, f.g.length), c = [], d = 0, e = 0; e <= a; e++) {
      var g = d + (this.i(e) & 65535) + (f.i(e) & 65535), b = (g >>> 16) + (this.i(e) >>> 16) + (f.i(e) >>> 16);
      d = b >>> 16;
      g &= 65535;
      b &= 65535;
      c[e] = b << 16 | g;
    }
    return new t(c, c[c.length - 1] & -2147483648 ? -1 : 0);
  };
  function F2(f, a) {
    return f.add(x2(a));
  }
  h.j = function(f) {
    if (C(this) || C(f)) return w;
    if (B2(this)) return B2(f) ? x2(this).j(x2(f)) : x2(x2(this).j(f));
    if (B2(f)) return x2(this.j(x2(f)));
    if (0 > this.l(A) && 0 > f.l(A)) return v(this.m() * f.m());
    for (var a = this.g.length + f.g.length, c = [], d = 0; d < 2 * a; d++) c[d] = 0;
    for (d = 0; d < this.g.length; d++) for (var e = 0; e < f.g.length; e++) {
      var g = this.i(d) >>> 16, b = this.i(d) & 65535, r = f.i(e) >>> 16, E = f.i(e) & 65535;
      c[2 * d + 2 * e] += b * E;
      G2(c, 2 * d + 2 * e);
      c[2 * d + 2 * e + 1] += g * E;
      G2(c, 2 * d + 2 * e + 1);
      c[2 * d + 2 * e + 1] += b * r;
      G2(c, 2 * d + 2 * e + 1);
      c[2 * d + 2 * e + 2] += g * r;
      G2(c, 2 * d + 2 * e + 2);
    }
    for (d = 0; d < a; d++) c[d] = c[2 * d + 1] << 16 | c[2 * d];
    for (d = a; d < 2 * a; d++) c[d] = 0;
    return new t(c, 0);
  };
  function G2(f, a) {
    for (; (f[a] & 65535) != f[a]; ) f[a + 1] += f[a] >>> 16, f[a] &= 65535, a++;
  }
  function H(f, a) {
    this.g = f;
    this.h = a;
  }
  function D(f, a) {
    if (C(a)) throw Error("division by zero");
    if (C(f)) return new H(w, w);
    if (B2(f)) return a = D(x2(f), a), new H(x2(a.g), x2(a.h));
    if (B2(a)) return a = D(f, x2(a)), new H(x2(a.g), a.h);
    if (30 < f.g.length) {
      if (B2(f) || B2(a)) throw Error("slowDivide_ only works with positive integers.");
      for (var c = z2, d = a; 0 >= d.l(f); ) c = I(c), d = I(d);
      var e = J(c, 1), g = J(d, 1);
      d = J(d, 2);
      for (c = J(c, 2); !C(d); ) {
        var b = g.add(d);
        0 >= b.l(f) && (e = e.add(c), g = b);
        d = J(d, 1);
        c = J(c, 1);
      }
      a = F2(f, e.j(a));
      return new H(e, a);
    }
    for (e = w; 0 <= f.l(a); ) {
      c = Math.max(1, Math.floor(f.m() / a.m()));
      d = Math.ceil(Math.log(c) / Math.LN2);
      d = 48 >= d ? 1 : Math.pow(2, d - 48);
      g = v(c);
      for (b = g.j(a); B2(b) || 0 < b.l(f); ) c -= d, g = v(c), b = g.j(a);
      C(g) && (g = z2);
      e = e.add(g);
      f = F2(f, b);
    }
    return new H(e, f);
  }
  h.A = function(f) {
    return D(this, f).h;
  };
  h.and = function(f) {
    for (var a = Math.max(this.g.length, f.g.length), c = [], d = 0; d < a; d++) c[d] = this.i(d) & f.i(d);
    return new t(c, this.h & f.h);
  };
  h.or = function(f) {
    for (var a = Math.max(this.g.length, f.g.length), c = [], d = 0; d < a; d++) c[d] = this.i(d) | f.i(d);
    return new t(c, this.h | f.h);
  };
  h.xor = function(f) {
    for (var a = Math.max(this.g.length, f.g.length), c = [], d = 0; d < a; d++) c[d] = this.i(d) ^ f.i(d);
    return new t(c, this.h ^ f.h);
  };
  function I(f) {
    for (var a = f.g.length + 1, c = [], d = 0; d < a; d++) c[d] = f.i(d) << 1 | f.i(d - 1) >>> 31;
    return new t(c, f.h);
  }
  function J(f, a) {
    var c = a >> 5;
    a %= 32;
    for (var d = f.g.length - c, e = [], g = 0; g < d; g++) e[g] = 0 < a ? f.i(g + c) >>> a | f.i(g + c + 1) << 32 - a : f.i(g + c);
    return new t(e, f.h);
  }
  m.prototype.digest = m.prototype.v;
  m.prototype.reset = m.prototype.s;
  m.prototype.update = m.prototype.u;
  Md5 = m;
  t.prototype.add = t.prototype.add;
  t.prototype.multiply = t.prototype.j;
  t.prototype.modulo = t.prototype.A;
  t.prototype.compare = t.prototype.l;
  t.prototype.toNumber = t.prototype.m;
  t.prototype.toString = t.prototype.toString;
  t.prototype.getBits = t.prototype.i;
  t.fromNumber = v;
  t.fromString = y;
  Integer = t;
}).apply(typeof commonjsGlobal$1 !== "undefined" ? commonjsGlobal$1 : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var XhrIo;
var WebChannel;
var EventType;
var ErrorCode;
var Stat;
var Event$1;
var getStatEventTarget;
var createWebChannelTransport;
(function() {
  var h, aa = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
    if (a == Array.prototype || a == Object.prototype) return a;
    a[b] = c.value;
    return a;
  };
  function ba(a) {
    a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof commonjsGlobal && commonjsGlobal];
    for (var b = 0; b < a.length; ++b) {
      var c = a[b];
      if (c && c.Math == Math) return c;
    }
    throw Error("Cannot find global object");
  }
  var ca = ba(this);
  function da(a, b) {
    if (b) a: {
      var c = ca;
      a = a.split(".");
      for (var d = 0; d < a.length - 1; d++) {
        var e = a[d];
        if (!(e in c)) break a;
        c = c[e];
      }
      a = a[a.length - 1];
      d = c[a];
      b = b(d);
      b != d && null != b && aa(c, a, { configurable: true, writable: true, value: b });
    }
  }
  function ea(a, b) {
    a instanceof String && (a += "");
    var c = 0, d = false, e = { next: function() {
      if (!d && c < a.length) {
        var f = c++;
        return { value: b(f, a[f]), done: false };
      }
      d = true;
      return { done: true, value: void 0 };
    } };
    e[Symbol.iterator] = function() {
      return e;
    };
    return e;
  }
  da("Array.prototype.values", function(a) {
    return a ? a : function() {
      return ea(this, function(b, c) {
        return c;
      });
    };
  });
  /** @license
  
   Copyright The Closure Library Authors.
   SPDX-License-Identifier: Apache-2.0
  */
  var fa = fa || {}, k2 = this || self;
  function ha(a) {
    var b = typeof a;
    b = "object" != b ? b : a ? Array.isArray(a) ? "array" : b : "null";
    return "array" == b || "object" == b && "number" == typeof a.length;
  }
  function n(a) {
    var b = typeof a;
    return "object" == b && null != a || "function" == b;
  }
  function ia(a, b, c) {
    return a.call.apply(a.bind, arguments);
  }
  function ja(a, b, c) {
    if (!a) throw Error();
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function() {
        var e = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(e, d);
        return a.apply(b, e);
      };
    }
    return function() {
      return a.apply(b, arguments);
    };
  }
  function p(a, b, c) {
    p = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ia : ja;
    return p.apply(null, arguments);
  }
  function ka(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function() {
      var d = c.slice();
      d.push.apply(d, arguments);
      return a.apply(this, d);
    };
  }
  function r(a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.aa = b.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
    a.Qb = function(d, e, f) {
      for (var g = Array(arguments.length - 2), m = 2; m < arguments.length; m++) g[m - 2] = arguments[m];
      return b.prototype[e].apply(d, g);
    };
  }
  function la(a) {
    const b = a.length;
    if (0 < b) {
      const c = Array(b);
      for (let d = 0; d < b; d++) c[d] = a[d];
      return c;
    }
    return [];
  }
  function ma(a, b) {
    for (let c = 1; c < arguments.length; c++) {
      const d = arguments[c];
      if (ha(d)) {
        const e = a.length || 0, f = d.length || 0;
        a.length = e + f;
        for (let g = 0; g < f; g++) a[e + g] = d[g];
      } else a.push(d);
    }
  }
  class na {
    constructor(a, b) {
      this.i = a;
      this.j = b;
      this.h = 0;
      this.g = null;
    }
    get() {
      let a;
      0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
      return a;
    }
  }
  function t(a) {
    return /^[\s\xa0]*$/.test(a);
  }
  function u() {
    var a = k2.navigator;
    return a && (a = a.userAgent) ? a : "";
  }
  function oa(a) {
    oa[" "](a);
    return a;
  }
  oa[" "] = function() {
  };
  var pa = -1 != u().indexOf("Gecko") && !(-1 != u().toLowerCase().indexOf("webkit") && -1 == u().indexOf("Edge")) && !(-1 != u().indexOf("Trident") || -1 != u().indexOf("MSIE")) && -1 == u().indexOf("Edge");
  function qa(a, b, c) {
    for (const d in a) b.call(c, a[d], d, a);
  }
  function ra(a, b) {
    for (const c in a) b.call(void 0, a[c], c, a);
  }
  function sa(a) {
    const b = {};
    for (const c in a) b[c] = a[c];
    return b;
  }
  const ta = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function ua(a, b) {
    let c, d;
    for (let e = 1; e < arguments.length; e++) {
      d = arguments[e];
      for (c in d) a[c] = d[c];
      for (let f = 0; f < ta.length; f++) c = ta[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
    }
  }
  function va(a) {
    var b = 1;
    a = a.split(":");
    const c = [];
    for (; 0 < b && a.length; ) c.push(a.shift()), b--;
    a.length && c.push(a.join(":"));
    return c;
  }
  function wa(a) {
    k2.setTimeout(() => {
      throw a;
    }, 0);
  }
  function xa() {
    var a = za;
    let b = null;
    a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
    return b;
  }
  class Aa {
    constructor() {
      this.h = this.g = null;
    }
    add(a, b) {
      const c = Ba.get();
      c.set(a, b);
      this.h ? this.h.next = c : this.g = c;
      this.h = c;
    }
  }
  var Ba = new na(() => new Ca(), (a) => a.reset());
  class Ca {
    constructor() {
      this.next = this.g = this.h = null;
    }
    set(a, b) {
      this.h = a;
      this.g = b;
      this.next = null;
    }
    reset() {
      this.next = this.g = this.h = null;
    }
  }
  let x2, y = false, za = new Aa(), Ea = () => {
    const a = k2.Promise.resolve(void 0);
    x2 = () => {
      a.then(Da);
    };
  };
  var Da = () => {
    for (var a; a = xa(); ) {
      try {
        a.h.call(a.g);
      } catch (c) {
        wa(c);
      }
      var b = Ba;
      b.j(a);
      100 > b.h && (b.h++, a.next = b.g, b.g = a);
    }
    y = false;
  };
  function z2() {
    this.s = this.s;
    this.C = this.C;
  }
  z2.prototype.s = false;
  z2.prototype.ma = function() {
    this.s || (this.s = true, this.N());
  };
  z2.prototype.N = function() {
    if (this.C) for (; this.C.length; ) this.C.shift()();
  };
  function A(a, b) {
    this.type = a;
    this.g = this.target = b;
    this.defaultPrevented = false;
  }
  A.prototype.h = function() {
    this.defaultPrevented = true;
  };
  var Fa = function() {
    if (!k2.addEventListener || !Object.defineProperty) return false;
    var a = false, b = Object.defineProperty({}, "passive", { get: function() {
      a = true;
    } });
    try {
      const c = () => {
      };
      k2.addEventListener("test", c, b);
      k2.removeEventListener("test", c, b);
    } catch (c) {
    }
    return a;
  }();
  function C(a, b) {
    A.call(this, a ? a.type : "");
    this.relatedTarget = this.g = this.target = null;
    this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
    this.key = "";
    this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
    this.state = null;
    this.pointerId = 0;
    this.pointerType = "";
    this.i = null;
    if (a) {
      var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
      this.target = a.target || a.srcElement;
      this.g = b;
      if (b = a.relatedTarget) {
        if (pa) {
          a: {
            try {
              oa(b.nodeName);
              var e = true;
              break a;
            } catch (f) {
            }
            e = false;
          }
          e || (b = null);
        }
      } else "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);
      this.relatedTarget = b;
      d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
      this.button = a.button;
      this.key = a.key || "";
      this.ctrlKey = a.ctrlKey;
      this.altKey = a.altKey;
      this.shiftKey = a.shiftKey;
      this.metaKey = a.metaKey;
      this.pointerId = a.pointerId || 0;
      this.pointerType = "string" === typeof a.pointerType ? a.pointerType : Ga[a.pointerType] || "";
      this.state = a.state;
      this.i = a;
      a.defaultPrevented && C.aa.h.call(this);
    }
  }
  r(C, A);
  var Ga = { 2: "touch", 3: "pen", 4: "mouse" };
  C.prototype.h = function() {
    C.aa.h.call(this);
    var a = this.i;
    a.preventDefault ? a.preventDefault() : a.returnValue = false;
  };
  var D = "closure_listenable_" + (1e6 * Math.random() | 0);
  var Ha = 0;
  function Ia(a, b, c, d, e) {
    this.listener = a;
    this.proxy = null;
    this.src = b;
    this.type = c;
    this.capture = !!d;
    this.ha = e;
    this.key = ++Ha;
    this.da = this.fa = false;
  }
  function Ja(a) {
    a.da = true;
    a.listener = null;
    a.proxy = null;
    a.src = null;
    a.ha = null;
  }
  function Ka(a) {
    this.src = a;
    this.g = {};
    this.h = 0;
  }
  Ka.prototype.add = function(a, b, c, d, e) {
    var f = a.toString();
    a = this.g[f];
    a || (a = this.g[f] = [], this.h++);
    var g = La(a, b, d, e);
    -1 < g ? (b = a[g], c || (b.fa = false)) : (b = new Ia(b, this.src, f, !!d, e), b.fa = c, a.push(b));
    return b;
  };
  function Ma(a, b) {
    var c = b.type;
    if (c in a.g) {
      var d = a.g[c], e = Array.prototype.indexOf.call(d, b, void 0), f;
      (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
      f && (Ja(b), 0 == a.g[c].length && (delete a.g[c], a.h--));
    }
  }
  function La(a, b, c, d) {
    for (var e = 0; e < a.length; ++e) {
      var f = a[e];
      if (!f.da && f.listener == b && f.capture == !!c && f.ha == d) return e;
    }
    return -1;
  }
  var Na = "closure_lm_" + (1e6 * Math.random() | 0), Oa = {};
  function Qa(a, b, c, d, e) {
    if (Array.isArray(b)) {
      for (var f = 0; f < b.length; f++) Qa(a, b[f], c, d, e);
      return null;
    }
    c = Sa(c);
    return a && a[D] ? a.K(b, c, n(d) ? !!d.capture : false, e) : Ta(a, b, c, false, d, e);
  }
  function Ta(a, b, c, d, e, f) {
    if (!b) throw Error("Invalid event type");
    var g = n(e) ? !!e.capture : !!e, m = Ua(a);
    m || (a[Na] = m = new Ka(a));
    c = m.add(b, c, d, g, f);
    if (c.proxy) return c;
    d = Va();
    c.proxy = d;
    d.src = a;
    d.listener = c;
    if (a.addEventListener) Fa || (e = g), void 0 === e && (e = false), a.addEventListener(b.toString(), d, e);
    else if (a.attachEvent) a.attachEvent(Wa(b.toString()), d);
    else if (a.addListener && a.removeListener) a.addListener(d);
    else throw Error("addEventListener and attachEvent are unavailable.");
    return c;
  }
  function Va() {
    function a(c) {
      return b.call(a.src, a.listener, c);
    }
    const b = Xa;
    return a;
  }
  function Ya(a, b, c, d, e) {
    if (Array.isArray(b)) for (var f = 0; f < b.length; f++) Ya(a, b[f], c, d, e);
    else (d = n(d) ? !!d.capture : !!d, c = Sa(c), a && a[D]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = La(f, c, d, e), -1 < c && (Ja(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.g[b], a.h--)))) : a && (a = Ua(a)) && (b = a.g[b.toString()], a = -1, b && (a = La(b, c, d, e)), (c = -1 < a ? b[a] : null) && Za(c));
  }
  function Za(a) {
    if ("number" !== typeof a && a && !a.da) {
      var b = a.src;
      if (b && b[D]) Ma(b.i, a);
      else {
        var c = a.type, d = a.proxy;
        b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(Wa(c), d) : b.addListener && b.removeListener && b.removeListener(d);
        (c = Ua(b)) ? (Ma(c, a), 0 == c.h && (c.src = null, b[Na] = null)) : Ja(a);
      }
    }
  }
  function Wa(a) {
    return a in Oa ? Oa[a] : Oa[a] = "on" + a;
  }
  function Xa(a, b) {
    if (a.da) a = true;
    else {
      b = new C(b, this);
      var c = a.listener, d = a.ha || a.src;
      a.fa && Za(a);
      a = c.call(d, b);
    }
    return a;
  }
  function Ua(a) {
    a = a[Na];
    return a instanceof Ka ? a : null;
  }
  var $a = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
  function Sa(a) {
    if ("function" === typeof a) return a;
    a[$a] || (a[$a] = function(b) {
      return a.handleEvent(b);
    });
    return a[$a];
  }
  function E() {
    z2.call(this);
    this.i = new Ka(this);
    this.M = this;
    this.F = null;
  }
  r(E, z2);
  E.prototype[D] = true;
  E.prototype.removeEventListener = function(a, b, c, d) {
    Ya(this, a, b, c, d);
  };
  function F2(a, b) {
    var c, d = a.F;
    if (d) for (c = []; d; d = d.F) c.push(d);
    a = a.M;
    d = b.type || b;
    if ("string" === typeof b) b = new A(b, a);
    else if (b instanceof A) b.target = b.target || a;
    else {
      var e = b;
      b = new A(d, a);
      ua(b, e);
    }
    e = true;
    if (c) for (var f = c.length - 1; 0 <= f; f--) {
      var g = b.g = c[f];
      e = ab(g, d, true, b) && e;
    }
    g = b.g = a;
    e = ab(g, d, true, b) && e;
    e = ab(g, d, false, b) && e;
    if (c) for (f = 0; f < c.length; f++) g = b.g = c[f], e = ab(g, d, false, b) && e;
  }
  E.prototype.N = function() {
    E.aa.N.call(this);
    if (this.i) {
      var a = this.i, c;
      for (c in a.g) {
        for (var d = a.g[c], e = 0; e < d.length; e++) Ja(d[e]);
        delete a.g[c];
        a.h--;
      }
    }
    this.F = null;
  };
  E.prototype.K = function(a, b, c, d) {
    return this.i.add(String(a), b, false, c, d);
  };
  E.prototype.L = function(a, b, c, d) {
    return this.i.add(String(a), b, true, c, d);
  };
  function ab(a, b, c, d) {
    b = a.i.g[String(b)];
    if (!b) return true;
    b = b.concat();
    for (var e = true, f = 0; f < b.length; ++f) {
      var g = b[f];
      if (g && !g.da && g.capture == c) {
        var m = g.listener, q2 = g.ha || g.src;
        g.fa && Ma(a.i, g);
        e = false !== m.call(q2, d) && e;
      }
    }
    return e && !d.defaultPrevented;
  }
  function bb(a, b, c) {
    if ("function" === typeof a) c && (a = p(a, c));
    else if (a && "function" == typeof a.handleEvent) a = p(a.handleEvent, a);
    else throw Error("Invalid listener argument");
    return 2147483647 < Number(b) ? -1 : k2.setTimeout(a, b || 0);
  }
  function cb(a) {
    a.g = bb(() => {
      a.g = null;
      a.i && (a.i = false, cb(a));
    }, a.l);
    const b = a.h;
    a.h = null;
    a.m.apply(null, b);
  }
  class eb extends z2 {
    constructor(a, b) {
      super();
      this.m = a;
      this.l = b;
      this.h = null;
      this.i = false;
      this.g = null;
    }
    j(a) {
      this.h = arguments;
      this.g ? this.i = true : cb(this);
    }
    N() {
      super.N();
      this.g && (k2.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
    }
  }
  function G2(a) {
    z2.call(this);
    this.h = a;
    this.g = {};
  }
  r(G2, z2);
  var fb = [];
  function gb(a) {
    qa(a.g, function(b, c) {
      this.g.hasOwnProperty(c) && Za(b);
    }, a);
    a.g = {};
  }
  G2.prototype.N = function() {
    G2.aa.N.call(this);
    gb(this);
  };
  G2.prototype.handleEvent = function() {
    throw Error("EventHandler.handleEvent not implemented");
  };
  var hb = k2.JSON.stringify;
  var ib = k2.JSON.parse;
  var jb = class {
    stringify(a) {
      return k2.JSON.stringify(a, void 0);
    }
    parse(a) {
      return k2.JSON.parse(a, void 0);
    }
  };
  function kb() {
  }
  kb.prototype.h = null;
  function lb(a) {
    return a.h || (a.h = a.i());
  }
  function mb() {
  }
  var H = { OPEN: "a", kb: "b", Ja: "c", wb: "d" };
  function nb() {
    A.call(this, "d");
  }
  r(nb, A);
  function ob() {
    A.call(this, "c");
  }
  r(ob, A);
  var I = {}, pb = null;
  function qb() {
    return pb = pb || new E();
  }
  I.La = "serverreachability";
  function rb(a) {
    A.call(this, I.La, a);
  }
  r(rb, A);
  function J(a) {
    const b = qb();
    F2(b, new rb(b));
  }
  I.STAT_EVENT = "statevent";
  function sb(a, b) {
    A.call(this, I.STAT_EVENT, a);
    this.stat = b;
  }
  r(sb, A);
  function K(a) {
    const b = qb();
    F2(b, new sb(b, a));
  }
  I.Ma = "timingevent";
  function tb(a, b) {
    A.call(this, I.Ma, a);
    this.size = b;
  }
  r(tb, A);
  function ub(a, b) {
    if ("function" !== typeof a) throw Error("Fn must not be null and must be a function");
    return k2.setTimeout(function() {
      a();
    }, b);
  }
  function vb() {
    this.g = true;
  }
  vb.prototype.xa = function() {
    this.g = false;
  };
  function wb(a, b, c, d, e, f) {
    a.info(function() {
      if (a.g) if (f) {
        var g = "";
        for (var m = f.split("&"), q2 = 0; q2 < m.length; q2++) {
          var l = m[q2].split("=");
          if (1 < l.length) {
            var v = l[0];
            l = l[1];
            var w = v.split("_");
            g = 2 <= w.length && "type" == w[1] ? g + (v + "=" + l + "&") : g + (v + "=redacted&");
          }
        }
      } else g = null;
      else g = f;
      return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + g;
    });
  }
  function xb(a, b, c, d, e, f, g) {
    a.info(function() {
      return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + g;
    });
  }
  function L2(a, b, c, d) {
    a.info(function() {
      return "XMLHTTP TEXT (" + b + "): " + yb(a, c) + (d ? " " + d : "");
    });
  }
  function zb(a, b) {
    a.info(function() {
      return "TIMEOUT: " + b;
    });
  }
  vb.prototype.info = function() {
  };
  function yb(a, b) {
    if (!a.g) return b;
    if (!b) return null;
    try {
      var c = JSON.parse(b);
      if (c) {
        for (a = 0; a < c.length; a++) if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if ("noop" != f && "stop" != f && "close" != f) for (var g = 1; g < e.length; g++) e[g] = "";
            }
          }
        }
      }
      return hb(c);
    } catch (m) {
      return b;
    }
  }
  var Ab = { NO_ERROR: 0, gb: 1, tb: 2, sb: 3, nb: 4, rb: 5, ub: 6, Ia: 7, TIMEOUT: 8, xb: 9 };
  var Bb = { lb: "complete", Hb: "success", Ja: "error", Ia: "abort", zb: "ready", Ab: "readystatechange", TIMEOUT: "timeout", vb: "incrementaldata", yb: "progress", ob: "downloadprogress", Pb: "uploadprogress" };
  var Cb;
  function Db() {
  }
  r(Db, kb);
  Db.prototype.g = function() {
    return new XMLHttpRequest();
  };
  Db.prototype.i = function() {
    return {};
  };
  Cb = new Db();
  function M2(a, b, c, d) {
    this.j = a;
    this.i = b;
    this.l = c;
    this.R = d || 1;
    this.U = new G2(this);
    this.I = 45e3;
    this.H = null;
    this.o = false;
    this.m = this.A = this.v = this.L = this.F = this.S = this.B = null;
    this.D = [];
    this.g = null;
    this.C = 0;
    this.s = this.u = null;
    this.X = -1;
    this.J = false;
    this.O = 0;
    this.M = null;
    this.W = this.K = this.T = this.P = false;
    this.h = new Eb();
  }
  function Eb() {
    this.i = null;
    this.g = "";
    this.h = false;
  }
  var Fb = {}, Gb = {};
  function Hb(a, b, c) {
    a.L = 1;
    a.v = Ib(N2(b));
    a.m = c;
    a.P = true;
    Jb(a, null);
  }
  function Jb(a, b) {
    a.F = Date.now();
    Kb(a);
    a.A = N2(a.v);
    var c = a.A, d = a.R;
    Array.isArray(d) || (d = [String(d)]);
    Lb(c.i, "t", d);
    a.C = 0;
    c = a.j.J;
    a.h = new Eb();
    a.g = Mb(a.j, c ? b : null, !a.m);
    0 < a.O && (a.M = new eb(p(a.Y, a, a.g), a.O));
    b = a.U;
    c = a.g;
    d = a.ca;
    var e = "readystatechange";
    Array.isArray(e) || (e && (fb[0] = e.toString()), e = fb);
    for (var f = 0; f < e.length; f++) {
      var g = Qa(c, e[f], d || b.handleEvent, false, b.h || b);
      if (!g) break;
      b.g[g.key] = g;
    }
    b = a.H ? sa(a.H) : {};
    a.m ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(
      a.A,
      a.u,
      a.m,
      b
    )) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
    J();
    wb(a.i, a.u, a.A, a.l, a.R, a.m);
  }
  M2.prototype.ca = function(a) {
    a = a.target;
    const b = this.M;
    b && 3 == P(a) ? b.j() : this.Y(a);
  };
  M2.prototype.Y = function(a) {
    try {
      if (a == this.g) a: {
        const w = P(this.g);
        var b = this.g.Ba();
        const O2 = this.g.Z();
        if (!(3 > w) && (3 != w || this.g && (this.h.h || this.g.oa() || Nb(this.g)))) {
          this.J || 4 != w || 7 == b || (8 == b || 0 >= O2 ? J(3) : J(2));
          Ob(this);
          var c = this.g.Z();
          this.X = c;
          b: if (Pb(this)) {
            var d = Nb(this.g);
            a = "";
            var e = d.length, f = 4 == P(this.g);
            if (!this.h.i) {
              if ("undefined" === typeof TextDecoder) {
                Q2(this);
                Qb(this);
                var g = "";
                break b;
              }
              this.h.i = new k2.TextDecoder();
            }
            for (b = 0; b < e; b++) this.h.h = true, a += this.h.i.decode(d[b], { stream: !(f && b == e - 1) });
            d.length = 0;
            this.h.g += a;
            this.C = 0;
            g = this.h.g;
          } else g = this.g.oa();
          this.o = 200 == c;
          xb(this.i, this.u, this.A, this.l, this.R, w, c);
          if (this.o) {
            if (this.T && !this.K) {
              b: {
                if (this.g) {
                  var m, q2 = this.g;
                  if ((m = q2.g ? q2.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !t(m)) {
                    var l = m;
                    break b;
                  }
                }
                l = null;
              }
              if (c = l) L2(this.i, this.l, c, "Initial handshake response via X-HTTP-Initial-Response"), this.K = true, Rb(this, c);
              else {
                this.o = false;
                this.s = 3;
                K(12);
                Q2(this);
                Qb(this);
                break a;
              }
            }
            if (this.P) {
              c = true;
              let B2;
              for (; !this.J && this.C < g.length; ) if (B2 = Sb(this, g), B2 == Gb) {
                4 == w && (this.s = 4, K(14), c = false);
                L2(this.i, this.l, null, "[Incomplete Response]");
                break;
              } else if (B2 == Fb) {
                this.s = 4;
                K(15);
                L2(this.i, this.l, g, "[Invalid Chunk]");
                c = false;
                break;
              } else L2(this.i, this.l, B2, null), Rb(this, B2);
              Pb(this) && 0 != this.C && (this.h.g = this.h.g.slice(this.C), this.C = 0);
              4 != w || 0 != g.length || this.h.h || (this.s = 1, K(16), c = false);
              this.o = this.o && c;
              if (!c) L2(this.i, this.l, g, "[Invalid Chunked Response]"), Q2(this), Qb(this);
              else if (0 < g.length && !this.W) {
                this.W = true;
                var v = this.j;
                v.g == this && v.ba && !v.M && (v.j.info("Great, no buffering proxy detected. Bytes received: " + g.length), Tb(v), v.M = true, K(11));
              }
            } else L2(this.i, this.l, g, null), Rb(this, g);
            4 == w && Q2(this);
            this.o && !this.J && (4 == w ? Ub(this.j, this) : (this.o = false, Kb(this)));
          } else Vb(this.g), 400 == c && 0 < g.indexOf("Unknown SID") ? (this.s = 3, K(12)) : (this.s = 0, K(13)), Q2(this), Qb(this);
        }
      }
    } catch (w) {
    } finally {
    }
  };
  function Pb(a) {
    return a.g ? "GET" == a.u && 2 != a.L && a.j.Ca : false;
  }
  function Sb(a, b) {
    var c = a.C, d = b.indexOf("\n", c);
    if (-1 == d) return Gb;
    c = Number(b.substring(c, d));
    if (isNaN(c)) return Fb;
    d += 1;
    if (d + c > b.length) return Gb;
    b = b.slice(d, d + c);
    a.C = d + c;
    return b;
  }
  M2.prototype.cancel = function() {
    this.J = true;
    Q2(this);
  };
  function Kb(a) {
    a.S = Date.now() + a.I;
    Wb(a, a.I);
  }
  function Wb(a, b) {
    if (null != a.B) throw Error("WatchDog timer not null");
    a.B = ub(p(a.ba, a), b);
  }
  function Ob(a) {
    a.B && (k2.clearTimeout(a.B), a.B = null);
  }
  M2.prototype.ba = function() {
    this.B = null;
    const a = Date.now();
    0 <= a - this.S ? (zb(this.i, this.A), 2 != this.L && (J(), K(17)), Q2(this), this.s = 2, Qb(this)) : Wb(this, this.S - a);
  };
  function Qb(a) {
    0 == a.j.G || a.J || Ub(a.j, a);
  }
  function Q2(a) {
    Ob(a);
    var b = a.M;
    b && "function" == typeof b.ma && b.ma();
    a.M = null;
    gb(a.U);
    a.g && (b = a.g, a.g = null, b.abort(), b.ma());
  }
  function Rb(a, b) {
    try {
      var c = a.j;
      if (0 != c.G && (c.g == a || Xb(c.h, a))) {
        if (!a.K && Xb(c.h, a) && 3 == c.G) {
          try {
            var d = c.Da.g.parse(b);
          } catch (l) {
            d = null;
          }
          if (Array.isArray(d) && 3 == d.length) {
            var e = d;
            if (0 == e[0]) a: {
              if (!c.u) {
                if (c.g) if (c.g.F + 3e3 < a.F) Yb(c), Zb(c);
                else break a;
                $b(c);
                K(18);
              }
            }
            else c.za = e[1], 0 < c.za - c.T && 37500 > e[2] && c.F && 0 == c.v && !c.C && (c.C = ub(p(c.Za, c), 6e3));
            if (1 >= ac(c.h) && c.ca) {
              try {
                c.ca();
              } catch (l) {
              }
              c.ca = void 0;
            }
          } else R(c, 11);
        } else if ((a.K || c.g == a) && Yb(c), !t(b)) for (e = c.Da.g.parse(b), b = 0; b < e.length; b++) {
          let l = e[b];
          c.T = l[0];
          l = l[1];
          if (2 == c.G) if ("c" == l[0]) {
            c.K = l[1];
            c.ia = l[2];
            const v = l[3];
            null != v && (c.la = v, c.j.info("VER=" + c.la));
            const w = l[4];
            null != w && (c.Aa = w, c.j.info("SVER=" + c.Aa));
            const O2 = l[5];
            null != O2 && "number" === typeof O2 && 0 < O2 && (d = 1.5 * O2, c.L = d, c.j.info("backChannelRequestTimeoutMs_=" + d));
            d = c;
            const B2 = a.g;
            if (B2) {
              const ya = B2.g ? B2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
              if (ya) {
                var f = d.h;
                f.g || -1 == ya.indexOf("spdy") && -1 == ya.indexOf("quic") && -1 == ya.indexOf("h2") || (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (bc(f, f.h), f.h = null));
              }
              if (d.D) {
                const db2 = B2.g ? B2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                db2 && (d.ya = db2, S(d.I, d.D, db2));
              }
            }
            c.G = 3;
            c.l && c.l.ua();
            c.ba && (c.R = Date.now() - a.F, c.j.info("Handshake RTT: " + c.R + "ms"));
            d = c;
            var g = a;
            d.qa = cc(d, d.J ? d.ia : null, d.W);
            if (g.K) {
              dc(d.h, g);
              var m = g, q2 = d.L;
              q2 && (m.I = q2);
              m.B && (Ob(m), Kb(m));
              d.g = g;
            } else ec(d);
            0 < c.i.length && fc(c);
          } else "stop" != l[0] && "close" != l[0] || R(c, 7);
          else 3 == c.G && ("stop" == l[0] || "close" == l[0] ? "stop" == l[0] ? R(c, 7) : gc(c) : "noop" != l[0] && c.l && c.l.ta(l), c.v = 0);
        }
      }
      J(4);
    } catch (l) {
    }
  }
  var hc = class {
    constructor(a, b) {
      this.g = a;
      this.map = b;
    }
  };
  function ic(a) {
    this.l = a || 10;
    k2.PerformanceNavigationTiming ? (a = k2.performance.getEntriesByType("navigation"), a = 0 < a.length && ("hq" == a[0].nextHopProtocol || "h2" == a[0].nextHopProtocol)) : a = !!(k2.chrome && k2.chrome.loadTimes && k2.chrome.loadTimes() && k2.chrome.loadTimes().wasFetchedViaSpdy);
    this.j = a ? this.l : 1;
    this.g = null;
    1 < this.j && (this.g = /* @__PURE__ */ new Set());
    this.h = null;
    this.i = [];
  }
  function jc(a) {
    return a.h ? true : a.g ? a.g.size >= a.j : false;
  }
  function ac(a) {
    return a.h ? 1 : a.g ? a.g.size : 0;
  }
  function Xb(a, b) {
    return a.h ? a.h == b : a.g ? a.g.has(b) : false;
  }
  function bc(a, b) {
    a.g ? a.g.add(b) : a.h = b;
  }
  function dc(a, b) {
    a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
  }
  ic.prototype.cancel = function() {
    this.i = kc(this);
    if (this.h) this.h.cancel(), this.h = null;
    else if (this.g && 0 !== this.g.size) {
      for (const a of this.g.values()) a.cancel();
      this.g.clear();
    }
  };
  function kc(a) {
    if (null != a.h) return a.i.concat(a.h.D);
    if (null != a.g && 0 !== a.g.size) {
      let b = a.i;
      for (const c of a.g.values()) b = b.concat(c.D);
      return b;
    }
    return la(a.i);
  }
  function lc(a) {
    if (a.V && "function" == typeof a.V) return a.V();
    if ("undefined" !== typeof Map && a instanceof Map || "undefined" !== typeof Set && a instanceof Set) return Array.from(a.values());
    if ("string" === typeof a) return a.split("");
    if (ha(a)) {
      for (var b = [], c = a.length, d = 0; d < c; d++) b.push(a[d]);
      return b;
    }
    b = [];
    c = 0;
    for (d in a) b[c++] = a[d];
    return b;
  }
  function mc(a) {
    if (a.na && "function" == typeof a.na) return a.na();
    if (!a.V || "function" != typeof a.V) {
      if ("undefined" !== typeof Map && a instanceof Map) return Array.from(a.keys());
      if (!("undefined" !== typeof Set && a instanceof Set)) {
        if (ha(a) || "string" === typeof a) {
          var b = [];
          a = a.length;
          for (var c = 0; c < a; c++) b.push(c);
          return b;
        }
        b = [];
        c = 0;
        for (const d in a) b[c++] = d;
        return b;
      }
    }
  }
  function nc(a, b) {
    if (a.forEach && "function" == typeof a.forEach) a.forEach(b, void 0);
    else if (ha(a) || "string" === typeof a) Array.prototype.forEach.call(a, b, void 0);
    else for (var c = mc(a), d = lc(a), e = d.length, f = 0; f < e; f++) b.call(void 0, d[f], c && c[f], a);
  }
  var oc = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
  function pc(a, b) {
    if (a) {
      a = a.split("&");
      for (var c = 0; c < a.length; c++) {
        var d = a[c].indexOf("="), e = null;
        if (0 <= d) {
          var f = a[c].substring(0, d);
          e = a[c].substring(d + 1);
        } else f = a[c];
        b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
      }
    }
  }
  function T(a) {
    this.g = this.o = this.j = "";
    this.s = null;
    this.m = this.l = "";
    this.h = false;
    if (a instanceof T) {
      this.h = a.h;
      qc(this, a.j);
      this.o = a.o;
      this.g = a.g;
      rc(this, a.s);
      this.l = a.l;
      var b = a.i;
      var c = new sc();
      c.i = b.i;
      b.g && (c.g = new Map(b.g), c.h = b.h);
      tc(this, c);
      this.m = a.m;
    } else a && (b = String(a).match(oc)) ? (this.h = false, qc(this, b[1] || "", true), this.o = uc(b[2] || ""), this.g = uc(b[3] || "", true), rc(this, b[4]), this.l = uc(b[5] || "", true), tc(this, b[6] || "", true), this.m = uc(b[7] || "")) : (this.h = false, this.i = new sc(null, this.h));
  }
  T.prototype.toString = function() {
    var a = [], b = this.j;
    b && a.push(vc(b, wc, true), ":");
    var c = this.g;
    if (c || "file" == b) a.push("//"), (b = this.o) && a.push(vc(b, wc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.s, null != c && a.push(":", String(c));
    if (c = this.l) this.g && "/" != c.charAt(0) && a.push("/"), a.push(vc(c, "/" == c.charAt(0) ? xc : yc, true));
    (c = this.i.toString()) && a.push("?", c);
    (c = this.m) && a.push("#", vc(c, zc));
    return a.join("");
  };
  function N2(a) {
    return new T(a);
  }
  function qc(a, b, c) {
    a.j = c ? uc(b, true) : b;
    a.j && (a.j = a.j.replace(/:$/, ""));
  }
  function rc(a, b) {
    if (b) {
      b = Number(b);
      if (isNaN(b) || 0 > b) throw Error("Bad port number " + b);
      a.s = b;
    } else a.s = null;
  }
  function tc(a, b, c) {
    b instanceof sc ? (a.i = b, Ac(a.i, a.h)) : (c || (b = vc(b, Bc)), a.i = new sc(b, a.h));
  }
  function S(a, b, c) {
    a.i.set(b, c);
  }
  function Ib(a) {
    S(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
    return a;
  }
  function uc(a, b) {
    return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
  }
  function vc(a, b, c) {
    return "string" === typeof a ? (a = encodeURI(a).replace(b, Cc), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
  }
  function Cc(a) {
    a = a.charCodeAt(0);
    return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
  }
  var wc = /[#\/\?@]/g, yc = /[#\?:]/g, xc = /[#\?]/g, Bc = /[#\?@]/g, zc = /#/g;
  function sc(a, b) {
    this.h = this.g = null;
    this.i = a || null;
    this.j = !!b;
  }
  function U(a) {
    a.g || (a.g = /* @__PURE__ */ new Map(), a.h = 0, a.i && pc(a.i, function(b, c) {
      a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
    }));
  }
  h = sc.prototype;
  h.add = function(a, b) {
    U(this);
    this.i = null;
    a = V(this, a);
    var c = this.g.get(a);
    c || this.g.set(a, c = []);
    c.push(b);
    this.h += 1;
    return this;
  };
  function Dc(a, b) {
    U(a);
    b = V(a, b);
    a.g.has(b) && (a.i = null, a.h -= a.g.get(b).length, a.g.delete(b));
  }
  function Ec(a, b) {
    U(a);
    b = V(a, b);
    return a.g.has(b);
  }
  h.forEach = function(a, b) {
    U(this);
    this.g.forEach(function(c, d) {
      c.forEach(function(e) {
        a.call(b, e, d, this);
      }, this);
    }, this);
  };
  h.na = function() {
    U(this);
    const a = Array.from(this.g.values()), b = Array.from(this.g.keys()), c = [];
    for (let d = 0; d < b.length; d++) {
      const e = a[d];
      for (let f = 0; f < e.length; f++) c.push(b[d]);
    }
    return c;
  };
  h.V = function(a) {
    U(this);
    let b = [];
    if ("string" === typeof a) Ec(this, a) && (b = b.concat(this.g.get(V(this, a))));
    else {
      a = Array.from(this.g.values());
      for (let c = 0; c < a.length; c++) b = b.concat(a[c]);
    }
    return b;
  };
  h.set = function(a, b) {
    U(this);
    this.i = null;
    a = V(this, a);
    Ec(this, a) && (this.h -= this.g.get(a).length);
    this.g.set(a, [b]);
    this.h += 1;
    return this;
  };
  h.get = function(a, b) {
    if (!a) return b;
    a = this.V(a);
    return 0 < a.length ? String(a[0]) : b;
  };
  function Lb(a, b, c) {
    Dc(a, b);
    0 < c.length && (a.i = null, a.g.set(V(a, b), la(c)), a.h += c.length);
  }
  h.toString = function() {
    if (this.i) return this.i;
    if (!this.g) return "";
    const a = [], b = Array.from(this.g.keys());
    for (var c = 0; c < b.length; c++) {
      var d = b[c];
      const f = encodeURIComponent(String(d)), g = this.V(d);
      for (d = 0; d < g.length; d++) {
        var e = f;
        "" !== g[d] && (e += "=" + encodeURIComponent(String(g[d])));
        a.push(e);
      }
    }
    return this.i = a.join("&");
  };
  function V(a, b) {
    b = String(b);
    a.j && (b = b.toLowerCase());
    return b;
  }
  function Ac(a, b) {
    b && !a.j && (U(a), a.i = null, a.g.forEach(function(c, d) {
      var e = d.toLowerCase();
      d != e && (Dc(this, d), Lb(this, e, c));
    }, a));
    a.j = b;
  }
  function Fc(a, b) {
    const c = new vb();
    if (k2.Image) {
      const d = new Image();
      d.onload = ka(W, c, "TestLoadImage: loaded", true, b, d);
      d.onerror = ka(W, c, "TestLoadImage: error", false, b, d);
      d.onabort = ka(W, c, "TestLoadImage: abort", false, b, d);
      d.ontimeout = ka(W, c, "TestLoadImage: timeout", false, b, d);
      k2.setTimeout(function() {
        if (d.ontimeout) d.ontimeout();
      }, 1e4);
      d.src = a;
    } else b(false);
  }
  function Gc(a, b) {
    const c = new vb(), d = new AbortController(), e = setTimeout(() => {
      d.abort();
      W(c, "TestPingServer: timeout", false, b);
    }, 1e4);
    fetch(a, { signal: d.signal }).then((f) => {
      clearTimeout(e);
      f.ok ? W(c, "TestPingServer: ok", true, b) : W(c, "TestPingServer: server error", false, b);
    }).catch(() => {
      clearTimeout(e);
      W(c, "TestPingServer: error", false, b);
    });
  }
  function W(a, b, c, d, e) {
    try {
      e && (e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null), d(c);
    } catch (f) {
    }
  }
  function Hc() {
    this.g = new jb();
  }
  function Ic(a, b, c) {
    const d = c || "";
    try {
      nc(a, function(e, f) {
        let g = e;
        n(e) && (g = hb(e));
        b.push(d + f + "=" + encodeURIComponent(g));
      });
    } catch (e) {
      throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
    }
  }
  function Jc(a) {
    this.l = a.Ub || null;
    this.j = a.eb || false;
  }
  r(Jc, kb);
  Jc.prototype.g = function() {
    return new Kc(this.l, this.j);
  };
  Jc.prototype.i = /* @__PURE__ */ function(a) {
    return function() {
      return a;
    };
  }({});
  function Kc(a, b) {
    E.call(this);
    this.D = a;
    this.o = b;
    this.m = void 0;
    this.status = this.readyState = 0;
    this.responseType = this.responseText = this.response = this.statusText = "";
    this.onreadystatechange = null;
    this.u = new Headers();
    this.h = null;
    this.B = "GET";
    this.A = "";
    this.g = false;
    this.v = this.j = this.l = null;
  }
  r(Kc, E);
  h = Kc.prototype;
  h.open = function(a, b) {
    if (0 != this.readyState) throw this.abort(), Error("Error reopening a connection");
    this.B = a;
    this.A = b;
    this.readyState = 1;
    Lc(this);
  };
  h.send = function(a) {
    if (1 != this.readyState) throw this.abort(), Error("need to call open() first. ");
    this.g = true;
    const b = { headers: this.u, method: this.B, credentials: this.m, cache: void 0 };
    a && (b.body = a);
    (this.D || k2).fetch(new Request(this.A, b)).then(this.Sa.bind(this), this.ga.bind(this));
  };
  h.abort = function() {
    this.response = this.responseText = "";
    this.u = new Headers();
    this.status = 0;
    this.j && this.j.cancel("Request was aborted.").catch(() => {
    });
    1 <= this.readyState && this.g && 4 != this.readyState && (this.g = false, Mc(this));
    this.readyState = 0;
  };
  h.Sa = function(a) {
    if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, Lc(this)), this.g && (this.readyState = 3, Lc(this), this.g))) if ("arraybuffer" === this.responseType) a.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
    else if ("undefined" !== typeof k2.ReadableStream && "body" in a) {
      this.j = a.body.getReader();
      if (this.o) {
        if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else this.response = this.responseText = "", this.v = new TextDecoder();
      Nc(this);
    } else a.text().then(this.Ra.bind(this), this.ga.bind(this));
  };
  function Nc(a) {
    a.j.read().then(a.Pa.bind(a)).catch(a.ga.bind(a));
  }
  h.Pa = function(a) {
    if (this.g) {
      if (this.o && a.value) this.response.push(a.value);
      else if (!this.o) {
        var b = a.value ? a.value : new Uint8Array(0);
        if (b = this.v.decode(b, { stream: !a.done })) this.response = this.responseText += b;
      }
      a.done ? Mc(this) : Lc(this);
      3 == this.readyState && Nc(this);
    }
  };
  h.Ra = function(a) {
    this.g && (this.response = this.responseText = a, Mc(this));
  };
  h.Qa = function(a) {
    this.g && (this.response = a, Mc(this));
  };
  h.ga = function() {
    this.g && Mc(this);
  };
  function Mc(a) {
    a.readyState = 4;
    a.l = null;
    a.j = null;
    a.v = null;
    Lc(a);
  }
  h.setRequestHeader = function(a, b) {
    this.u.append(a, b);
  };
  h.getResponseHeader = function(a) {
    return this.h ? this.h.get(a.toLowerCase()) || "" : "";
  };
  h.getAllResponseHeaders = function() {
    if (!this.h) return "";
    const a = [], b = this.h.entries();
    for (var c = b.next(); !c.done; ) c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
    return a.join("\r\n");
  };
  function Lc(a) {
    a.onreadystatechange && a.onreadystatechange.call(a);
  }
  Object.defineProperty(Kc.prototype, "withCredentials", { get: function() {
    return "include" === this.m;
  }, set: function(a) {
    this.m = a ? "include" : "same-origin";
  } });
  function Oc(a) {
    let b = "";
    qa(a, function(c, d) {
      b += d;
      b += ":";
      b += c;
      b += "\r\n";
    });
    return b;
  }
  function Pc(a, b, c) {
    a: {
      for (d in c) {
        var d = false;
        break a;
      }
      d = true;
    }
    d || (c = Oc(c), "string" === typeof a ? null != c && encodeURIComponent(String(c)) : S(a, b, c));
  }
  function X(a) {
    E.call(this);
    this.headers = /* @__PURE__ */ new Map();
    this.o = a || null;
    this.h = false;
    this.v = this.g = null;
    this.D = "";
    this.m = 0;
    this.l = "";
    this.j = this.B = this.u = this.A = false;
    this.I = null;
    this.H = "";
    this.J = false;
  }
  r(X, E);
  var Qc = /^https?$/i, Rc = ["POST", "PUT"];
  h = X.prototype;
  h.Ha = function(a) {
    this.J = a;
  };
  h.ea = function(a, b, c, d) {
    if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + a);
    b = b ? b.toUpperCase() : "GET";
    this.D = a;
    this.l = "";
    this.m = 0;
    this.A = false;
    this.h = true;
    this.g = this.o ? this.o.g() : Cb.g();
    this.v = this.o ? lb(this.o) : lb(Cb);
    this.g.onreadystatechange = p(this.Ea, this);
    try {
      this.B = true, this.g.open(b, String(a), true), this.B = false;
    } catch (f) {
      Sc(this, f);
      return;
    }
    a = c || "";
    c = new Map(this.headers);
    if (d) if (Object.getPrototypeOf(d) === Object.prototype) for (var e in d) c.set(e, d[e]);
    else if ("function" === typeof d.keys && "function" === typeof d.get) for (const f of d.keys()) c.set(f, d.get(f));
    else throw Error("Unknown input type for opt_headers: " + String(d));
    d = Array.from(c.keys()).find((f) => "content-type" == f.toLowerCase());
    e = k2.FormData && a instanceof k2.FormData;
    !(0 <= Array.prototype.indexOf.call(Rc, b, void 0)) || d || e || c.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
    for (const [f, g] of c) this.g.setRequestHeader(f, g);
    this.H && (this.g.responseType = this.H);
    "withCredentials" in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
    try {
      Tc(this), this.u = true, this.g.send(a), this.u = false;
    } catch (f) {
      Sc(this, f);
    }
  };
  function Sc(a, b) {
    a.h = false;
    a.g && (a.j = true, a.g.abort(), a.j = false);
    a.l = b;
    a.m = 5;
    Uc(a);
    Vc(a);
  }
  function Uc(a) {
    a.A || (a.A = true, F2(a, "complete"), F2(a, "error"));
  }
  h.abort = function(a) {
    this.g && this.h && (this.h = false, this.j = true, this.g.abort(), this.j = false, this.m = a || 7, F2(this, "complete"), F2(this, "abort"), Vc(this));
  };
  h.N = function() {
    this.g && (this.h && (this.h = false, this.j = true, this.g.abort(), this.j = false), Vc(this, true));
    X.aa.N.call(this);
  };
  h.Ea = function() {
    this.s || (this.B || this.u || this.j ? Wc(this) : this.bb());
  };
  h.bb = function() {
    Wc(this);
  };
  function Wc(a) {
    if (a.h && "undefined" != typeof fa && (!a.v[1] || 4 != P(a) || 2 != a.Z())) {
      if (a.u && 4 == P(a)) bb(a.Ea, 0, a);
      else if (F2(a, "readystatechange"), 4 == P(a)) {
        a.h = false;
        try {
          const g = a.Z();
          a: switch (g) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
          var c;
          if (!(c = b)) {
            var d;
            if (d = 0 === g) {
              var e = String(a.D).match(oc)[1] || null;
              !e && k2.self && k2.self.location && (e = k2.self.location.protocol.slice(0, -1));
              d = !Qc.test(e ? e.toLowerCase() : "");
            }
            c = d;
          }
          if (c) F2(a, "complete"), F2(a, "success");
          else {
            a.m = 6;
            try {
              var f = 2 < P(a) ? a.g.statusText : "";
            } catch (m) {
              f = "";
            }
            a.l = f + " [" + a.Z() + "]";
            Uc(a);
          }
        } finally {
          Vc(a);
        }
      }
    }
  }
  function Vc(a, b) {
    if (a.g) {
      Tc(a);
      const c = a.g, d = a.v[0] ? () => {
      } : null;
      a.g = null;
      a.v = null;
      b || F2(a, "ready");
      try {
        c.onreadystatechange = d;
      } catch (e) {
      }
    }
  }
  function Tc(a) {
    a.I && (k2.clearTimeout(a.I), a.I = null);
  }
  h.isActive = function() {
    return !!this.g;
  };
  function P(a) {
    return a.g ? a.g.readyState : 0;
  }
  h.Z = function() {
    try {
      return 2 < P(this) ? this.g.status : -1;
    } catch (a) {
      return -1;
    }
  };
  h.oa = function() {
    try {
      return this.g ? this.g.responseText : "";
    } catch (a) {
      return "";
    }
  };
  h.Oa = function(a) {
    if (this.g) {
      var b = this.g.responseText;
      a && 0 == b.indexOf(a) && (b = b.substring(a.length));
      return ib(b);
    }
  };
  function Nb(a) {
    try {
      if (!a.g) return null;
      if ("response" in a.g) return a.g.response;
      switch (a.H) {
        case "":
        case "text":
          return a.g.responseText;
        case "arraybuffer":
          if ("mozResponseArrayBuffer" in a.g) return a.g.mozResponseArrayBuffer;
      }
      return null;
    } catch (b) {
      return null;
    }
  }
  function Vb(a) {
    const b = {};
    a = (a.g && 2 <= P(a) ? a.g.getAllResponseHeaders() || "" : "").split("\r\n");
    for (let d = 0; d < a.length; d++) {
      if (t(a[d])) continue;
      var c = va(a[d]);
      const e = c[0];
      c = c[1];
      if ("string" !== typeof c) continue;
      c = c.trim();
      const f = b[e] || [];
      b[e] = f;
      f.push(c);
    }
    ra(b, function(d) {
      return d.join(", ");
    });
  }
  h.Ba = function() {
    return this.m;
  };
  h.Ka = function() {
    return "string" === typeof this.l ? this.l : String(this.l);
  };
  function Xc(a, b, c) {
    return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
  }
  function Yc(a) {
    this.Aa = 0;
    this.i = [];
    this.j = new vb();
    this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null;
    this.Ya = this.U = 0;
    this.Va = Xc("failFast", false, a);
    this.F = this.C = this.u = this.s = this.l = null;
    this.X = true;
    this.za = this.T = -1;
    this.Y = this.v = this.B = 0;
    this.Ta = Xc("baseRetryDelayMs", 5e3, a);
    this.cb = Xc("retryDelaySeedMs", 1e4, a);
    this.Wa = Xc("forwardChannelMaxRetries", 2, a);
    this.wa = Xc("forwardChannelRequestTimeoutMs", 2e4, a);
    this.pa = a && a.xmlHttpFactory || void 0;
    this.Xa = a && a.Tb || void 0;
    this.Ca = a && a.useFetchStreams || false;
    this.L = void 0;
    this.J = a && a.supportsCrossDomainXhr || false;
    this.K = "";
    this.h = new ic(a && a.concurrentRequestLimit);
    this.Da = new Hc();
    this.P = a && a.fastHandshake || false;
    this.O = a && a.encodeInitMessageHeaders || false;
    this.P && this.O && (this.O = false);
    this.Ua = a && a.Rb || false;
    a && a.xa && this.j.xa();
    a && a.forceLongPolling && (this.X = false);
    this.ba = !this.P && this.X && a && a.detectBufferingProxy || false;
    this.ja = void 0;
    a && a.longPollingTimeout && 0 < a.longPollingTimeout && (this.ja = a.longPollingTimeout);
    this.ca = void 0;
    this.R = 0;
    this.M = false;
    this.ka = this.A = null;
  }
  h = Yc.prototype;
  h.la = 8;
  h.G = 1;
  h.connect = function(a, b, c, d) {
    K(0);
    this.W = a;
    this.H = b || {};
    c && void 0 !== d && (this.H.OSID = c, this.H.OAID = d);
    this.F = this.X;
    this.I = cc(this, null, this.W);
    fc(this);
  };
  function gc(a) {
    Zc(a);
    if (3 == a.G) {
      var b = a.U++, c = N2(a.I);
      S(c, "SID", a.K);
      S(c, "RID", b);
      S(c, "TYPE", "terminate");
      $c(a, c);
      b = new M2(a, a.j, b);
      b.L = 2;
      b.v = Ib(N2(c));
      c = false;
      if (k2.navigator && k2.navigator.sendBeacon) try {
        c = k2.navigator.sendBeacon(b.v.toString(), "");
      } catch (d) {
      }
      !c && k2.Image && (new Image().src = b.v, c = true);
      c || (b.g = Mb(b.j, null), b.g.ea(b.v));
      b.F = Date.now();
      Kb(b);
    }
    ad(a);
  }
  function Zb(a) {
    a.g && (Tb(a), a.g.cancel(), a.g = null);
  }
  function Zc(a) {
    Zb(a);
    a.u && (k2.clearTimeout(a.u), a.u = null);
    Yb(a);
    a.h.cancel();
    a.s && ("number" === typeof a.s && k2.clearTimeout(a.s), a.s = null);
  }
  function fc(a) {
    if (!jc(a.h) && !a.s) {
      a.s = true;
      var b = a.Ga;
      x2 || Ea();
      y || (x2(), y = true);
      za.add(b, a);
      a.B = 0;
    }
  }
  function bd(a, b) {
    if (ac(a.h) >= a.h.j - (a.s ? 1 : 0)) return false;
    if (a.s) return a.i = b.D.concat(a.i), true;
    if (1 == a.G || 2 == a.G || a.B >= (a.Va ? 0 : a.Wa)) return false;
    a.s = ub(p(a.Ga, a, b), cd(a, a.B));
    a.B++;
    return true;
  }
  h.Ga = function(a) {
    if (this.s) if (this.s = null, 1 == this.G) {
      if (!a) {
        this.U = Math.floor(1e5 * Math.random());
        a = this.U++;
        const e = new M2(this, this.j, a);
        let f = this.o;
        this.S && (f ? (f = sa(f), ua(f, this.S)) : f = this.S);
        null !== this.m || this.O || (e.H = f, f = null);
        if (this.P) a: {
          var b = 0;
          for (var c = 0; c < this.i.length; c++) {
            b: {
              var d = this.i[c];
              if ("__data__" in d.map && (d = d.map.__data__, "string" === typeof d)) {
                d = d.length;
                break b;
              }
              d = void 0;
            }
            if (void 0 === d) break;
            b += d;
            if (4096 < b) {
              b = c;
              break a;
            }
            if (4096 === b || c === this.i.length - 1) {
              b = c + 1;
              break a;
            }
          }
          b = 1e3;
        }
        else b = 1e3;
        b = dd(this, e, b);
        c = N2(this.I);
        S(c, "RID", a);
        S(c, "CVER", 22);
        this.D && S(c, "X-HTTP-Session-Id", this.D);
        $c(this, c);
        f && (this.O ? b = "headers=" + encodeURIComponent(String(Oc(f))) + "&" + b : this.m && Pc(c, this.m, f));
        bc(this.h, e);
        this.Ua && S(c, "TYPE", "init");
        this.P ? (S(c, "$req", b), S(c, "SID", "null"), e.T = true, Hb(e, c, null)) : Hb(e, c, b);
        this.G = 2;
      }
    } else 3 == this.G && (a ? ed(this, a) : 0 == this.i.length || jc(this.h) || ed(this));
  };
  function ed(a, b) {
    var c;
    b ? c = b.l : c = a.U++;
    const d = N2(a.I);
    S(d, "SID", a.K);
    S(d, "RID", c);
    S(d, "AID", a.T);
    $c(a, d);
    a.m && a.o && Pc(d, a.m, a.o);
    c = new M2(a, a.j, c, a.B + 1);
    null === a.m && (c.H = a.o);
    b && (a.i = b.D.concat(a.i));
    b = dd(a, c, 1e3);
    c.I = Math.round(0.5 * a.wa) + Math.round(0.5 * a.wa * Math.random());
    bc(a.h, c);
    Hb(c, d, b);
  }
  function $c(a, b) {
    a.H && qa(a.H, function(c, d) {
      S(b, d, c);
    });
    a.l && nc({}, function(c, d) {
      S(b, d, c);
    });
  }
  function dd(a, b, c) {
    c = Math.min(a.i.length, c);
    var d = a.l ? p(a.l.Na, a.l, a) : null;
    a: {
      var e = a.i;
      let f = -1;
      for (; ; ) {
        const g = ["count=" + c];
        -1 == f ? 0 < c ? (f = e[0].g, g.push("ofs=" + f)) : f = 0 : g.push("ofs=" + f);
        let m = true;
        for (let q2 = 0; q2 < c; q2++) {
          let l = e[q2].g;
          const v = e[q2].map;
          l -= f;
          if (0 > l) f = Math.max(0, e[q2].g - 100), m = false;
          else try {
            Ic(v, g, "req" + l + "_");
          } catch (w) {
            d && d(v);
          }
        }
        if (m) {
          d = g.join("&");
          break a;
        }
      }
    }
    a = a.i.splice(0, c);
    b.D = a;
    return d;
  }
  function ec(a) {
    if (!a.g && !a.u) {
      a.Y = 1;
      var b = a.Fa;
      x2 || Ea();
      y || (x2(), y = true);
      za.add(b, a);
      a.v = 0;
    }
  }
  function $b(a) {
    if (a.g || a.u || 3 <= a.v) return false;
    a.Y++;
    a.u = ub(p(a.Fa, a), cd(a, a.v));
    a.v++;
    return true;
  }
  h.Fa = function() {
    this.u = null;
    fd(this);
    if (this.ba && !(this.M || null == this.g || 0 >= this.R)) {
      var a = 2 * this.R;
      this.j.info("BP detection timer enabled: " + a);
      this.A = ub(p(this.ab, this), a);
    }
  };
  h.ab = function() {
    this.A && (this.A = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.F = false, this.M = true, K(10), Zb(this), fd(this));
  };
  function Tb(a) {
    null != a.A && (k2.clearTimeout(a.A), a.A = null);
  }
  function fd(a) {
    a.g = new M2(a, a.j, "rpc", a.Y);
    null === a.m && (a.g.H = a.o);
    a.g.O = 0;
    var b = N2(a.qa);
    S(b, "RID", "rpc");
    S(b, "SID", a.K);
    S(b, "AID", a.T);
    S(b, "CI", a.F ? "0" : "1");
    !a.F && a.ja && S(b, "TO", a.ja);
    S(b, "TYPE", "xmlhttp");
    $c(a, b);
    a.m && a.o && Pc(b, a.m, a.o);
    a.L && (a.g.I = a.L);
    var c = a.g;
    a = a.ia;
    c.L = 1;
    c.v = Ib(N2(b));
    c.m = null;
    c.P = true;
    Jb(c, a);
  }
  h.Za = function() {
    null != this.C && (this.C = null, Zb(this), $b(this), K(19));
  };
  function Yb(a) {
    null != a.C && (k2.clearTimeout(a.C), a.C = null);
  }
  function Ub(a, b) {
    var c = null;
    if (a.g == b) {
      Yb(a);
      Tb(a);
      a.g = null;
      var d = 2;
    } else if (Xb(a.h, b)) c = b.D, dc(a.h, b), d = 1;
    else return;
    if (0 != a.G) {
      if (b.o) if (1 == d) {
        c = b.m ? b.m.length : 0;
        b = Date.now() - b.F;
        var e = a.B;
        d = qb();
        F2(d, new tb(d, c));
        fc(a);
      } else ec(a);
      else if (e = b.s, 3 == e || 0 == e && 0 < b.X || !(1 == d && bd(a, b) || 2 == d && $b(a))) switch (c && 0 < c.length && (b = a.h, b.i = b.i.concat(c)), e) {
        case 1:
          R(a, 5);
          break;
        case 4:
          R(a, 10);
          break;
        case 3:
          R(a, 6);
          break;
        default:
          R(a, 2);
      }
    }
  }
  function cd(a, b) {
    let c = a.Ta + Math.floor(Math.random() * a.cb);
    a.isActive() || (c *= 2);
    return c * b;
  }
  function R(a, b) {
    a.j.info("Error code " + b);
    if (2 == b) {
      var c = p(a.fb, a), d = a.Xa;
      const e = !d;
      d = new T(d || "//www.google.com/images/cleardot.gif");
      k2.location && "http" == k2.location.protocol || qc(d, "https");
      Ib(d);
      e ? Fc(d.toString(), c) : Gc(d.toString(), c);
    } else K(2);
    a.G = 0;
    a.l && a.l.sa(b);
    ad(a);
    Zc(a);
  }
  h.fb = function(a) {
    a ? (this.j.info("Successfully pinged google.com"), K(2)) : (this.j.info("Failed to ping google.com"), K(1));
  };
  function ad(a) {
    a.G = 0;
    a.ka = [];
    if (a.l) {
      const b = kc(a.h);
      if (0 != b.length || 0 != a.i.length) ma(a.ka, b), ma(a.ka, a.i), a.h.i.length = 0, la(a.i), a.i.length = 0;
      a.l.ra();
    }
  }
  function cc(a, b, c) {
    var d = c instanceof T ? N2(c) : new T(c);
    if ("" != d.g) b && (d.g = b + "." + d.g), rc(d, d.s);
    else {
      var e = k2.location;
      d = e.protocol;
      b = b ? b + "." + e.hostname : e.hostname;
      e = +e.port;
      var f = new T(null);
      d && qc(f, d);
      b && (f.g = b);
      e && rc(f, e);
      c && (f.l = c);
      d = f;
    }
    c = a.D;
    b = a.ya;
    c && b && S(d, c, b);
    S(d, "VER", a.la);
    $c(a, d);
    return d;
  }
  function Mb(a, b, c) {
    if (b && !a.J) throw Error("Can't create secondary domain capable XhrIo object.");
    b = a.Ca && !a.pa ? new X(new Jc({ eb: c })) : new X(a.pa);
    b.Ha(a.J);
    return b;
  }
  h.isActive = function() {
    return !!this.l && this.l.isActive(this);
  };
  function gd() {
  }
  h = gd.prototype;
  h.ua = function() {
  };
  h.ta = function() {
  };
  h.sa = function() {
  };
  h.ra = function() {
  };
  h.isActive = function() {
    return true;
  };
  h.Na = function() {
  };
  function hd() {
  }
  hd.prototype.g = function(a, b) {
    return new Y(a, b);
  };
  function Y(a, b) {
    E.call(this);
    this.g = new Yc(b);
    this.l = a;
    this.h = b && b.messageUrlParams || null;
    a = b && b.messageHeaders || null;
    b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
    this.g.o = a;
    a = b && b.initMessageHeaders || null;
    b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
    b && b.va && (a ? a["X-WebChannel-Client-Profile"] = b.va : a = { "X-WebChannel-Client-Profile": b.va });
    this.g.S = a;
    (a = b && b.Sb) && !t(a) && (this.g.m = a);
    this.v = b && b.supportsCrossDomainXhr || false;
    this.u = b && b.sendRawJson || false;
    (b = b && b.httpSessionIdParam) && !t(b) && (this.g.D = b, a = this.h, null !== a && b in a && (a = this.h, b in a && delete a[b]));
    this.j = new Z(this);
  }
  r(Y, E);
  Y.prototype.m = function() {
    this.g.l = this.j;
    this.v && (this.g.J = true);
    this.g.connect(this.l, this.h || void 0);
  };
  Y.prototype.close = function() {
    gc(this.g);
  };
  Y.prototype.o = function(a) {
    var b = this.g;
    if ("string" === typeof a) {
      var c = {};
      c.__data__ = a;
      a = c;
    } else this.u && (c = {}, c.__data__ = hb(a), a = c);
    b.i.push(new hc(b.Ya++, a));
    3 == b.G && fc(b);
  };
  Y.prototype.N = function() {
    this.g.l = null;
    delete this.j;
    gc(this.g);
    delete this.g;
    Y.aa.N.call(this);
  };
  function id(a) {
    nb.call(this);
    a.__headers__ && (this.headers = a.__headers__, this.statusCode = a.__status__, delete a.__headers__, delete a.__status__);
    var b = a.__sm__;
    if (b) {
      a: {
        for (const c in b) {
          a = c;
          break a;
        }
        a = void 0;
      }
      if (this.i = a) a = this.i, b = null !== b && a in b ? b[a] : void 0;
      this.data = b;
    } else this.data = a;
  }
  r(id, nb);
  function jd() {
    ob.call(this);
    this.status = 1;
  }
  r(jd, ob);
  function Z(a) {
    this.g = a;
  }
  r(Z, gd);
  Z.prototype.ua = function() {
    F2(this.g, "a");
  };
  Z.prototype.ta = function(a) {
    F2(this.g, new id(a));
  };
  Z.prototype.sa = function(a) {
    F2(this.g, new jd());
  };
  Z.prototype.ra = function() {
    F2(this.g, "b");
  };
  hd.prototype.createWebChannel = hd.prototype.g;
  Y.prototype.send = Y.prototype.o;
  Y.prototype.open = Y.prototype.m;
  Y.prototype.close = Y.prototype.close;
  createWebChannelTransport = function() {
    return new hd();
  };
  getStatEventTarget = function() {
    return qb();
  };
  Event$1 = I;
  Stat = { mb: 0, pb: 1, qb: 2, Jb: 3, Ob: 4, Lb: 5, Mb: 6, Kb: 7, Ib: 8, Nb: 9, PROXY: 10, NOPROXY: 11, Gb: 12, Cb: 13, Db: 14, Bb: 15, Eb: 16, Fb: 17, ib: 18, hb: 19, jb: 20 };
  Ab.NO_ERROR = 0;
  Ab.TIMEOUT = 8;
  Ab.HTTP_ERROR = 6;
  ErrorCode = Ab;
  Bb.COMPLETE = "complete";
  EventType = Bb;
  mb.EventType = H;
  H.OPEN = "a";
  H.CLOSE = "b";
  H.ERROR = "c";
  H.MESSAGE = "d";
  E.prototype.listen = E.prototype.K;
  WebChannel = mb;
  X.prototype.listenOnce = X.prototype.L;
  X.prototype.getLastError = X.prototype.Ka;
  X.prototype.getLastErrorCode = X.prototype.Ba;
  X.prototype.getStatus = X.prototype.Z;
  X.prototype.getResponseJson = X.prototype.Oa;
  X.prototype.getResponseText = X.prototype.oa;
  X.prototype.send = X.prototype.ea;
  X.prototype.setWithCredentials = X.prototype.Ha;
  XhrIo = X;
}).apply(typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
const F = "@firebase/firestore", M = "4.8.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class User {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return null != this.uid;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
User.UNAUTHENTICATED = new User(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
User.GOOGLE_CREDENTIALS = new User("google-credentials-uid"), User.FIRST_PARTY = new User("first-party-uid"), User.MOCK_USER = new User("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let x = "11.10.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const O = new Logger2("@firebase/firestore");
function __PRIVATE_getLogLevel() {
  return O.logLevel;
}
function __PRIVATE_logDebug(e, ...t) {
  if (O.logLevel <= LogLevel.DEBUG) {
    const n = t.map(__PRIVATE_argToString);
    O.debug(`Firestore (${x}): ${e}`, ...n);
  }
}
function __PRIVATE_logError(e, ...t) {
  if (O.logLevel <= LogLevel.ERROR) {
    const n = t.map(__PRIVATE_argToString);
    O.error(`Firestore (${x}): ${e}`, ...n);
  }
}
function __PRIVATE_logWarn(e, ...t) {
  if (O.logLevel <= LogLevel.WARN) {
    const n = t.map(__PRIVATE_argToString);
    O.warn(`Firestore (${x}): ${e}`, ...n);
  }
}
function __PRIVATE_argToString(e) {
  if ("string" == typeof e) return e;
  try {
    /**
    * @license
    * Copyright 2020 Google LLC
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    return function __PRIVATE_formatJSON(e2) {
      return JSON.stringify(e2);
    }(e);
  } catch (t) {
    return e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fail(e, t, n) {
  let r = "Unexpected state";
  "string" == typeof t ? r = t : n = t, __PRIVATE__fail(e, r, n);
}
function __PRIVATE__fail(e, t, n) {
  let r = `FIRESTORE (${x}) INTERNAL ASSERTION FAILED: ${t} (ID: ${e.toString(16)})`;
  if (void 0 !== n) try {
    r += " CONTEXT: " + JSON.stringify(n);
  } catch (e2) {
    r += " CONTEXT: " + n;
  }
  throw __PRIVATE_logError(r), new Error(r);
}
function __PRIVATE_hardAssert(e, t, n, r) {
  let i = "Unexpected state";
  "string" == typeof n ? i = n : r = n, e || __PRIVATE__fail(t, i, r);
}
function __PRIVATE_debugCast(e, t) {
  return e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const N = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: "ok",
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: "cancelled",
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: "unknown",
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: "invalid-argument",
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: "deadline-exceeded",
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: "not-found",
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: "already-exists",
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller cannot be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: "permission-denied",
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: "unauthenticated",
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: "resource-exhausted",
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: "failed-precondition",
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: "aborted",
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: "out-of-range",
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: "unimplemented",
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: "internal",
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: "unavailable",
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: "data-loss"
};
class FirestoreError extends FirebaseError {
  /** @hideconstructor */
  constructor(e, t) {
    super(e, t), this.code = e, this.message = t, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_Deferred {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_OAuthToken {
  constructor(e, t) {
    this.user = t, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${e}`);
  }
}
class __PRIVATE_EmptyAuthCredentialsProvider {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
    e.enqueueRetryable(() => t(User.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class __PRIVATE_EmulatorAuthCredentialsProvider {
  constructor(e) {
    this.token = e, /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(e, t) {
    this.changeListener = t, // Fire with initial user.
    e.enqueueRetryable(() => t(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class __PRIVATE_FirebaseAuthCredentialsProvider {
  constructor(e) {
    this.t = e, /** Tracks the current User. */
    this.currentUser = User.UNAUTHENTICATED, /**
     * Counter used to detect if the token changed while a getToken request was
     * outstanding.
     */
    this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(e, t) {
    __PRIVATE_hardAssert(void 0 === this.o, 42304);
    let n = this.i;
    const __PRIVATE_guardedChangeListener = (e2) => this.i !== n ? (n = this.i, t(e2)) : Promise.resolve();
    let r = new __PRIVATE_Deferred();
    this.o = () => {
      this.i++, this.currentUser = this.u(), r.resolve(), r = new __PRIVATE_Deferred(), e.enqueueRetryable(() => __PRIVATE_guardedChangeListener(this.currentUser));
    };
    const __PRIVATE_awaitNextToken = () => {
      const t2 = r;
      e.enqueueRetryable(async () => {
        await t2.promise, await __PRIVATE_guardedChangeListener(this.currentUser);
      });
    }, __PRIVATE_registerAuth = (e2) => {
      __PRIVATE_logDebug("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = e2, this.o && (this.auth.addAuthTokenListener(this.o), __PRIVATE_awaitNextToken());
    };
    this.t.onInit((e2) => __PRIVATE_registerAuth(e2)), // Our users can initialize Auth right after Firestore, so we give it
    // a chance to register itself with the component framework before we
    // determine whether to start up in unauthenticated mode.
    setTimeout(() => {
      if (!this.auth) {
        const e2 = this.t.getImmediate({
          optional: true
        });
        e2 ? __PRIVATE_registerAuth(e2) : (
          // If auth is still not available, proceed with `null` user
          (__PRIVATE_logDebug("FirebaseAuthCredentialsProvider", "Auth not yet detected"), r.resolve(), r = new __PRIVATE_Deferred())
        );
      }
    }, 0), __PRIVATE_awaitNextToken();
  }
  getToken() {
    const e = this.i, t = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(t).then((t2) => (
      // Cancel the request since the token changed while the request was
      // outstanding so the response is potentially for a previous user (which
      // user, we can't be sure).
      this.i !== e ? (__PRIVATE_logDebug("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : t2 ? (__PRIVATE_hardAssert("string" == typeof t2.accessToken, 31837, {
        l: t2
      }), new __PRIVATE_OAuthToken(t2.accessToken, this.currentUser)) : null
    )) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.o && this.auth.removeAuthTokenListener(this.o), this.o = void 0;
  }
  // Auth.getUid() can return null even with a user logged in. It is because
  // getUid() is synchronous, but the auth code populating Uid is asynchronous.
  // This method should only be called in the AuthTokenListener callback
  // to guarantee to get the actual user.
  u() {
    const e = this.auth && this.auth.getUid();
    return __PRIVATE_hardAssert(null === e || "string" == typeof e, 2055, {
      h: e
    }), new User(e);
  }
}
class __PRIVATE_FirstPartyToken {
  constructor(e, t, n) {
    this.P = e, this.T = t, this.I = n, this.type = "FirstParty", this.user = User.FIRST_PARTY, this.A = /* @__PURE__ */ new Map();
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  R() {
    return this.I ? this.I() : null;
  }
  get headers() {
    this.A.set("X-Goog-AuthUser", this.P);
    const e = this.R();
    return e && this.A.set("Authorization", e), this.T && this.A.set("X-Goog-Iam-Authorization-Token", this.T), this.A;
  }
}
class __PRIVATE_FirstPartyAuthCredentialsProvider {
  constructor(e, t, n) {
    this.P = e, this.T = t, this.I = n;
  }
  getToken() {
    return Promise.resolve(new __PRIVATE_FirstPartyToken(this.P, this.T, this.I));
  }
  start(e, t) {
    e.enqueueRetryable(() => t(User.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class AppCheckToken {
  constructor(e) {
    this.value = e, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class __PRIVATE_FirebaseAppCheckTokenProvider {
  constructor(t, n) {
    this.V = n, this.forceRefresh = false, this.appCheck = null, this.m = null, this.p = null, _isFirebaseServerApp(t) && t.settings.appCheckToken && (this.p = t.settings.appCheckToken);
  }
  start(e, t) {
    __PRIVATE_hardAssert(void 0 === this.o, 3512);
    const onTokenChanged = (e2) => {
      null != e2.error && __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${e2.error.message}`);
      const n = e2.token !== this.m;
      return this.m = e2.token, __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", `Received ${n ? "new" : "existing"} token.`), n ? t(e2.token) : Promise.resolve();
    };
    this.o = (t2) => {
      e.enqueueRetryable(() => onTokenChanged(t2));
    };
    const __PRIVATE_registerAppCheck = (e2) => {
      __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = e2, this.o && this.appCheck.addTokenListener(this.o);
    };
    this.V.onInit((e2) => __PRIVATE_registerAppCheck(e2)), // Our users can initialize AppCheck after Firestore, so we give it
    // a chance to register itself with the component framework.
    setTimeout(() => {
      if (!this.appCheck) {
        const e2 = this.V.getImmediate({
          optional: true
        });
        e2 ? __PRIVATE_registerAppCheck(e2) : (
          // If AppCheck is still not available, proceed without it.
          __PRIVATE_logDebug("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
        );
      }
    }, 0);
  }
  getToken() {
    if (this.p) return Promise.resolve(new AppCheckToken(this.p));
    const e = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(e).then((e2) => e2 ? (__PRIVATE_hardAssert("string" == typeof e2.token, 44558, {
      tokenResult: e2
    }), this.m = e2.token, new AppCheckToken(e2.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.o && this.appCheck.removeTokenListener(this.o), this.o = void 0;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_randomBytes(e) {
  const t = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "undefined" != typeof self && (self.crypto || self.msCrypto)
  ), n = new Uint8Array(e);
  if (t && "function" == typeof t.getRandomValues) t.getRandomValues(n);
  else
    for (let t2 = 0; t2 < e; t2++) n[t2] = Math.floor(256 * Math.random());
  return n;
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_newTextEncoder() {
  return new TextEncoder();
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_AutoId {
  static newId() {
    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = 62 * Math.floor(256 / 62);
    let n = "";
    for (; n.length < 20; ) {
      const r = __PRIVATE_randomBytes(40);
      for (let i = 0; i < r.length; ++i)
        n.length < 20 && r[i] < t && (n += e.charAt(r[i] % 62));
    }
    return n;
  }
}
function __PRIVATE_primitiveComparator(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function __PRIVATE_compareUtf8Strings(e, t) {
  let n = 0;
  for (; n < e.length && n < t.length; ) {
    const r = e.codePointAt(n), i = t.codePointAt(n);
    if (r !== i) {
      if (r < 128 && i < 128)
        return __PRIVATE_primitiveComparator(r, i);
      {
        const s = __PRIVATE_newTextEncoder(), o = __PRIVATE_compareByteArrays$1(s.encode(__PRIVATE_getUtf8SafeSubstring(e, n)), s.encode(__PRIVATE_getUtf8SafeSubstring(t, n)));
        return 0 !== o ? o : __PRIVATE_primitiveComparator(r, i);
      }
    }
    n += r > 65535 ? 2 : 1;
  }
  return __PRIVATE_primitiveComparator(e.length, t.length);
}
function __PRIVATE_getUtf8SafeSubstring(e, t) {
  return e.codePointAt(t) > 65535 ? e.substring(t, t + 2) : e.substring(t, t + 1);
}
function __PRIVATE_compareByteArrays$1(e, t) {
  for (let n = 0; n < e.length && n < t.length; ++n) if (e[n] !== t[n]) return __PRIVATE_primitiveComparator(e[n], t[n]);
  return __PRIVATE_primitiveComparator(e.length, t.length);
}
function __PRIVATE_arrayEquals(e, t, n) {
  return e.length === t.length && e.every((e2, r) => n(e2, t[r]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const B = "__name__";
class BasePath {
  constructor(e, t, n) {
    void 0 === t ? t = 0 : t > e.length && fail(637, {
      offset: t,
      range: e.length
    }), void 0 === n ? n = e.length - t : n > e.length - t && fail(1746, {
      length: n,
      range: e.length - t
    }), this.segments = e, this.offset = t, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(e) {
    return 0 === BasePath.comparator(this, e);
  }
  child(e) {
    const t = this.segments.slice(this.offset, this.limit());
    return e instanceof BasePath ? e.forEach((e2) => {
      t.push(e2);
    }) : t.push(e), this.construct(t);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(e) {
    return e = void 0 === e ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(e) {
    return this.segments[this.offset + e];
  }
  isEmpty() {
    return 0 === this.length;
  }
  isPrefixOf(e) {
    if (e.length < this.length) return false;
    for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return false;
    return true;
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length) return false;
    for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return false;
    return true;
  }
  forEach(e) {
    for (let t = this.offset, n = this.limit(); t < n; t++) e(this.segments[t]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  /**
   * Compare 2 paths segment by segment, prioritizing numeric IDs
   * (e.g., "__id123__") in numeric ascending order, followed by string
   * segments in lexicographical order.
   */
  static comparator(e, t) {
    const n = Math.min(e.length, t.length);
    for (let r = 0; r < n; r++) {
      const n2 = BasePath.compareSegments(e.get(r), t.get(r));
      if (0 !== n2) return n2;
    }
    return __PRIVATE_primitiveComparator(e.length, t.length);
  }
  static compareSegments(e, t) {
    const n = BasePath.isNumericId(e), r = BasePath.isNumericId(t);
    return n && !r ? -1 : !n && r ? 1 : n && r ? BasePath.extractNumericId(e).compare(BasePath.extractNumericId(t)) : __PRIVATE_compareUtf8Strings(e, t);
  }
  // Checks if a segment is a numeric ID (starts with "__id" and ends with "__").
  static isNumericId(e) {
    return e.startsWith("__id") && e.endsWith("__");
  }
  static extractNumericId(e) {
    return Integer.fromString(e.substring(4, e.length - 2));
  }
}
class ResourcePath extends BasePath {
  construct(e, t, n) {
    return new ResourcePath(e, t, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns a string representation of this path
   * where each path segment has been encoded with
   * `encodeURIComponent`.
   */
  toUriEncodedString() {
    return this.toArray().map(encodeURIComponent).join("/");
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...e) {
    const t = [];
    for (const n of e) {
      if (n.indexOf("//") >= 0) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      t.push(...n.split("/").filter((e2) => e2.length > 0));
    }
    return new ResourcePath(t);
  }
  static emptyPath() {
    return new ResourcePath([]);
  }
}
const L = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class FieldPath$1 extends BasePath {
  construct(e, t, n) {
    return new FieldPath$1(e, t, n);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(e) {
    return L.test(e);
  }
  canonicalString() {
    return this.toArray().map((e) => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), FieldPath$1.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return 1 === this.length && this.get(0) === B;
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new FieldPath$1([B]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(e) {
    const t = [];
    let n = "", r = 0;
    const __PRIVATE_addCurrentSegment = () => {
      if (0 === n.length) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      t.push(n), n = "";
    };
    let i = false;
    for (; r < e.length; ) {
      const t2 = e[r];
      if ("\\" === t2) {
        if (r + 1 === e.length) throw new FirestoreError(N.INVALID_ARGUMENT, "Path has trailing escape character: " + e);
        const t3 = e[r + 1];
        if ("\\" !== t3 && "." !== t3 && "`" !== t3) throw new FirestoreError(N.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e);
        n += t3, r += 2;
      } else "`" === t2 ? (i = !i, r++) : "." !== t2 || i ? (n += t2, r++) : (__PRIVATE_addCurrentSegment(), r++);
    }
    if (__PRIVATE_addCurrentSegment(), i) throw new FirestoreError(N.INVALID_ARGUMENT, "Unterminated ` in path: " + e);
    return new FieldPath$1(t);
  }
  static emptyPath() {
    return new FieldPath$1([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentKey {
  constructor(e) {
    this.path = e;
  }
  static fromPath(e) {
    return new DocumentKey(ResourcePath.fromString(e));
  }
  static fromName(e) {
    return new DocumentKey(ResourcePath.fromString(e).popFirst(5));
  }
  static empty() {
    return new DocumentKey(ResourcePath.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(e) {
    return null !== e && 0 === ResourcePath.comparator(this.path, e.path);
  }
  toString() {
    return this.path.toString();
  }
  static comparator(e, t) {
    return ResourcePath.comparator(e.path, t.path);
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(e) {
    return new DocumentKey(new ResourcePath(e.slice()));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_validateNonEmptyArgument(e, t, n) {
  if (!n) throw new FirestoreError(N.INVALID_ARGUMENT, `Function ${e}() cannot be called with an empty ${t}.`);
}
function __PRIVATE_validateIsNotUsedTogether(e, t, n, r) {
  if (true === t && true === r) throw new FirestoreError(N.INVALID_ARGUMENT, `${e} and ${n} cannot be used together.`);
}
function __PRIVATE_validateDocumentPath(e) {
  if (!DocumentKey.isDocumentKey(e)) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`);
}
function __PRIVATE_validateCollectionPath(e) {
  if (DocumentKey.isDocumentKey(e)) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`);
}
function __PRIVATE_isPlainObject(e) {
  return "object" == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e));
}
function __PRIVATE_valueDescription(e) {
  if (void 0 === e) return "undefined";
  if (null === e) return "null";
  if ("string" == typeof e) return e.length > 20 && (e = `${e.substring(0, 20)}...`), JSON.stringify(e);
  if ("number" == typeof e || "boolean" == typeof e) return "" + e;
  if ("object" == typeof e) {
    if (e instanceof Array) return "an array";
    {
      const t = (
        /** try to get the constructor name for an object. */
        function __PRIVATE_tryGetCustomObjectType(e2) {
          if (e2.constructor) return e2.constructor.name;
          return null;
        }(e)
      );
      return t ? `a custom ${t} object` : "an object";
    }
  }
  return "function" == typeof e ? "a function" : fail(12329, {
    type: typeof e
  });
}
function __PRIVATE_cast(e, t) {
  if ("_delegate" in e && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (e = e._delegate), !(e instanceof t)) {
    if (t.name === e.constructor.name) throw new FirestoreError(N.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = __PRIVATE_valueDescription(e);
      throw new FirestoreError(N.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${n}`);
    }
  }
  return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function property(e, t) {
  const n = {
    typeString: e
  };
  return t && (n.value = t), n;
}
function __PRIVATE_validateJSON(e, t) {
  if (!__PRIVATE_isPlainObject(e)) throw new FirestoreError(N.INVALID_ARGUMENT, "JSON must be an object");
  let n;
  for (const r in t) if (t[r]) {
    const i = t[r].typeString, s = "value" in t[r] ? {
      value: t[r].value
    } : void 0;
    if (!(r in e)) {
      n = `JSON missing required field: '${r}'`;
      break;
    }
    const o = e[r];
    if (i && typeof o !== i) {
      n = `JSON field '${r}' must be a ${i}.`;
      break;
    }
    if (void 0 !== s && o !== s.value) {
      n = `Expected '${r}' field to equal '${s.value}'`;
      break;
    }
  }
  if (n) throw new FirestoreError(N.INVALID_ARGUMENT, n);
  return true;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const k = -62135596800, q = 1e6;
class Timestamp {
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return Timestamp.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(e) {
    return Timestamp.fromMillis(e.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(e) {
    const t = Math.floor(e / 1e3), n = Math.floor((e - 1e3 * t) * q);
    return new Timestamp(t, n);
  }
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(e, t) {
    if (this.seconds = e, this.nanoseconds = t, t < 0) throw new FirestoreError(N.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t);
    if (t >= 1e9) throw new FirestoreError(N.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t);
    if (e < k) throw new FirestoreError(N.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
    if (e >= 253402300800) throw new FirestoreError(N.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / q;
  }
  _compareTo(e) {
    return this.seconds === e.seconds ? __PRIVATE_primitiveComparator(this.nanoseconds, e.nanoseconds) : __PRIVATE_primitiveComparator(this.seconds, e.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /**
   * Returns a JSON-serializable representation of this `Timestamp`.
   */
  toJSON() {
    return {
      type: Timestamp._jsonSchemaVersion,
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  /**
   * Builds a `Timestamp` instance from a JSON object created by {@link Timestamp.toJSON}.
   */
  static fromJSON(e) {
    if (__PRIVATE_validateJSON(e, Timestamp._jsonSchema)) return new Timestamp(e.seconds, e.nanoseconds);
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const e = this.seconds - k;
    return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
Timestamp._jsonSchemaVersion = "firestore/timestamp/1.0", Timestamp._jsonSchema = {
  type: property("string", Timestamp._jsonSchemaVersion),
  seconds: property("number"),
  nanoseconds: property("number")
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SnapshotVersion {
  static fromTimestamp(e) {
    return new SnapshotVersion(e);
  }
  static min() {
    return new SnapshotVersion(new Timestamp(0, 0));
  }
  static max() {
    return new SnapshotVersion(new Timestamp(253402300799, 999999999));
  }
  constructor(e) {
    this.timestamp = e;
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp);
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Q = -1;
function __PRIVATE_newIndexOffsetSuccessorFromReadTime(e, t) {
  const n = e.toTimestamp().seconds, r = e.toTimestamp().nanoseconds + 1, i = SnapshotVersion.fromTimestamp(1e9 === r ? new Timestamp(n + 1, 0) : new Timestamp(n, r));
  return new IndexOffset(i, DocumentKey.empty(), t);
}
function __PRIVATE_newIndexOffsetFromDocument(e) {
  return new IndexOffset(e.readTime, e.key, Q);
}
class IndexOffset {
  constructor(e, t, n) {
    this.readTime = e, this.documentKey = t, this.largestBatchId = n;
  }
  /** Returns an offset that sorts before all regular offsets. */
  static min() {
    return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), Q);
  }
  /** Returns an offset that sorts after all regular offsets. */
  static max() {
    return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), Q);
  }
}
function __PRIVATE_indexOffsetComparator(e, t) {
  let n = e.readTime.compareTo(t.readTime);
  return 0 !== n ? n : (n = DocumentKey.comparator(e.documentKey, t.documentKey), 0 !== n ? n : __PRIVATE_primitiveComparator(e.largestBatchId, t.largestBatchId));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $ = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class PersistenceTransaction {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(e) {
    this.onCommittedListeners.push(e);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((e) => e());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function __PRIVATE_ignoreIfPrimaryLeaseLoss(e) {
  if (e.code !== N.FAILED_PRECONDITION || e.message !== $) throw e;
  __PRIVATE_logDebug("LocalStore", "Unexpectedly lost primary lease");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PersistencePromise {
  constructor(e) {
    this.nextCallback = null, this.catchCallback = null, // When the operation resolves, we'll set result or error and mark isDone.
    this.result = void 0, this.error = void 0, this.isDone = false, // Set to true when .then() or .catch() are called and prevents additional
    // chaining.
    this.callbackAttached = false, e((e2) => {
      this.isDone = true, this.result = e2, this.nextCallback && // value should be defined unless T is Void, but we can't express
      // that in the type system.
      this.nextCallback(e2);
    }, (e2) => {
      this.isDone = true, this.error = e2, this.catchCallback && this.catchCallback(e2);
    });
  }
  catch(e) {
    return this.next(void 0, e);
  }
  next(e, t) {
    return this.callbackAttached && fail(59440), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new PersistencePromise((n, r) => {
      this.nextCallback = (t2) => {
        this.wrapSuccess(e, t2).next(n, r);
      }, this.catchCallback = (e2) => {
        this.wrapFailure(t, e2).next(n, r);
      };
    });
  }
  toPromise() {
    return new Promise((e, t) => {
      this.next(e, t);
    });
  }
  wrapUserFunction(e) {
    try {
      const t = e();
      return t instanceof PersistencePromise ? t : PersistencePromise.resolve(t);
    } catch (e2) {
      return PersistencePromise.reject(e2);
    }
  }
  wrapSuccess(e, t) {
    return e ? this.wrapUserFunction(() => e(t)) : PersistencePromise.resolve(t);
  }
  wrapFailure(e, t) {
    return e ? this.wrapUserFunction(() => e(t)) : PersistencePromise.reject(t);
  }
  static resolve(e) {
    return new PersistencePromise((t, n) => {
      t(e);
    });
  }
  static reject(e) {
    return new PersistencePromise((t, n) => {
      n(e);
    });
  }
  static waitFor(e) {
    return new PersistencePromise((t, n) => {
      let r = 0, i = 0, s = false;
      e.forEach((e2) => {
        ++r, e2.next(() => {
          ++i, s && i === r && t();
        }, (e3) => n(e3));
      }), s = true, i === r && t();
    });
  }
  /**
   * Given an array of predicate functions that asynchronously evaluate to a
   * boolean, implements a short-circuiting `or` between the results. Predicates
   * will be evaluated until one of them returns `true`, then stop. The final
   * result will be whether any of them returned `true`.
   */
  static or(e) {
    let t = PersistencePromise.resolve(false);
    for (const n of e) t = t.next((e2) => e2 ? PersistencePromise.resolve(e2) : n());
    return t;
  }
  static forEach(e, t) {
    const n = [];
    return e.forEach((e2, r) => {
      n.push(t.call(this, e2, r));
    }), this.waitFor(n);
  }
  /**
   * Concurrently map all array elements through asynchronous function.
   */
  static mapArray(e, t) {
    return new PersistencePromise((n, r) => {
      const i = e.length, s = new Array(i);
      let o = 0;
      for (let _ = 0; _ < i; _++) {
        const a = _;
        t(e[a]).next((e2) => {
          s[a] = e2, ++o, o === i && n(s);
        }, (e2) => r(e2));
      }
    });
  }
  /**
   * An alternative to recursive PersistencePromise calls, that avoids
   * potential memory problems from unbounded chains of promises.
   *
   * The `action` will be called repeatedly while `condition` is true.
   */
  static doWhile(e, t) {
    return new PersistencePromise((n, r) => {
      const process2 = () => {
        true === e() ? t().next(() => {
          process2();
        }, r) : n();
      };
      process2();
    });
  }
}
function __PRIVATE_getAndroidVersion(e) {
  const t = e.match(/Android ([\d.]+)/i), n = t ? t[1].split(".").slice(0, 2).join(".") : "-1";
  return Number(n);
}
function __PRIVATE_isIndexedDbTransactionError(e) {
  return "IndexedDbTransactionError" === e.name;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_ListenSequence {
  constructor(e, t) {
    this.previousValue = e, t && (t.sequenceNumberHandler = (e2) => this._e(e2), this.ae = (e2) => t.writeSequenceNumber(e2));
  }
  _e(e) {
    return this.previousValue = Math.max(e, this.previousValue), this.previousValue;
  }
  next() {
    const e = ++this.previousValue;
    return this.ae && this.ae(e), e;
  }
}
__PRIVATE_ListenSequence.ue = -1;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const G = -1;
function __PRIVATE_isNullOrUndefined(e) {
  return null == e;
}
function __PRIVATE_isNegativeZero(e) {
  return 0 === e && 1 / e == -1 / 0;
}
function isSafeInteger(e) {
  return "number" == typeof e && Number.isInteger(e) && !__PRIVATE_isNegativeZero(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const z = "";
function __PRIVATE_encodeResourcePath(e) {
  let t = "";
  for (let n = 0; n < e.length; n++) t.length > 0 && (t = __PRIVATE_encodeSeparator(t)), t = __PRIVATE_encodeSegment(e.get(n), t);
  return __PRIVATE_encodeSeparator(t);
}
function __PRIVATE_encodeSegment(e, t) {
  let n = t;
  const r = e.length;
  for (let t2 = 0; t2 < r; t2++) {
    const r2 = e.charAt(t2);
    switch (r2) {
      case "\0":
        n += "";
        break;
      case z:
        n += "";
        break;
      default:
        n += r2;
    }
  }
  return n;
}
function __PRIVATE_encodeSeparator(e) {
  return e + z + "";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_objectSize(e) {
  let t = 0;
  for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++;
  return t;
}
function forEach(e, t) {
  for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n]);
}
function isEmpty(e) {
  for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return false;
  return true;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SortedMap {
  constructor(e, t) {
    this.comparator = e, this.root = t || LLRBNode.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(e, t) {
    return new SortedMap(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(e) {
    return new SortedMap(this.comparator, this.root.remove(e, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(e) {
    let t = this.root;
    for (; !t.isEmpty(); ) {
      const n = this.comparator(e, t.key);
      if (0 === n) return t.value;
      n < 0 ? t = t.left : n > 0 && (t = t.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(e) {
    let t = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const r = this.comparator(e, n.key);
      if (0 === r) return t + n.left.size;
      r < 0 ? n = n.left : (
        // Count all nodes left of the node plus the node itself
        (t += n.left.size + 1, n = n.right)
      );
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.root.inorderTraversal(e);
  }
  forEach(e) {
    this.inorderTraversal((t, n) => (e(t, n), false));
  }
  toString() {
    const e = [];
    return this.inorderTraversal((t, n) => (e.push(`${t}:${n}`), false)), `{${e.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.root.reverseTraversal(e);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new SortedMapIterator(this.root, null, this.comparator, false);
  }
  getIteratorFrom(e) {
    return new SortedMapIterator(this.root, e, this.comparator, false);
  }
  getReverseIterator() {
    return new SortedMapIterator(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(e) {
    return new SortedMapIterator(this.root, e, this.comparator, true);
  }
}
class SortedMapIterator {
  constructor(e, t, n, r) {
    this.isReverse = r, this.nodeStack = [];
    let i = 1;
    for (; !e.isEmpty(); ) if (i = t ? n(e.key, t) : 1, // flip the comparison if we're going in reverse
    t && r && (i *= -1), i < 0)
      e = this.isReverse ? e.left : e.right;
    else {
      if (0 === i) {
        this.nodeStack.push(e);
        break;
      }
      this.nodeStack.push(e), e = this.isReverse ? e.right : e.left;
    }
  }
  getNext() {
    let e = this.nodeStack.pop();
    const t = {
      key: e.key,
      value: e.value
    };
    if (this.isReverse) for (e = e.left; !e.isEmpty(); ) this.nodeStack.push(e), e = e.right;
    else for (e = e.right; !e.isEmpty(); ) this.nodeStack.push(e), e = e.left;
    return t;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (0 === this.nodeStack.length) return null;
    const e = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: e.key,
      value: e.value
    };
  }
}
class LLRBNode {
  constructor(e, t, n, r, i) {
    this.key = e, this.value = t, this.color = null != n ? n : LLRBNode.RED, this.left = null != r ? r : LLRBNode.EMPTY, this.right = null != i ? i : LLRBNode.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(e, t, n, r, i) {
    return new LLRBNode(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(e, t, n) {
    let r = this;
    const i = n(e, r.key);
    return r = i < 0 ? r.copy(null, null, null, r.left.insert(e, t, n), null) : 0 === i ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, n)), r.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty()) return LLRBNode.EMPTY;
    let e = this;
    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(e, t) {
    let n, r = this;
    if (t(e, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(e, t), null);
    else {
      if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === t(e, r.key)) {
        if (r.right.isEmpty()) return LLRBNode.EMPTY;
        n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin());
      }
      r = r.copy(null, null, null, null, r.right.remove(e, t));
    }
    return r.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let e = this;
    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e;
  }
  moveRedLeft() {
    let e = this.colorFlip();
    return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e;
  }
  moveRedRight() {
    let e = this.colorFlip();
    return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e;
  }
  rotateLeft() {
    const e = this.copy(null, null, LLRBNode.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight() {
    const e = this.copy(null, null, LLRBNode.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, t);
  }
  // For testing.
  checkMaxDepth() {
    const e = this.check();
    return Math.pow(2, e) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed()) throw fail(43730, {
      key: this.key,
      value: this.value
    });
    if (this.right.isRed()) throw fail(14113, {
      key: this.key,
      value: this.value
    });
    const e = this.left.check();
    if (e !== this.right.check()) throw fail(27949);
    return e + (this.isRed() ? 0 : 1);
  }
}
LLRBNode.EMPTY = null, LLRBNode.RED = true, LLRBNode.BLACK = false;
LLRBNode.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
class LLRBEmptyNode {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw fail(57766);
  }
  get value() {
    throw fail(16141);
  }
  get color() {
    throw fail(16727);
  }
  get left() {
    throw fail(29726);
  }
  get right() {
    throw fail(36894);
  }
  // Returns a copy of the current node.
  copy(e, t, n, r, i) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(e, t, n) {
    return new LLRBNode(e, t);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(e, t) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(e) {
    return false;
  }
  reverseTraversal(e) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  // For testing.
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SortedSet {
  constructor(e) {
    this.comparator = e, this.data = new SortedMap(this.comparator);
  }
  has(e) {
    return null !== this.data.get(e);
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(e) {
    return this.data.indexOf(e);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(e) {
    this.data.inorderTraversal((t, n) => (e(t), false));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(e, t) {
    const n = this.data.getIteratorFrom(e[0]);
    for (; n.hasNext(); ) {
      const r = n.getNext();
      if (this.comparator(r.key, e[1]) >= 0) return;
      t(r.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(e, t) {
    let n;
    for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext(); ) {
      if (!e(n.getNext().key)) return;
    }
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(e) {
    const t = this.data.getIteratorFrom(e);
    return t.hasNext() ? t.getNext().key : null;
  }
  getIterator() {
    return new SortedSetIterator(this.data.getIterator());
  }
  getIteratorFrom(e) {
    return new SortedSetIterator(this.data.getIteratorFrom(e));
  }
  /** Inserts or updates an element */
  add(e) {
    return this.copy(this.data.remove(e).insert(e, true));
  }
  /** Deletes an element */
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(e) {
    let t = this;
    return t.size < e.size && (t = e, e = this), e.forEach((e2) => {
      t = t.add(e2);
    }), t;
  }
  isEqual(e) {
    if (!(e instanceof SortedSet)) return false;
    if (this.size !== e.size) return false;
    const t = this.data.getIterator(), n = e.data.getIterator();
    for (; t.hasNext(); ) {
      const e2 = t.getNext().key, r = n.getNext().key;
      if (0 !== this.comparator(e2, r)) return false;
    }
    return true;
  }
  toArray() {
    const e = [];
    return this.forEach((t) => {
      e.push(t);
    }), e;
  }
  toString() {
    const e = [];
    return this.forEach((t) => e.push(t)), "SortedSet(" + e.toString() + ")";
  }
  copy(e) {
    const t = new SortedSet(this.comparator);
    return t.data = e, t;
  }
}
class SortedSetIterator {
  constructor(e) {
    this.iter = e;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FieldMask {
  constructor(e) {
    this.fields = e, // TODO(dimond): validation of FieldMask
    // Sort the field mask to support `FieldMask.isEqual()` and assert below.
    e.sort(FieldPath$1.comparator);
  }
  static empty() {
    return new FieldMask([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(e) {
    let t = new SortedSet(FieldPath$1.comparator);
    for (const e2 of this.fields) t = t.add(e2);
    for (const n of e) t = t.add(n);
    return new FieldMask(t.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(e) {
    for (const t of this.fields) if (t.isPrefixOf(e)) return true;
    return false;
  }
  isEqual(e) {
    return __PRIVATE_arrayEquals(this.fields, e.fields, (e2, t) => e2.isEqual(t));
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_Base64DecodeError extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ByteString {
  constructor(e) {
    this.binaryString = e;
  }
  static fromBase64String(e) {
    const t = function __PRIVATE_decodeBase64(e2) {
      try {
        return atob(e2);
      } catch (e3) {
        throw "undefined" != typeof DOMException && e3 instanceof DOMException ? new __PRIVATE_Base64DecodeError("Invalid base64 string: " + e3) : e3;
      }
    }(e);
    return new ByteString(t);
  }
  static fromUint8Array(e) {
    const t = (
      /**
      * Helper function to convert an Uint8array to a binary string.
      */
      function __PRIVATE_binaryStringFromUint8Array(e2) {
        let t2 = "";
        for (let n = 0; n < e2.length; ++n) t2 += String.fromCharCode(e2[n]);
        return t2;
      }(e)
    );
    return new ByteString(t);
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(e++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return function __PRIVATE_encodeBase64(e) {
      return btoa(e);
    }(this.binaryString);
  }
  toUint8Array() {
    return function __PRIVATE_uint8ArrayFromBinaryString(e) {
      const t = new Uint8Array(e.length);
      for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
      return t;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(e) {
    return __PRIVATE_primitiveComparator(this.binaryString, e.binaryString);
  }
  isEqual(e) {
    return this.binaryString === e.binaryString;
  }
}
ByteString.EMPTY_BYTE_STRING = new ByteString("");
const it = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function __PRIVATE_normalizeTimestamp(e) {
  if (__PRIVATE_hardAssert(!!e, 39018), "string" == typeof e) {
    let t = 0;
    const n = it.exec(e);
    if (__PRIVATE_hardAssert(!!n, 46558, {
      timestamp: e
    }), n[1]) {
      let e2 = n[1];
      e2 = (e2 + "000000000").substr(0, 9), t = Number(e2);
    }
    const r = new Date(e);
    return {
      seconds: Math.floor(r.getTime() / 1e3),
      nanos: t
    };
  }
  return {
    seconds: __PRIVATE_normalizeNumber(e.seconds),
    nanos: __PRIVATE_normalizeNumber(e.nanos)
  };
}
function __PRIVATE_normalizeNumber(e) {
  return "number" == typeof e ? e : "string" == typeof e ? Number(e) : 0;
}
function __PRIVATE_normalizeByteString(e) {
  return "string" == typeof e ? ByteString.fromBase64String(e) : ByteString.fromUint8Array(e);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const st = "server_timestamp", ot = "__type__", _t = "__previous_value__", at = "__local_write_time__";
function __PRIVATE_isServerTimestamp(e) {
  var t, n;
  return (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {})[ot]) || void 0 === n ? void 0 : n.stringValue) === st;
}
function __PRIVATE_getPreviousValue(e) {
  const t = e.mapValue.fields[_t];
  return __PRIVATE_isServerTimestamp(t) ? __PRIVATE_getPreviousValue(t) : t;
}
function __PRIVATE_getLocalWriteTime(e) {
  const t = __PRIVATE_normalizeTimestamp(e.mapValue.fields[at].timestampValue);
  return new Timestamp(t.seconds, t.nanos);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DatabaseInfo {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param longPollingOptions Options that configure long-polling.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(e, t, n, r, i, s, o, _, a, u) {
    this.databaseId = e, this.appId = t, this.persistenceKey = n, this.host = r, this.ssl = i, this.forceLongPolling = s, this.autoDetectLongPolling = o, this.longPollingOptions = _, this.useFetchStreams = a, this.isUsingEmulator = u;
  }
}
const ut = "(default)";
class DatabaseId {
  constructor(e, t) {
    this.projectId = e, this.database = t || ut;
  }
  static empty() {
    return new DatabaseId("", "");
  }
  get isDefaultDatabase() {
    return this.database === ut;
  }
  isEqual(e) {
    return e instanceof DatabaseId && e.projectId === this.projectId && e.database === this.database;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ct = "__type__", lt = "__max__", ht = {
  mapValue: {}
}, Pt = "__vector__", Tt = "value";
function __PRIVATE_typeOrder(e) {
  return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? __PRIVATE_isServerTimestamp(e) ? 4 : __PRIVATE_isMaxValue(e) ? 9007199254740991 : __PRIVATE_isVectorValue(e) ? 10 : 11 : fail(28295, {
    value: e
  });
}
function __PRIVATE_valueEquals(e, t) {
  if (e === t) return true;
  const n = __PRIVATE_typeOrder(e);
  if (n !== __PRIVATE_typeOrder(t)) return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return e.booleanValue === t.booleanValue;
    case 4:
      return __PRIVATE_getLocalWriteTime(e).isEqual(__PRIVATE_getLocalWriteTime(t));
    case 3:
      return function __PRIVATE_timestampEquals(e2, t2) {
        if ("string" == typeof e2.timestampValue && "string" == typeof t2.timestampValue && e2.timestampValue.length === t2.timestampValue.length)
          return e2.timestampValue === t2.timestampValue;
        const n2 = __PRIVATE_normalizeTimestamp(e2.timestampValue), r = __PRIVATE_normalizeTimestamp(t2.timestampValue);
        return n2.seconds === r.seconds && n2.nanos === r.nanos;
      }(e, t);
    case 5:
      return e.stringValue === t.stringValue;
    case 6:
      return function __PRIVATE_blobEquals(e2, t2) {
        return __PRIVATE_normalizeByteString(e2.bytesValue).isEqual(__PRIVATE_normalizeByteString(t2.bytesValue));
      }(e, t);
    case 7:
      return e.referenceValue === t.referenceValue;
    case 8:
      return function __PRIVATE_geoPointEquals(e2, t2) {
        return __PRIVATE_normalizeNumber(e2.geoPointValue.latitude) === __PRIVATE_normalizeNumber(t2.geoPointValue.latitude) && __PRIVATE_normalizeNumber(e2.geoPointValue.longitude) === __PRIVATE_normalizeNumber(t2.geoPointValue.longitude);
      }(e, t);
    case 2:
      return function __PRIVATE_numberEquals(e2, t2) {
        if ("integerValue" in e2 && "integerValue" in t2) return __PRIVATE_normalizeNumber(e2.integerValue) === __PRIVATE_normalizeNumber(t2.integerValue);
        if ("doubleValue" in e2 && "doubleValue" in t2) {
          const n2 = __PRIVATE_normalizeNumber(e2.doubleValue), r = __PRIVATE_normalizeNumber(t2.doubleValue);
          return n2 === r ? __PRIVATE_isNegativeZero(n2) === __PRIVATE_isNegativeZero(r) : isNaN(n2) && isNaN(r);
        }
        return false;
      }(e, t);
    case 9:
      return __PRIVATE_arrayEquals(e.arrayValue.values || [], t.arrayValue.values || [], __PRIVATE_valueEquals);
    case 10:
    case 11:
      return function __PRIVATE_objectEquals(e2, t2) {
        const n2 = e2.mapValue.fields || {}, r = t2.mapValue.fields || {};
        if (__PRIVATE_objectSize(n2) !== __PRIVATE_objectSize(r)) return false;
        for (const e3 in n2) if (n2.hasOwnProperty(e3) && (void 0 === r[e3] || !__PRIVATE_valueEquals(n2[e3], r[e3]))) return false;
        return true;
      }(e, t);
    default:
      return fail(52216, {
        left: e
      });
  }
}
function __PRIVATE_arrayValueContains(e, t) {
  return void 0 !== (e.values || []).find((e2) => __PRIVATE_valueEquals(e2, t));
}
function __PRIVATE_valueCompare(e, t) {
  if (e === t) return 0;
  const n = __PRIVATE_typeOrder(e), r = __PRIVATE_typeOrder(t);
  if (n !== r) return __PRIVATE_primitiveComparator(n, r);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return __PRIVATE_primitiveComparator(e.booleanValue, t.booleanValue);
    case 2:
      return function __PRIVATE_compareNumbers(e2, t2) {
        const n2 = __PRIVATE_normalizeNumber(e2.integerValue || e2.doubleValue), r2 = __PRIVATE_normalizeNumber(t2.integerValue || t2.doubleValue);
        return n2 < r2 ? -1 : n2 > r2 ? 1 : n2 === r2 ? 0 : (
          // one or both are NaN.
          isNaN(n2) ? isNaN(r2) ? 0 : -1 : 1
        );
      }(e, t);
    case 3:
      return __PRIVATE_compareTimestamps(e.timestampValue, t.timestampValue);
    case 4:
      return __PRIVATE_compareTimestamps(__PRIVATE_getLocalWriteTime(e), __PRIVATE_getLocalWriteTime(t));
    case 5:
      return __PRIVATE_compareUtf8Strings(e.stringValue, t.stringValue);
    case 6:
      return function __PRIVATE_compareBlobs(e2, t2) {
        const n2 = __PRIVATE_normalizeByteString(e2), r2 = __PRIVATE_normalizeByteString(t2);
        return n2.compareTo(r2);
      }(e.bytesValue, t.bytesValue);
    case 7:
      return function __PRIVATE_compareReferences(e2, t2) {
        const n2 = e2.split("/"), r2 = t2.split("/");
        for (let e3 = 0; e3 < n2.length && e3 < r2.length; e3++) {
          const t3 = __PRIVATE_primitiveComparator(n2[e3], r2[e3]);
          if (0 !== t3) return t3;
        }
        return __PRIVATE_primitiveComparator(n2.length, r2.length);
      }(e.referenceValue, t.referenceValue);
    case 8:
      return function __PRIVATE_compareGeoPoints(e2, t2) {
        const n2 = __PRIVATE_primitiveComparator(__PRIVATE_normalizeNumber(e2.latitude), __PRIVATE_normalizeNumber(t2.latitude));
        if (0 !== n2) return n2;
        return __PRIVATE_primitiveComparator(__PRIVATE_normalizeNumber(e2.longitude), __PRIVATE_normalizeNumber(t2.longitude));
      }(e.geoPointValue, t.geoPointValue);
    case 9:
      return __PRIVATE_compareArrays(e.arrayValue, t.arrayValue);
    case 10:
      return function __PRIVATE_compareVectors(e2, t2) {
        var n2, r2, i, s;
        const o = e2.fields || {}, _ = t2.fields || {}, a = null === (n2 = o[Tt]) || void 0 === n2 ? void 0 : n2.arrayValue, u = null === (r2 = _[Tt]) || void 0 === r2 ? void 0 : r2.arrayValue, c = __PRIVATE_primitiveComparator((null === (i = null == a ? void 0 : a.values) || void 0 === i ? void 0 : i.length) || 0, (null === (s = null == u ? void 0 : u.values) || void 0 === s ? void 0 : s.length) || 0);
        if (0 !== c) return c;
        return __PRIVATE_compareArrays(a, u);
      }(e.mapValue, t.mapValue);
    case 11:
      return function __PRIVATE_compareMaps(e2, t2) {
        if (e2 === ht.mapValue && t2 === ht.mapValue) return 0;
        if (e2 === ht.mapValue) return 1;
        if (t2 === ht.mapValue) return -1;
        const n2 = e2.fields || {}, r2 = Object.keys(n2), i = t2.fields || {}, s = Object.keys(i);
        r2.sort(), s.sort();
        for (let e3 = 0; e3 < r2.length && e3 < s.length; ++e3) {
          const t3 = __PRIVATE_compareUtf8Strings(r2[e3], s[e3]);
          if (0 !== t3) return t3;
          const o = __PRIVATE_valueCompare(n2[r2[e3]], i[s[e3]]);
          if (0 !== o) return o;
        }
        return __PRIVATE_primitiveComparator(r2.length, s.length);
      }(e.mapValue, t.mapValue);
    default:
      throw fail(23264, {
        le: n
      });
  }
}
function __PRIVATE_compareTimestamps(e, t) {
  if ("string" == typeof e && "string" == typeof t && e.length === t.length) return __PRIVATE_primitiveComparator(e, t);
  const n = __PRIVATE_normalizeTimestamp(e), r = __PRIVATE_normalizeTimestamp(t), i = __PRIVATE_primitiveComparator(n.seconds, r.seconds);
  return 0 !== i ? i : __PRIVATE_primitiveComparator(n.nanos, r.nanos);
}
function __PRIVATE_compareArrays(e, t) {
  const n = e.values || [], r = t.values || [];
  for (let e2 = 0; e2 < n.length && e2 < r.length; ++e2) {
    const t2 = __PRIVATE_valueCompare(n[e2], r[e2]);
    if (t2) return t2;
  }
  return __PRIVATE_primitiveComparator(n.length, r.length);
}
function canonicalId(e) {
  return __PRIVATE_canonifyValue(e);
}
function __PRIVATE_canonifyValue(e) {
  return "nullValue" in e ? "null" : "booleanValue" in e ? "" + e.booleanValue : "integerValue" in e ? "" + e.integerValue : "doubleValue" in e ? "" + e.doubleValue : "timestampValue" in e ? function __PRIVATE_canonifyTimestamp(e2) {
    const t = __PRIVATE_normalizeTimestamp(e2);
    return `time(${t.seconds},${t.nanos})`;
  }(e.timestampValue) : "stringValue" in e ? e.stringValue : "bytesValue" in e ? function __PRIVATE_canonifyByteString(e2) {
    return __PRIVATE_normalizeByteString(e2).toBase64();
  }(e.bytesValue) : "referenceValue" in e ? function __PRIVATE_canonifyReference(e2) {
    return DocumentKey.fromName(e2).toString();
  }(e.referenceValue) : "geoPointValue" in e ? function __PRIVATE_canonifyGeoPoint(e2) {
    return `geo(${e2.latitude},${e2.longitude})`;
  }(e.geoPointValue) : "arrayValue" in e ? function __PRIVATE_canonifyArray(e2) {
    let t = "[", n = true;
    for (const r of e2.values || []) n ? n = false : t += ",", t += __PRIVATE_canonifyValue(r);
    return t + "]";
  }(e.arrayValue) : "mapValue" in e ? function __PRIVATE_canonifyMap(e2) {
    const t = Object.keys(e2.fields || {}).sort();
    let n = "{", r = true;
    for (const i of t) r ? r = false : n += ",", n += `${i}:${__PRIVATE_canonifyValue(e2.fields[i])}`;
    return n + "}";
  }(e.mapValue) : fail(61005, {
    value: e
  });
}
function __PRIVATE_estimateByteSize(e) {
  switch (__PRIVATE_typeOrder(e)) {
    case 0:
    case 1:
      return 4;
    case 2:
      return 8;
    case 3:
    case 8:
      return 16;
    case 4:
      const t = __PRIVATE_getPreviousValue(e);
      return t ? 16 + __PRIVATE_estimateByteSize(t) : 16;
    case 5:
      return 2 * e.stringValue.length;
    case 6:
      return __PRIVATE_normalizeByteString(e.bytesValue).approximateByteSize();
    case 7:
      return e.referenceValue.length;
    case 9:
      return function __PRIVATE_estimateArrayByteSize(e2) {
        return (e2.values || []).reduce((e3, t2) => e3 + __PRIVATE_estimateByteSize(t2), 0);
      }(e.arrayValue);
    case 10:
    case 11:
      return function __PRIVATE_estimateMapByteSize(e2) {
        let t2 = 0;
        return forEach(e2.fields, (e3, n) => {
          t2 += e3.length + __PRIVATE_estimateByteSize(n);
        }), t2;
      }(e.mapValue);
    default:
      throw fail(13486, {
        value: e
      });
  }
}
function __PRIVATE_refValue(e, t) {
  return {
    referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}`
  };
}
function isInteger(e) {
  return !!e && "integerValue" in e;
}
function isArray(e) {
  return !!e && "arrayValue" in e;
}
function __PRIVATE_isNullValue(e) {
  return !!e && "nullValue" in e;
}
function __PRIVATE_isNanValue(e) {
  return !!e && "doubleValue" in e && isNaN(Number(e.doubleValue));
}
function __PRIVATE_isMapValue(e) {
  return !!e && "mapValue" in e;
}
function __PRIVATE_isVectorValue(e) {
  var t, n;
  return (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {})[ct]) || void 0 === n ? void 0 : n.stringValue) === Pt;
}
function __PRIVATE_deepClone(e) {
  if (e.geoPointValue) return {
    geoPointValue: Object.assign({}, e.geoPointValue)
  };
  if (e.timestampValue && "object" == typeof e.timestampValue) return {
    timestampValue: Object.assign({}, e.timestampValue)
  };
  if (e.mapValue) {
    const t = {
      mapValue: {
        fields: {}
      }
    };
    return forEach(e.mapValue.fields, (e2, n) => t.mapValue.fields[e2] = __PRIVATE_deepClone(n)), t;
  }
  if (e.arrayValue) {
    const t = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (e.arrayValue.values || []).length; ++n) t.arrayValue.values[n] = __PRIVATE_deepClone(e.arrayValue.values[n]);
    return t;
  }
  return Object.assign({}, e);
}
function __PRIVATE_isMaxValue(e) {
  return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === lt;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectValue {
  constructor(e) {
    this.value = e;
  }
  static empty() {
    return new ObjectValue({
      mapValue: {}
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(e) {
    if (e.isEmpty()) return this.value;
    {
      let t = this.value;
      for (let n = 0; n < e.length - 1; ++n) if (t = (t.mapValue.fields || {})[e.get(n)], !__PRIVATE_isMapValue(t)) return null;
      return t = (t.mapValue.fields || {})[e.lastSegment()], t || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(e, t) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = __PRIVATE_deepClone(t);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(e) {
    let t = FieldPath$1.emptyPath(), n = {}, r = [];
    e.forEach((e2, i2) => {
      if (!t.isImmediateParentOf(i2)) {
        const e3 = this.getFieldsMap(t);
        this.applyChanges(e3, n, r), n = {}, r = [], t = i2.popLast();
      }
      e2 ? n[i2.lastSegment()] = __PRIVATE_deepClone(e2) : r.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(t);
    this.applyChanges(i, n, r);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(e) {
    const t = this.field(e.popLast());
    __PRIVATE_isMapValue(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
  }
  isEqual(e) {
    return __PRIVATE_valueEquals(this.value, e.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(e) {
    let t = this.value;
    t.mapValue.fields || (t.mapValue = {
      fields: {}
    });
    for (let n = 0; n < e.length; ++n) {
      let r = t.mapValue.fields[e.get(n)];
      __PRIVATE_isMapValue(r) && r.mapValue.fields || (r = {
        mapValue: {
          fields: {}
        }
      }, t.mapValue.fields[e.get(n)] = r), t = r;
    }
    return t.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(e, t, n) {
    forEach(t, (t2, n2) => e[t2] = n2);
    for (const t2 of n) delete e[t2];
  }
  clone() {
    return new ObjectValue(__PRIVATE_deepClone(this.value));
  }
}
function __PRIVATE_extractFieldMask(e) {
  const t = [];
  return forEach(e.fields, (e2, n) => {
    const r = new FieldPath$1([e2]);
    if (__PRIVATE_isMapValue(n)) {
      const e3 = __PRIVATE_extractFieldMask(n.mapValue).fields;
      if (0 === e3.length)
        t.push(r);
      else
        for (const n2 of e3) t.push(r.child(n2));
    } else
      t.push(r);
  }), new FieldMask(t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MutableDocument {
  constructor(e, t, n, r, i, s, o) {
    this.key = e, this.documentType = t, this.version = n, this.readTime = r, this.createTime = i, this.data = s, this.documentState = o;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(e) {
    return new MutableDocument(
      e,
      0,
      /* version */
      SnapshotVersion.min(),
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      SnapshotVersion.min(),
      ObjectValue.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(e, t, n, r) {
    return new MutableDocument(
      e,
      1,
      /* version */
      t,
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      n,
      r,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(e, t) {
    return new MutableDocument(
      e,
      2,
      /* version */
      t,
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      SnapshotVersion.min(),
      ObjectValue.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(e, t) {
    return new MutableDocument(
      e,
      3,
      /* version */
      t,
      /* readTime */
      SnapshotVersion.min(),
      /* createTime */
      SnapshotVersion.min(),
      ObjectValue.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(e, t) {
    return !this.createTime.isEqual(SnapshotVersion.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = e), this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(e) {
    return this.version = e, this.documentType = 2, this.data = ObjectValue.empty(), this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(e) {
    return this.version = e, this.documentType = 3, this.data = ObjectValue.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = SnapshotVersion.min(), this;
  }
  setReadTime(e) {
    return this.readTime = e, this;
  }
  get hasLocalMutations() {
    return 1 === this.documentState;
  }
  get hasCommittedMutations() {
    return 2 === this.documentState;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return 0 !== this.documentType;
  }
  isFoundDocument() {
    return 1 === this.documentType;
  }
  isNoDocument() {
    return 2 === this.documentType;
  }
  isUnknownDocument() {
    return 3 === this.documentType;
  }
  isEqual(e) {
    return e instanceof MutableDocument && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data);
  }
  mutableCopy() {
    return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bound {
  constructor(e, t) {
    this.position = e, this.inclusive = t;
  }
}
function __PRIVATE_boundCompareToDocument(e, t, n) {
  let r = 0;
  for (let i = 0; i < e.position.length; i++) {
    const s = t[i], o = e.position[i];
    if (s.field.isKeyField()) r = DocumentKey.comparator(DocumentKey.fromName(o.referenceValue), n.key);
    else {
      r = __PRIVATE_valueCompare(o, n.data.field(s.field));
    }
    if ("desc" === s.dir && (r *= -1), 0 !== r) break;
  }
  return r;
}
function __PRIVATE_boundEquals(e, t) {
  if (null === e) return null === t;
  if (null === t) return false;
  if (e.inclusive !== t.inclusive || e.position.length !== t.position.length) return false;
  for (let n = 0; n < e.position.length; n++) {
    if (!__PRIVATE_valueEquals(e.position[n], t.position[n])) return false;
  }
  return true;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OrderBy {
  constructor(e, t = "asc") {
    this.field = e, this.dir = t;
  }
}
function __PRIVATE_orderByEquals(e, t) {
  return e.dir === t.dir && e.field.isEqual(t.field);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Filter {
}
class FieldFilter extends Filter {
  constructor(e, t, n) {
    super(), this.field = e, this.op = t, this.value = n;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t, n) {
    return e.isKeyField() ? "in" === t || "not-in" === t ? this.createKeyFieldInFilter(e, t, n) : new __PRIVATE_KeyFieldFilter(e, t, n) : "array-contains" === t ? new __PRIVATE_ArrayContainsFilter(e, n) : "in" === t ? new __PRIVATE_InFilter(e, n) : "not-in" === t ? new __PRIVATE_NotInFilter(e, n) : "array-contains-any" === t ? new __PRIVATE_ArrayContainsAnyFilter(e, n) : new FieldFilter(e, t, n);
  }
  static createKeyFieldInFilter(e, t, n) {
    return "in" === t ? new __PRIVATE_KeyFieldInFilter(e, n) : new __PRIVATE_KeyFieldNotInFilter(e, n);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return "!=" === this.op ? null !== t && void 0 === t.nullValue && this.matchesComparison(__PRIVATE_valueCompare(t, this.value)) : null !== t && __PRIVATE_typeOrder(this.value) === __PRIVATE_typeOrder(t) && this.matchesComparison(__PRIVATE_valueCompare(t, this.value));
  }
  matchesComparison(e) {
    switch (this.op) {
      case "<":
        return e < 0;
      case "<=":
        return e <= 0;
      case "==":
        return 0 === e;
      case "!=":
        return 0 !== e;
      case ">":
        return e > 0;
      case ">=":
        return e >= 0;
      default:
        return fail(47266, {
          operator: this.op
        });
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
}
class CompositeFilter extends Filter {
  constructor(e, t) {
    super(), this.filters = e, this.op = t, this.he = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t) {
    return new CompositeFilter(e, t);
  }
  matches(e) {
    return __PRIVATE_compositeFilterIsConjunction(this) ? void 0 === this.filters.find((t) => !t.matches(e)) : void 0 !== this.filters.find((t) => t.matches(e));
  }
  getFlattenedFilters() {
    return null !== this.he || (this.he = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.he;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
}
function __PRIVATE_compositeFilterIsConjunction(e) {
  return "and" === e.op;
}
function __PRIVATE_compositeFilterIsFlatConjunction(e) {
  return __PRIVATE_compositeFilterIsFlat(e) && __PRIVATE_compositeFilterIsConjunction(e);
}
function __PRIVATE_compositeFilterIsFlat(e) {
  for (const t of e.filters) if (t instanceof CompositeFilter) return false;
  return true;
}
function __PRIVATE_canonifyFilter(e) {
  if (e instanceof FieldFilter)
    return e.field.canonicalString() + e.op.toString() + canonicalId(e.value);
  if (__PRIVATE_compositeFilterIsFlatConjunction(e))
    return e.filters.map((e2) => __PRIVATE_canonifyFilter(e2)).join(",");
  {
    const t = e.filters.map((e2) => __PRIVATE_canonifyFilter(e2)).join(",");
    return `${e.op}(${t})`;
  }
}
function __PRIVATE_filterEquals(e, t) {
  return e instanceof FieldFilter ? function __PRIVATE_fieldFilterEquals(e2, t2) {
    return t2 instanceof FieldFilter && e2.op === t2.op && e2.field.isEqual(t2.field) && __PRIVATE_valueEquals(e2.value, t2.value);
  }(e, t) : e instanceof CompositeFilter ? function __PRIVATE_compositeFilterEquals(e2, t2) {
    if (t2 instanceof CompositeFilter && e2.op === t2.op && e2.filters.length === t2.filters.length) {
      return e2.filters.reduce((e3, n, r) => e3 && __PRIVATE_filterEquals(n, t2.filters[r]), true);
    }
    return false;
  }(e, t) : void fail(19439);
}
function __PRIVATE_stringifyFilter(e) {
  return e instanceof FieldFilter ? function __PRIVATE_stringifyFieldFilter(e2) {
    return `${e2.field.canonicalString()} ${e2.op} ${canonicalId(e2.value)}`;
  }(e) : e instanceof CompositeFilter ? function __PRIVATE_stringifyCompositeFilter(e2) {
    return e2.op.toString() + " {" + e2.getFilters().map(__PRIVATE_stringifyFilter).join(" ,") + "}";
  }(e) : "Filter";
}
class __PRIVATE_KeyFieldFilter extends FieldFilter {
  constructor(e, t, n) {
    super(e, t, n), this.key = DocumentKey.fromName(n.referenceValue);
  }
  matches(e) {
    const t = DocumentKey.comparator(e.key, this.key);
    return this.matchesComparison(t);
  }
}
class __PRIVATE_KeyFieldInFilter extends FieldFilter {
  constructor(e, t) {
    super(e, "in", t), this.keys = __PRIVATE_extractDocumentKeysFromArrayValue("in", t);
  }
  matches(e) {
    return this.keys.some((t) => t.isEqual(e.key));
  }
}
class __PRIVATE_KeyFieldNotInFilter extends FieldFilter {
  constructor(e, t) {
    super(e, "not-in", t), this.keys = __PRIVATE_extractDocumentKeysFromArrayValue("not-in", t);
  }
  matches(e) {
    return !this.keys.some((t) => t.isEqual(e.key));
  }
}
function __PRIVATE_extractDocumentKeysFromArrayValue(e, t) {
  var n;
  return ((null === (n = t.arrayValue) || void 0 === n ? void 0 : n.values) || []).map((e2) => DocumentKey.fromName(e2.referenceValue));
}
class __PRIVATE_ArrayContainsFilter extends FieldFilter {
  constructor(e, t) {
    super(e, "array-contains", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return isArray(t) && __PRIVATE_arrayValueContains(t.arrayValue, this.value);
  }
}
class __PRIVATE_InFilter extends FieldFilter {
  constructor(e, t) {
    super(e, "in", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return null !== t && __PRIVATE_arrayValueContains(this.value.arrayValue, t);
  }
}
class __PRIVATE_NotInFilter extends FieldFilter {
  constructor(e, t) {
    super(e, "not-in", t);
  }
  matches(e) {
    if (__PRIVATE_arrayValueContains(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    })) return false;
    const t = e.data.field(this.field);
    return null !== t && void 0 === t.nullValue && !__PRIVATE_arrayValueContains(this.value.arrayValue, t);
  }
}
class __PRIVATE_ArrayContainsAnyFilter extends FieldFilter {
  constructor(e, t) {
    super(e, "array-contains-any", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return !(!isArray(t) || !t.arrayValue.values) && t.arrayValue.values.some((e2) => __PRIVATE_arrayValueContains(this.value.arrayValue, e2));
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_TargetImpl {
  constructor(e, t = null, n = [], r = [], i = null, s = null, o = null) {
    this.path = e, this.collectionGroup = t, this.orderBy = n, this.filters = r, this.limit = i, this.startAt = s, this.endAt = o, this.Pe = null;
  }
}
function __PRIVATE_newTarget(e, t = null, n = [], r = [], i = null, s = null, o = null) {
  return new __PRIVATE_TargetImpl(e, t, n, r, i, s, o);
}
function __PRIVATE_canonifyTarget(e) {
  const t = __PRIVATE_debugCast(e);
  if (null === t.Pe) {
    let e2 = t.path.canonicalString();
    null !== t.collectionGroup && (e2 += "|cg:" + t.collectionGroup), e2 += "|f:", e2 += t.filters.map((e3) => __PRIVATE_canonifyFilter(e3)).join(","), e2 += "|ob:", e2 += t.orderBy.map((e3) => function __PRIVATE_canonifyOrderBy(e4) {
      return e4.field.canonicalString() + e4.dir;
    }(e3)).join(","), __PRIVATE_isNullOrUndefined(t.limit) || (e2 += "|l:", e2 += t.limit), t.startAt && (e2 += "|lb:", e2 += t.startAt.inclusive ? "b:" : "a:", e2 += t.startAt.position.map((e3) => canonicalId(e3)).join(",")), t.endAt && (e2 += "|ub:", e2 += t.endAt.inclusive ? "a:" : "b:", e2 += t.endAt.position.map((e3) => canonicalId(e3)).join(",")), t.Pe = e2;
  }
  return t.Pe;
}
function __PRIVATE_targetEquals(e, t) {
  if (e.limit !== t.limit) return false;
  if (e.orderBy.length !== t.orderBy.length) return false;
  for (let n = 0; n < e.orderBy.length; n++) if (!__PRIVATE_orderByEquals(e.orderBy[n], t.orderBy[n])) return false;
  if (e.filters.length !== t.filters.length) return false;
  for (let n = 0; n < e.filters.length; n++) if (!__PRIVATE_filterEquals(e.filters[n], t.filters[n])) return false;
  return e.collectionGroup === t.collectionGroup && (!!e.path.isEqual(t.path) && (!!__PRIVATE_boundEquals(e.startAt, t.startAt) && __PRIVATE_boundEquals(e.endAt, t.endAt)));
}
function __PRIVATE_targetIsDocumentTarget(e) {
  return DocumentKey.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_QueryImpl {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(e, t = null, n = [], r = [], i = null, s = "F", o = null, _ = null) {
    this.path = e, this.collectionGroup = t, this.explicitOrderBy = n, this.filters = r, this.limit = i, this.limitType = s, this.startAt = o, this.endAt = _, this.Te = null, // The corresponding `Target` of this `Query` instance, for use with
    // non-aggregate queries.
    this.Ie = null, // The corresponding `Target` of this `Query` instance, for use with
    // aggregate queries. Unlike targets for non-aggregate queries,
    // aggregate query targets do not contain normalized order-bys, they only
    // contain explicit order-bys.
    this.de = null, this.startAt, this.endAt;
  }
}
function __PRIVATE_newQuery(e, t, n, r, i, s, o, _) {
  return new __PRIVATE_QueryImpl(e, t, n, r, i, s, o, _);
}
function __PRIVATE_newQueryForPath(e) {
  return new __PRIVATE_QueryImpl(e);
}
function __PRIVATE_queryMatchesAllDocuments(e) {
  return 0 === e.filters.length && null === e.limit && null == e.startAt && null == e.endAt && (0 === e.explicitOrderBy.length || 1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField());
}
function __PRIVATE_isCollectionGroupQuery(e) {
  return null !== e.collectionGroup;
}
function __PRIVATE_queryNormalizedOrderBy(e) {
  const t = __PRIVATE_debugCast(e);
  if (null === t.Te) {
    t.Te = [];
    const e2 = /* @__PURE__ */ new Set();
    for (const n2 of t.explicitOrderBy) t.Te.push(n2), e2.add(n2.field.canonicalString());
    const n = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc", r = function __PRIVATE_getInequalityFilterFields(e3) {
      let t2 = new SortedSet(FieldPath$1.comparator);
      return e3.filters.forEach((e4) => {
        e4.getFlattenedFilters().forEach((e5) => {
          e5.isInequality() && (t2 = t2.add(e5.field));
        });
      }), t2;
    }(t);
    r.forEach((r2) => {
      e2.has(r2.canonicalString()) || r2.isKeyField() || t.Te.push(new OrderBy(r2, n));
    }), // Add the document key field to the last if it is not explicitly ordered.
    e2.has(FieldPath$1.keyField().canonicalString()) || t.Te.push(new OrderBy(FieldPath$1.keyField(), n));
  }
  return t.Te;
}
function __PRIVATE_queryToTarget(e) {
  const t = __PRIVATE_debugCast(e);
  return t.Ie || (t.Ie = __PRIVATE__queryToTarget(t, __PRIVATE_queryNormalizedOrderBy(e))), t.Ie;
}
function __PRIVATE__queryToTarget(e, t) {
  if ("F" === e.limitType) return __PRIVATE_newTarget(e.path, e.collectionGroup, t, e.filters, e.limit, e.startAt, e.endAt);
  {
    t = t.map((e2) => {
      const t2 = "desc" === e2.dir ? "asc" : "desc";
      return new OrderBy(e2.field, t2);
    });
    const n = e.endAt ? new Bound(e.endAt.position, e.endAt.inclusive) : null, r = e.startAt ? new Bound(e.startAt.position, e.startAt.inclusive) : null;
    return __PRIVATE_newTarget(e.path, e.collectionGroup, t, e.filters, e.limit, n, r);
  }
}
function __PRIVATE_queryWithAddedFilter(e, t) {
  const n = e.filters.concat([t]);
  return new __PRIVATE_QueryImpl(e.path, e.collectionGroup, e.explicitOrderBy.slice(), n, e.limit, e.limitType, e.startAt, e.endAt);
}
function __PRIVATE_queryWithLimit(e, t, n) {
  return new __PRIVATE_QueryImpl(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt);
}
function __PRIVATE_queryEquals(e, t) {
  return __PRIVATE_targetEquals(__PRIVATE_queryToTarget(e), __PRIVATE_queryToTarget(t)) && e.limitType === t.limitType;
}
function __PRIVATE_canonifyQuery(e) {
  return `${__PRIVATE_canonifyTarget(__PRIVATE_queryToTarget(e))}|lt:${e.limitType}`;
}
function __PRIVATE_stringifyQuery(e) {
  return `Query(target=${function __PRIVATE_stringifyTarget(e2) {
    let t = e2.path.canonicalString();
    return null !== e2.collectionGroup && (t += " collectionGroup=" + e2.collectionGroup), e2.filters.length > 0 && (t += `, filters: [${e2.filters.map((e3) => __PRIVATE_stringifyFilter(e3)).join(", ")}]`), __PRIVATE_isNullOrUndefined(e2.limit) || (t += ", limit: " + e2.limit), e2.orderBy.length > 0 && (t += `, orderBy: [${e2.orderBy.map((e3) => function __PRIVATE_stringifyOrderBy(e4) {
      return `${e4.field.canonicalString()} (${e4.dir})`;
    }(e3)).join(", ")}]`), e2.startAt && (t += ", startAt: ", t += e2.startAt.inclusive ? "b:" : "a:", t += e2.startAt.position.map((e3) => canonicalId(e3)).join(",")), e2.endAt && (t += ", endAt: ", t += e2.endAt.inclusive ? "a:" : "b:", t += e2.endAt.position.map((e3) => canonicalId(e3)).join(",")), `Target(${t})`;
  }(__PRIVATE_queryToTarget(e))}; limitType=${e.limitType})`;
}
function __PRIVATE_queryMatches(e, t) {
  return t.isFoundDocument() && function __PRIVATE_queryMatchesPathAndCollectionGroup(e2, t2) {
    const n = t2.key.path;
    return null !== e2.collectionGroup ? t2.key.hasCollectionId(e2.collectionGroup) && e2.path.isPrefixOf(n) : DocumentKey.isDocumentKey(e2.path) ? e2.path.isEqual(n) : e2.path.isImmediateParentOf(n);
  }(e, t) && function __PRIVATE_queryMatchesOrderBy(e2, t2) {
    for (const n of __PRIVATE_queryNormalizedOrderBy(e2))
      if (!n.field.isKeyField() && null === t2.data.field(n.field)) return false;
    return true;
  }(e, t) && function __PRIVATE_queryMatchesFilters(e2, t2) {
    for (const n of e2.filters) if (!n.matches(t2)) return false;
    return true;
  }(e, t) && function __PRIVATE_queryMatchesBounds(e2, t2) {
    if (e2.startAt && !/**
    * Returns true if a document sorts before a bound using the provided sort
    * order.
    */
    function __PRIVATE_boundSortsBeforeDocument(e3, t3, n) {
      const r = __PRIVATE_boundCompareToDocument(e3, t3, n);
      return e3.inclusive ? r <= 0 : r < 0;
    }(e2.startAt, __PRIVATE_queryNormalizedOrderBy(e2), t2)) return false;
    if (e2.endAt && !function __PRIVATE_boundSortsAfterDocument(e3, t3, n) {
      const r = __PRIVATE_boundCompareToDocument(e3, t3, n);
      return e3.inclusive ? r >= 0 : r > 0;
    }(e2.endAt, __PRIVATE_queryNormalizedOrderBy(e2), t2)) return false;
    return true;
  }(e, t);
}
function __PRIVATE_queryCollectionGroup(e) {
  return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2));
}
function __PRIVATE_newQueryComparator(e) {
  return (t, n) => {
    let r = false;
    for (const i of __PRIVATE_queryNormalizedOrderBy(e)) {
      const e2 = __PRIVATE_compareDocs(i, t, n);
      if (0 !== e2) return e2;
      r = r || i.field.isKeyField();
    }
    return 0;
  };
}
function __PRIVATE_compareDocs(e, t, n) {
  const r = e.field.isKeyField() ? DocumentKey.comparator(t.key, n.key) : function __PRIVATE_compareDocumentsByField(e2, t2, n2) {
    const r2 = t2.data.field(e2), i = n2.data.field(e2);
    return null !== r2 && null !== i ? __PRIVATE_valueCompare(r2, i) : fail(42886);
  }(e.field, t, n);
  switch (e.dir) {
    case "asc":
      return r;
    case "desc":
      return -1 * r;
    default:
      return fail(19790, {
        direction: e.dir
      });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectMap {
  constructor(e, t) {
    this.mapKeyFn = e, this.equalsFn = t, /**
     * The inner map for a key/value pair. Due to the possibility of collisions we
     * keep a list of entries that we do a linear search through to find an actual
     * match. Note that collisions should be rare, so we still expect near
     * constant time lookups in practice.
     */
    this.inner = {}, /** The number of entries stored in the map */
    this.innerSize = 0;
  }
  /** Get a value for this key, or undefined if it does not exist. */
  get(e) {
    const t = this.mapKeyFn(e), n = this.inner[t];
    if (void 0 !== n) {
      for (const [t2, r] of n) if (this.equalsFn(t2, e)) return r;
    }
  }
  has(e) {
    return void 0 !== this.get(e);
  }
  /** Put this key and value in the map. */
  set(e, t) {
    const n = this.mapKeyFn(e), r = this.inner[n];
    if (void 0 === r) return this.inner[n] = [[e, t]], void this.innerSize++;
    for (let n2 = 0; n2 < r.length; n2++) if (this.equalsFn(r[n2][0], e))
      return void (r[n2] = [e, t]);
    r.push([e, t]), this.innerSize++;
  }
  /**
   * Remove this key from the map. Returns a boolean if anything was deleted.
   */
  delete(e) {
    const t = this.mapKeyFn(e), n = this.inner[t];
    if (void 0 === n) return false;
    for (let r = 0; r < n.length; r++) if (this.equalsFn(n[r][0], e)) return 1 === n.length ? delete this.inner[t] : n.splice(r, 1), this.innerSize--, true;
    return false;
  }
  forEach(e) {
    forEach(this.inner, (t, n) => {
      for (const [t2, r] of n) e(t2, r);
    });
  }
  isEmpty() {
    return isEmpty(this.inner);
  }
  size() {
    return this.innerSize;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Et = new SortedMap(DocumentKey.comparator);
function __PRIVATE_mutableDocumentMap() {
  return Et;
}
const At = new SortedMap(DocumentKey.comparator);
function documentMap(...e) {
  let t = At;
  for (const n of e) t = t.insert(n.key, n);
  return t;
}
function __PRIVATE_convertOverlayedDocumentMapToDocumentMap(e) {
  let t = At;
  return e.forEach((e2, n) => t = t.insert(e2, n.overlayedDocument)), t;
}
function __PRIVATE_newOverlayMap() {
  return __PRIVATE_newDocumentKeyMap();
}
function __PRIVATE_newMutationMap() {
  return __PRIVATE_newDocumentKeyMap();
}
function __PRIVATE_newDocumentKeyMap() {
  return new ObjectMap((e) => e.toString(), (e, t) => e.isEqual(t));
}
const Rt = new SortedMap(DocumentKey.comparator);
const Vt = new SortedSet(DocumentKey.comparator);
function __PRIVATE_documentKeySet(...e) {
  let t = Vt;
  for (const n of e) t = t.add(n);
  return t;
}
const mt = new SortedSet(__PRIVATE_primitiveComparator);
function __PRIVATE_targetIdSet() {
  return mt;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_toDouble(e, t) {
  if (e.useProto3Json) {
    if (isNaN(t)) return {
      doubleValue: "NaN"
    };
    if (t === 1 / 0) return {
      doubleValue: "Infinity"
    };
    if (t === -1 / 0) return {
      doubleValue: "-Infinity"
    };
  }
  return {
    doubleValue: __PRIVATE_isNegativeZero(t) ? "-0" : t
  };
}
function __PRIVATE_toInteger(e) {
  return {
    integerValue: "" + e
  };
}
function toNumber(e, t) {
  return isSafeInteger(t) ? __PRIVATE_toInteger(t) : __PRIVATE_toDouble(e, t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TransformOperation {
  constructor() {
    this._ = void 0;
  }
}
function __PRIVATE_applyTransformOperationToLocalView(e, t, n) {
  return e instanceof __PRIVATE_ServerTimestampTransform ? function serverTimestamp$1(e2, t2) {
    const n2 = {
      fields: {
        [ot]: {
          stringValue: st
        },
        [at]: {
          timestampValue: {
            seconds: e2.seconds,
            nanos: e2.nanoseconds
          }
        }
      }
    };
    return t2 && __PRIVATE_isServerTimestamp(t2) && (t2 = __PRIVATE_getPreviousValue(t2)), t2 && (n2.fields[_t] = t2), {
      mapValue: n2
    };
  }(n, t) : e instanceof __PRIVATE_ArrayUnionTransformOperation ? __PRIVATE_applyArrayUnionTransformOperation(e, t) : e instanceof __PRIVATE_ArrayRemoveTransformOperation ? __PRIVATE_applyArrayRemoveTransformOperation(e, t) : function __PRIVATE_applyNumericIncrementTransformOperationToLocalView(e2, t2) {
    const n2 = __PRIVATE_computeTransformOperationBaseValue(e2, t2), r = asNumber(n2) + asNumber(e2.Ee);
    return isInteger(n2) && isInteger(e2.Ee) ? __PRIVATE_toInteger(r) : __PRIVATE_toDouble(e2.serializer, r);
  }(e, t);
}
function __PRIVATE_applyTransformOperationToRemoteDocument(e, t, n) {
  return e instanceof __PRIVATE_ArrayUnionTransformOperation ? __PRIVATE_applyArrayUnionTransformOperation(e, t) : e instanceof __PRIVATE_ArrayRemoveTransformOperation ? __PRIVATE_applyArrayRemoveTransformOperation(e, t) : n;
}
function __PRIVATE_computeTransformOperationBaseValue(e, t) {
  return e instanceof __PRIVATE_NumericIncrementTransformOperation ? (
    /** Returns true if `value` is either an IntegerValue or a DoubleValue. */
    function __PRIVATE_isNumber(e2) {
      return isInteger(e2) || function __PRIVATE_isDouble(e3) {
        return !!e3 && "doubleValue" in e3;
      }(e2);
    }(t) ? t : {
      integerValue: 0
    }
  ) : null;
}
class __PRIVATE_ServerTimestampTransform extends TransformOperation {
}
class __PRIVATE_ArrayUnionTransformOperation extends TransformOperation {
  constructor(e) {
    super(), this.elements = e;
  }
}
function __PRIVATE_applyArrayUnionTransformOperation(e, t) {
  const n = __PRIVATE_coercedFieldValuesArray(t);
  for (const t2 of e.elements) n.some((e2) => __PRIVATE_valueEquals(e2, t2)) || n.push(t2);
  return {
    arrayValue: {
      values: n
    }
  };
}
class __PRIVATE_ArrayRemoveTransformOperation extends TransformOperation {
  constructor(e) {
    super(), this.elements = e;
  }
}
function __PRIVATE_applyArrayRemoveTransformOperation(e, t) {
  let n = __PRIVATE_coercedFieldValuesArray(t);
  for (const t2 of e.elements) n = n.filter((e2) => !__PRIVATE_valueEquals(e2, t2));
  return {
    arrayValue: {
      values: n
    }
  };
}
class __PRIVATE_NumericIncrementTransformOperation extends TransformOperation {
  constructor(e, t) {
    super(), this.serializer = e, this.Ee = t;
  }
}
function asNumber(e) {
  return __PRIVATE_normalizeNumber(e.integerValue || e.doubleValue);
}
function __PRIVATE_coercedFieldValuesArray(e) {
  return isArray(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [];
}
function __PRIVATE_fieldTransformEquals(e, t) {
  return e.field.isEqual(t.field) && function __PRIVATE_transformOperationEquals(e2, t2) {
    return e2 instanceof __PRIVATE_ArrayUnionTransformOperation && t2 instanceof __PRIVATE_ArrayUnionTransformOperation || e2 instanceof __PRIVATE_ArrayRemoveTransformOperation && t2 instanceof __PRIVATE_ArrayRemoveTransformOperation ? __PRIVATE_arrayEquals(e2.elements, t2.elements, __PRIVATE_valueEquals) : e2 instanceof __PRIVATE_NumericIncrementTransformOperation && t2 instanceof __PRIVATE_NumericIncrementTransformOperation ? __PRIVATE_valueEquals(e2.Ee, t2.Ee) : e2 instanceof __PRIVATE_ServerTimestampTransform && t2 instanceof __PRIVATE_ServerTimestampTransform;
  }(e.transform, t.transform);
}
class MutationResult {
  constructor(e, t) {
    this.version = e, this.transformResults = t;
  }
}
class Precondition {
  constructor(e, t) {
    this.updateTime = e, this.exists = t;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new Precondition();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(e) {
    return new Precondition(void 0, e);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(e) {
    return new Precondition(e);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return void 0 === this.updateTime && void 0 === this.exists;
  }
  isEqual(e) {
    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
  }
}
function __PRIVATE_preconditionIsValidForDocument(e, t) {
  return void 0 !== e.updateTime ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : void 0 === e.exists || e.exists === t.isFoundDocument();
}
class Mutation {
}
function __PRIVATE_calculateOverlayMutation(e, t) {
  if (!e.hasLocalMutations || t && 0 === t.fields.length) return null;
  if (null === t) return e.isNoDocument() ? new __PRIVATE_DeleteMutation(e.key, Precondition.none()) : new __PRIVATE_SetMutation(e.key, e.data, Precondition.none());
  {
    const n = e.data, r = ObjectValue.empty();
    let i = new SortedSet(FieldPath$1.comparator);
    for (let e2 of t.fields) if (!i.has(e2)) {
      let t2 = n.field(e2);
      null === t2 && e2.length > 1 && (e2 = e2.popLast(), t2 = n.field(e2)), null === t2 ? r.delete(e2) : r.set(e2, t2), i = i.add(e2);
    }
    return new __PRIVATE_PatchMutation(e.key, r, new FieldMask(i.toArray()), Precondition.none());
  }
}
function __PRIVATE_mutationApplyToRemoteDocument(e, t, n) {
  e instanceof __PRIVATE_SetMutation ? function __PRIVATE_setMutationApplyToRemoteDocument(e2, t2, n2) {
    const r = e2.value.clone(), i = __PRIVATE_serverTransformResults(e2.fieldTransforms, t2, n2.transformResults);
    r.setAll(i), t2.convertToFoundDocument(n2.version, r).setHasCommittedMutations();
  }(e, t, n) : e instanceof __PRIVATE_PatchMutation ? function __PRIVATE_patchMutationApplyToRemoteDocument(e2, t2, n2) {
    if (!__PRIVATE_preconditionIsValidForDocument(e2.precondition, t2))
      return void t2.convertToUnknownDocument(n2.version);
    const r = __PRIVATE_serverTransformResults(e2.fieldTransforms, t2, n2.transformResults), i = t2.data;
    i.setAll(__PRIVATE_getPatch(e2)), i.setAll(r), t2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(e, t, n) : function __PRIVATE_deleteMutationApplyToRemoteDocument(e2, t2, n2) {
    t2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, t, n);
}
function __PRIVATE_mutationApplyToLocalView(e, t, n, r) {
  return e instanceof __PRIVATE_SetMutation ? function __PRIVATE_setMutationApplyToLocalView(e2, t2, n2, r2) {
    if (!__PRIVATE_preconditionIsValidForDocument(e2.precondition, t2))
      return n2;
    const i = e2.value.clone(), s = __PRIVATE_localTransformResults(e2.fieldTransforms, r2, t2);
    return i.setAll(s), t2.convertToFoundDocument(t2.version, i).setHasLocalMutations(), null;
  }(e, t, n, r) : e instanceof __PRIVATE_PatchMutation ? function __PRIVATE_patchMutationApplyToLocalView(e2, t2, n2, r2) {
    if (!__PRIVATE_preconditionIsValidForDocument(e2.precondition, t2)) return n2;
    const i = __PRIVATE_localTransformResults(e2.fieldTransforms, r2, t2), s = t2.data;
    if (s.setAll(__PRIVATE_getPatch(e2)), s.setAll(i), t2.convertToFoundDocument(t2.version, s).setHasLocalMutations(), null === n2) return null;
    return n2.unionWith(e2.fieldMask.fields).unionWith(e2.fieldTransforms.map((e3) => e3.field));
  }(e, t, n, r) : function __PRIVATE_deleteMutationApplyToLocalView(e2, t2, n2) {
    if (__PRIVATE_preconditionIsValidForDocument(e2.precondition, t2)) return t2.convertToNoDocument(t2.version).setHasLocalMutations(), null;
    return n2;
  }(e, t, n);
}
function __PRIVATE_mutationExtractBaseValue(e, t) {
  let n = null;
  for (const r of e.fieldTransforms) {
    const e2 = t.data.field(r.field), i = __PRIVATE_computeTransformOperationBaseValue(r.transform, e2 || null);
    null != i && (null === n && (n = ObjectValue.empty()), n.set(r.field, i));
  }
  return n || null;
}
function __PRIVATE_mutationEquals(e, t) {
  return e.type === t.type && (!!e.key.isEqual(t.key) && (!!e.precondition.isEqual(t.precondition) && (!!function __PRIVATE_fieldTransformsAreEqual(e2, t2) {
    return void 0 === e2 && void 0 === t2 || !(!e2 || !t2) && __PRIVATE_arrayEquals(e2, t2, (e3, t3) => __PRIVATE_fieldTransformEquals(e3, t3));
  }(e.fieldTransforms, t.fieldTransforms) && (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)))));
}
class __PRIVATE_SetMutation extends Mutation {
  constructor(e, t, n, r = []) {
    super(), this.key = e, this.value = t, this.precondition = n, this.fieldTransforms = r, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class __PRIVATE_PatchMutation extends Mutation {
  constructor(e, t, n, r, i = []) {
    super(), this.key = e, this.data = t, this.fieldMask = n, this.precondition = r, this.fieldTransforms = i, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
function __PRIVATE_getPatch(e) {
  const t = /* @__PURE__ */ new Map();
  return e.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const r = e.data.field(n);
      t.set(n, r);
    }
  }), t;
}
function __PRIVATE_serverTransformResults(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  __PRIVATE_hardAssert(e.length === n.length, 32656, {
    Ae: n.length,
    Re: e.length
  });
  for (let i = 0; i < n.length; i++) {
    const s = e[i], o = s.transform, _ = t.data.field(s.field);
    r.set(s.field, __PRIVATE_applyTransformOperationToRemoteDocument(o, _, n[i]));
  }
  return r;
}
function __PRIVATE_localTransformResults(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  for (const i of e) {
    const e2 = i.transform, s = n.data.field(i.field);
    r.set(i.field, __PRIVATE_applyTransformOperationToLocalView(e2, s, t));
  }
  return r;
}
class __PRIVATE_DeleteMutation extends Mutation {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class __PRIVATE_VerifyMutation extends Mutation {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MutationBatch {
  /**
   * @param batchId - The unique ID of this mutation batch.
   * @param localWriteTime - The original write time of this mutation.
   * @param baseMutations - Mutations that are used to populate the base
   * values when this mutation is applied locally. This can be used to locally
   * overwrite values that are persisted in the remote document cache. Base
   * mutations are never sent to the backend.
   * @param mutations - The user-provided mutations in this mutation batch.
   * User-provided mutations are applied both locally and remotely on the
   * backend.
   */
  constructor(e, t, n, r) {
    this.batchId = e, this.localWriteTime = t, this.baseMutations = n, this.mutations = r;
  }
  /**
   * Applies all the mutations in this MutationBatch to the specified document
   * to compute the state of the remote document
   *
   * @param document - The document to apply mutations to.
   * @param batchResult - The result of applying the MutationBatch to the
   * backend.
   */
  applyToRemoteDocument(e, t) {
    const n = t.mutationResults;
    for (let t2 = 0; t2 < this.mutations.length; t2++) {
      const r = this.mutations[t2];
      if (r.key.isEqual(e.key)) {
        __PRIVATE_mutationApplyToRemoteDocument(r, e, n[t2]);
      }
    }
  }
  /**
   * Computes the local view of a document given all the mutations in this
   * batch.
   *
   * @param document - The document to apply mutations to.
   * @param mutatedFields - Fields that have been updated before applying this mutation batch.
   * @returns A `FieldMask` representing all the fields that are mutated.
   */
  applyToLocalView(e, t) {
    for (const n of this.baseMutations) n.key.isEqual(e.key) && (t = __PRIVATE_mutationApplyToLocalView(n, e, t, this.localWriteTime));
    for (const n of this.mutations) n.key.isEqual(e.key) && (t = __PRIVATE_mutationApplyToLocalView(n, e, t, this.localWriteTime));
    return t;
  }
  /**
   * Computes the local view for all provided documents given the mutations in
   * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to
   * replace all the mutation applications.
   */
  applyToLocalDocumentSet(e, t) {
    const n = __PRIVATE_newMutationMap();
    return this.mutations.forEach((r) => {
      const i = e.get(r.key), s = i.overlayedDocument;
      let o = this.applyToLocalView(s, i.mutatedFields);
      o = t.has(r.key) ? null : o;
      const _ = __PRIVATE_calculateOverlayMutation(s, o);
      null !== _ && n.set(r.key, _), s.isValidDocument() || s.convertToNoDocument(SnapshotVersion.min());
    }), n;
  }
  keys() {
    return this.mutations.reduce((e, t) => e.add(t.key), __PRIVATE_documentKeySet());
  }
  isEqual(e) {
    return this.batchId === e.batchId && __PRIVATE_arrayEquals(this.mutations, e.mutations, (e2, t) => __PRIVATE_mutationEquals(e2, t)) && __PRIVATE_arrayEquals(this.baseMutations, e.baseMutations, (e2, t) => __PRIVATE_mutationEquals(e2, t));
  }
}
class MutationBatchResult {
  constructor(e, t, n, r) {
    this.batch = e, this.commitVersion = t, this.mutationResults = n, this.docVersions = r;
  }
  /**
   * Creates a new MutationBatchResult for the given batch and results. There
   * must be one result for each mutation in the batch. This static factory
   * caches a document=&gt;version mapping (docVersions).
   */
  static from(e, t, n) {
    __PRIVATE_hardAssert(e.mutations.length === n.length, 58842, {
      Ve: e.mutations.length,
      me: n.length
    });
    let r = /* @__PURE__ */ function __PRIVATE_documentVersionMap() {
      return Rt;
    }();
    const i = e.mutations;
    for (let e2 = 0; e2 < i.length; e2++) r = r.insert(i[e2].key, n[e2].version);
    return new MutationBatchResult(e, t, n, r);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Overlay {
  constructor(e, t) {
    this.largestBatchId = e, this.mutation = t;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(e) {
    return null !== e && this.mutation === e.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ExistenceFilter {
  constructor(e, t) {
    this.count = e, this.unchangedNames = t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ft, gt;
function __PRIVATE_isPermanentError(e) {
  switch (e) {
    case N.OK:
      return fail(64938);
    case N.CANCELLED:
    case N.UNKNOWN:
    case N.DEADLINE_EXCEEDED:
    case N.RESOURCE_EXHAUSTED:
    case N.INTERNAL:
    case N.UNAVAILABLE:
    case N.UNAUTHENTICATED:
      return false;
    case N.INVALID_ARGUMENT:
    case N.NOT_FOUND:
    case N.ALREADY_EXISTS:
    case N.PERMISSION_DENIED:
    case N.FAILED_PRECONDITION:
    case N.ABORTED:
    case N.OUT_OF_RANGE:
    case N.UNIMPLEMENTED:
    case N.DATA_LOSS:
      return true;
    default:
      return fail(15467, {
        code: e
      });
  }
}
function __PRIVATE_mapCodeFromRpcCode(e) {
  if (void 0 === e)
    return __PRIVATE_logError("GRPC error has no .code"), N.UNKNOWN;
  switch (e) {
    case ft.OK:
      return N.OK;
    case ft.CANCELLED:
      return N.CANCELLED;
    case ft.UNKNOWN:
      return N.UNKNOWN;
    case ft.DEADLINE_EXCEEDED:
      return N.DEADLINE_EXCEEDED;
    case ft.RESOURCE_EXHAUSTED:
      return N.RESOURCE_EXHAUSTED;
    case ft.INTERNAL:
      return N.INTERNAL;
    case ft.UNAVAILABLE:
      return N.UNAVAILABLE;
    case ft.UNAUTHENTICATED:
      return N.UNAUTHENTICATED;
    case ft.INVALID_ARGUMENT:
      return N.INVALID_ARGUMENT;
    case ft.NOT_FOUND:
      return N.NOT_FOUND;
    case ft.ALREADY_EXISTS:
      return N.ALREADY_EXISTS;
    case ft.PERMISSION_DENIED:
      return N.PERMISSION_DENIED;
    case ft.FAILED_PRECONDITION:
      return N.FAILED_PRECONDITION;
    case ft.ABORTED:
      return N.ABORTED;
    case ft.OUT_OF_RANGE:
      return N.OUT_OF_RANGE;
    case ft.UNIMPLEMENTED:
      return N.UNIMPLEMENTED;
    case ft.DATA_LOSS:
      return N.DATA_LOSS;
    default:
      return fail(39323, {
        code: e
      });
  }
}
(gt = ft || (ft = {}))[gt.OK = 0] = "OK", gt[gt.CANCELLED = 1] = "CANCELLED", gt[gt.UNKNOWN = 2] = "UNKNOWN", gt[gt.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", gt[gt.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", gt[gt.NOT_FOUND = 5] = "NOT_FOUND", gt[gt.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", gt[gt.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", gt[gt.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", gt[gt.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", gt[gt.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", gt[gt.ABORTED = 10] = "ABORTED", gt[gt.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", gt[gt.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", gt[gt.INTERNAL = 13] = "INTERNAL", gt[gt.UNAVAILABLE = 14] = "UNAVAILABLE", gt[gt.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yt = new Integer([4294967295, 4294967295], 0);
function __PRIVATE_getMd5HashValue(e) {
  const t = __PRIVATE_newTextEncoder().encode(e), n = new Md5();
  return n.update(t), new Uint8Array(n.digest());
}
function __PRIVATE_get64BitUints(e) {
  const t = new DataView(e.buffer), n = t.getUint32(
    0,
    /* littleEndian= */
    true
  ), r = t.getUint32(
    4,
    /* littleEndian= */
    true
  ), i = t.getUint32(
    8,
    /* littleEndian= */
    true
  ), s = t.getUint32(
    12,
    /* littleEndian= */
    true
  );
  return [new Integer([n, r], 0), new Integer([i, s], 0)];
}
class BloomFilter {
  constructor(e, t, n) {
    if (this.bitmap = e, this.padding = t, this.hashCount = n, t < 0 || t >= 8) throw new __PRIVATE_BloomFilterError(`Invalid padding: ${t}`);
    if (n < 0) throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${n}`);
    if (e.length > 0 && 0 === this.hashCount)
      throw new __PRIVATE_BloomFilterError(`Invalid hash count: ${n}`);
    if (0 === e.length && 0 !== t)
      throw new __PRIVATE_BloomFilterError(`Invalid padding when bitmap length is 0: ${t}`);
    this.fe = 8 * e.length - t, // Set the bit count in Integer to avoid repetition in mightContain().
    this.ge = Integer.fromNumber(this.fe);
  }
  // Calculate the ith hash value based on the hashed 64bit integers,
  // and calculate its corresponding bit index in the bitmap to be checked.
  pe(e, t, n) {
    let r = e.add(t.multiply(Integer.fromNumber(n)));
    return 1 === r.compare(yt) && (r = new Integer([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.ge).toNumber();
  }
  // Return whether the bit on the given index in the bitmap is set to 1.
  ye(e) {
    return !!(this.bitmap[Math.floor(e / 8)] & 1 << e % 8);
  }
  mightContain(e) {
    if (0 === this.fe) return false;
    const t = __PRIVATE_getMd5HashValue(e), [n, r] = __PRIVATE_get64BitUints(t);
    for (let e2 = 0; e2 < this.hashCount; e2++) {
      const t2 = this.pe(n, r, e2);
      if (!this.ye(t2)) return false;
    }
    return true;
  }
  /** Create bloom filter for testing purposes only. */
  static create(e, t, n) {
    const r = e % 8 == 0 ? 0 : 8 - e % 8, i = new Uint8Array(Math.ceil(e / 8)), s = new BloomFilter(i, r, t);
    return n.forEach((e2) => s.insert(e2)), s;
  }
  insert(e) {
    if (0 === this.fe) return;
    const t = __PRIVATE_getMd5HashValue(e), [n, r] = __PRIVATE_get64BitUints(t);
    for (let e2 = 0; e2 < this.hashCount; e2++) {
      const t2 = this.pe(n, r, e2);
      this.we(t2);
    }
  }
  we(e) {
    const t = Math.floor(e / 8), n = e % 8;
    this.bitmap[t] |= 1 << n;
  }
}
class __PRIVATE_BloomFilterError extends Error {
  constructor() {
    super(...arguments), this.name = "BloomFilterError";
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RemoteEvent {
  constructor(e, t, n, r, i) {
    this.snapshotVersion = e, this.targetChanges = t, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = i;
  }
  /**
   * HACK: Views require RemoteEvents in order to determine whether the view is
   * CURRENT, but secondary tabs don't receive remote events. So this method is
   * used to create a synthesized RemoteEvent that can be used to apply a
   * CURRENT status change to a View, for queries executed in a different tab.
   */
  // PORTING NOTE: Multi-tab only
  static createSynthesizedRemoteEventForCurrentChange(e, t, n) {
    const r = /* @__PURE__ */ new Map();
    return r.set(e, TargetChange.createSynthesizedTargetChangeForCurrentChange(e, t, n)), new RemoteEvent(SnapshotVersion.min(), r, new SortedMap(__PRIVATE_primitiveComparator), __PRIVATE_mutableDocumentMap(), __PRIVATE_documentKeySet());
  }
}
class TargetChange {
  constructor(e, t, n, r, i) {
    this.resumeToken = e, this.current = t, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = i;
  }
  /**
   * This method is used to create a synthesized TargetChanges that can be used to
   * apply a CURRENT status change to a View (for queries executed in a different
   * tab) or for new queries (to raise snapshots with correct CURRENT status).
   */
  static createSynthesizedTargetChangeForCurrentChange(e, t, n) {
    return new TargetChange(n, t, __PRIVATE_documentKeySet(), __PRIVATE_documentKeySet(), __PRIVATE_documentKeySet());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_DocumentWatchChange {
  constructor(e, t, n, r) {
    this.Se = e, this.removedTargetIds = t, this.key = n, this.be = r;
  }
}
class __PRIVATE_ExistenceFilterChange {
  constructor(e, t) {
    this.targetId = e, this.De = t;
  }
}
class __PRIVATE_WatchTargetChange {
  constructor(e, t, n = ByteString.EMPTY_BYTE_STRING, r = null) {
    this.state = e, this.targetIds = t, this.resumeToken = n, this.cause = r;
  }
}
class __PRIVATE_TargetState {
  constructor() {
    this.ve = 0, /**
     * Keeps track of the document changes since the last raised snapshot.
     *
     * These changes are continuously updated as we receive document updates and
     * always reflect the current set of changes against the last issued snapshot.
     */
    this.Ce = __PRIVATE_snapshotChangesMap(), /** See public getters for explanations of these fields. */
    this.Fe = ByteString.EMPTY_BYTE_STRING, this.Me = false, /**
     * Whether this target state should be included in the next snapshot. We
     * initialize to true so that newly-added targets are included in the next
     * RemoteEvent.
     */
    this.xe = true;
  }
  /**
   * Whether this target has been marked 'current'.
   *
   * 'Current' has special meaning in the RPC protocol: It implies that the
   * Watch backend has sent us all changes up to the point at which the target
   * was added and that the target is consistent with the rest of the watch
   * stream.
   */
  get current() {
    return this.Me;
  }
  /** The last resume token sent to us for this target. */
  get resumeToken() {
    return this.Fe;
  }
  /** Whether this target has pending target adds or target removes. */
  get Oe() {
    return 0 !== this.ve;
  }
  /** Whether we have modified any state that should trigger a snapshot. */
  get Ne() {
    return this.xe;
  }
  /**
   * Applies the resume token to the TargetChange, but only when it has a new
   * value. Empty resumeTokens are discarded.
   */
  Be(e) {
    e.approximateByteSize() > 0 && (this.xe = true, this.Fe = e);
  }
  /**
   * Creates a target change from the current set of changes.
   *
   * To reset the document changes after raising this snapshot, call
   * `clearPendingChanges()`.
   */
  Le() {
    let e = __PRIVATE_documentKeySet(), t = __PRIVATE_documentKeySet(), n = __PRIVATE_documentKeySet();
    return this.Ce.forEach((r, i) => {
      switch (i) {
        case 0:
          e = e.add(r);
          break;
        case 2:
          t = t.add(r);
          break;
        case 1:
          n = n.add(r);
          break;
        default:
          fail(38017, {
            changeType: i
          });
      }
    }), new TargetChange(this.Fe, this.Me, e, t, n);
  }
  /**
   * Resets the document changes and sets `hasPendingChanges` to false.
   */
  ke() {
    this.xe = false, this.Ce = __PRIVATE_snapshotChangesMap();
  }
  qe(e, t) {
    this.xe = true, this.Ce = this.Ce.insert(e, t);
  }
  Qe(e) {
    this.xe = true, this.Ce = this.Ce.remove(e);
  }
  $e() {
    this.ve += 1;
  }
  Ue() {
    this.ve -= 1, __PRIVATE_hardAssert(this.ve >= 0, 3241, {
      ve: this.ve
    });
  }
  Ke() {
    this.xe = true, this.Me = true;
  }
}
class __PRIVATE_WatchChangeAggregator {
  constructor(e) {
    this.We = e, /** The internal state of all tracked targets. */
    this.Ge = /* @__PURE__ */ new Map(), /** Keeps track of the documents to update since the last raised snapshot. */
    this.ze = __PRIVATE_mutableDocumentMap(), this.je = __PRIVATE_documentTargetMap(), /** A mapping of document keys to their set of target IDs. */
    this.Je = __PRIVATE_documentTargetMap(), /**
     * A map of targets with existence filter mismatches. These targets are
     * known to be inconsistent and their listens needs to be re-established by
     * RemoteStore.
     */
    this.He = new SortedMap(__PRIVATE_primitiveComparator);
  }
  /**
   * Processes and adds the DocumentWatchChange to the current set of changes.
   */
  Ye(e) {
    for (const t of e.Se) e.be && e.be.isFoundDocument() ? this.Ze(t, e.be) : this.Xe(t, e.key, e.be);
    for (const t of e.removedTargetIds) this.Xe(t, e.key, e.be);
  }
  /** Processes and adds the WatchTargetChange to the current set of changes. */
  et(e) {
    this.forEachTarget(e, (t) => {
      const n = this.tt(t);
      switch (e.state) {
        case 0:
          this.nt(t) && n.Be(e.resumeToken);
          break;
        case 1:
          n.Ue(), n.Oe || // We have a freshly added target, so we need to reset any state
          // that we had previously. This can happen e.g. when remove and add
          // back a target for existence filter mismatches.
          n.ke(), n.Be(e.resumeToken);
          break;
        case 2:
          n.Ue(), n.Oe || this.removeTarget(t);
          break;
        case 3:
          this.nt(t) && (n.Ke(), n.Be(e.resumeToken));
          break;
        case 4:
          this.nt(t) && // Reset the target and synthesizes removes for all existing
          // documents. The backend will re-add any documents that still
          // match the target before it sends the next global snapshot.
          (this.rt(t), n.Be(e.resumeToken));
          break;
        default:
          fail(56790, {
            state: e.state
          });
      }
    });
  }
  /**
   * Iterates over all targetIds that the watch change applies to: either the
   * targetIds explicitly listed in the change or the targetIds of all currently
   * active targets.
   */
  forEachTarget(e, t) {
    e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.Ge.forEach((e2, n) => {
      this.nt(n) && t(n);
    });
  }
  /**
   * Handles existence filters and synthesizes deletes for filter mismatches.
   * Targets that are invalidated by filter mismatches are added to
   * `pendingTargetResets`.
   */
  it(e) {
    const t = e.targetId, n = e.De.count, r = this.st(t);
    if (r) {
      const i = r.target;
      if (__PRIVATE_targetIsDocumentTarget(i)) if (0 === n) {
        const e2 = new DocumentKey(i.path);
        this.Xe(t, e2, MutableDocument.newNoDocument(e2, SnapshotVersion.min()));
      } else __PRIVATE_hardAssert(1 === n, 20013, {
        expectedCount: n
      });
      else {
        const r2 = this.ot(t);
        if (r2 !== n) {
          const n2 = this._t(e), i2 = n2 ? this.ut(n2, e, r2) : 1;
          if (0 !== i2) {
            this.rt(t);
            const e2 = 2 === i2 ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch";
            this.He = this.He.insert(t, e2);
          }
        }
      }
    }
  }
  /**
   * Parse the bloom filter from the "unchanged_names" field of an existence
   * filter.
   */
  _t(e) {
    const t = e.De.unchangedNames;
    if (!t || !t.bits) return null;
    const { bits: { bitmap: n = "", padding: r = 0 }, hashCount: i = 0 } = t;
    let s, o;
    try {
      s = __PRIVATE_normalizeByteString(n).toUint8Array();
    } catch (e2) {
      if (e2 instanceof __PRIVATE_Base64DecodeError) return __PRIVATE_logWarn("Decoding the base64 bloom filter in existence filter failed (" + e2.message + "); ignoring the bloom filter and falling back to full re-query."), null;
      throw e2;
    }
    try {
      o = new BloomFilter(s, r, i);
    } catch (e2) {
      return __PRIVATE_logWarn(e2 instanceof __PRIVATE_BloomFilterError ? "BloomFilter error: " : "Applying bloom filter failed: ", e2), null;
    }
    return 0 === o.fe ? null : o;
  }
  /**
   * Apply bloom filter to remove the deleted documents, and return the
   * application status.
   */
  ut(e, t, n) {
    return t.De.count === n - this.ht(e, t.targetId) ? 0 : 2;
  }
  /**
   * Filter out removed documents based on bloom filter membership result and
   * return number of documents removed.
   */
  ht(e, t) {
    const n = this.We.getRemoteKeysForTarget(t);
    let r = 0;
    return n.forEach((n2) => {
      const i = this.We.lt(), s = `projects/${i.projectId}/databases/${i.database}/documents/${n2.path.canonicalString()}`;
      e.mightContain(s) || (this.Xe(
        t,
        n2,
        /*updatedDocument=*/
        null
      ), r++);
    }), r;
  }
  /**
   * Converts the currently accumulated state into a remote event at the
   * provided snapshot version. Resets the accumulated changes before returning.
   */
  Pt(e) {
    const t = /* @__PURE__ */ new Map();
    this.Ge.forEach((n2, r2) => {
      const i = this.st(r2);
      if (i) {
        if (n2.current && __PRIVATE_targetIsDocumentTarget(i.target)) {
          const t2 = new DocumentKey(i.target.path);
          this.Tt(t2).has(r2) || this.It(r2, t2) || this.Xe(r2, t2, MutableDocument.newNoDocument(t2, e));
        }
        n2.Ne && (t.set(r2, n2.Le()), n2.ke());
      }
    });
    let n = __PRIVATE_documentKeySet();
    this.Je.forEach((e2, t2) => {
      let r2 = true;
      t2.forEachWhile((e3) => {
        const t3 = this.st(e3);
        return !t3 || "TargetPurposeLimboResolution" === t3.purpose || (r2 = false, false);
      }), r2 && (n = n.add(e2));
    }), this.ze.forEach((t2, n2) => n2.setReadTime(e));
    const r = new RemoteEvent(e, t, this.He, this.ze, n);
    return this.ze = __PRIVATE_mutableDocumentMap(), this.je = __PRIVATE_documentTargetMap(), this.Je = __PRIVATE_documentTargetMap(), this.He = new SortedMap(__PRIVATE_primitiveComparator), r;
  }
  /**
   * Adds the provided document to the internal list of document updates and
   * its document key to the given target's mapping.
   */
  // Visible for testing.
  Ze(e, t) {
    if (!this.nt(e)) return;
    const n = this.It(e, t.key) ? 2 : 0;
    this.tt(e).qe(t.key, n), this.ze = this.ze.insert(t.key, t), this.je = this.je.insert(t.key, this.Tt(t.key).add(e)), this.Je = this.Je.insert(t.key, this.dt(t.key).add(e));
  }
  /**
   * Removes the provided document from the target mapping. If the
   * document no longer matches the target, but the document's state is still
   * known (e.g. we know that the document was deleted or we received the change
   * that caused the filter mismatch), the new document can be provided
   * to update the remote document cache.
   */
  // Visible for testing.
  Xe(e, t, n) {
    if (!this.nt(e)) return;
    const r = this.tt(e);
    this.It(e, t) ? r.qe(
      t,
      1
      /* ChangeType.Removed */
    ) : (
      // The document may have entered and left the target before we raised a
      // snapshot, so we can just ignore the change.
      r.Qe(t)
    ), this.Je = this.Je.insert(t, this.dt(t).delete(e)), this.Je = this.Je.insert(t, this.dt(t).add(e)), n && (this.ze = this.ze.insert(t, n));
  }
  removeTarget(e) {
    this.Ge.delete(e);
  }
  /**
   * Returns the current count of documents in the target. This includes both
   * the number of documents that the LocalStore considers to be part of the
   * target as well as any accumulated changes.
   */
  ot(e) {
    const t = this.tt(e).Le();
    return this.We.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size;
  }
  /**
   * Increment the number of acks needed from watch before we can consider the
   * server to be 'in-sync' with the client's active targets.
   */
  $e(e) {
    this.tt(e).$e();
  }
  tt(e) {
    let t = this.Ge.get(e);
    return t || (t = new __PRIVATE_TargetState(), this.Ge.set(e, t)), t;
  }
  dt(e) {
    let t = this.Je.get(e);
    return t || (t = new SortedSet(__PRIVATE_primitiveComparator), this.Je = this.Je.insert(e, t)), t;
  }
  Tt(e) {
    let t = this.je.get(e);
    return t || (t = new SortedSet(__PRIVATE_primitiveComparator), this.je = this.je.insert(e, t)), t;
  }
  /**
   * Verifies that the user is still interested in this target (by calling
   * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs
   * from watch.
   */
  nt(e) {
    const t = null !== this.st(e);
    return t || __PRIVATE_logDebug("WatchChangeAggregator", "Detected inactive target", e), t;
  }
  /**
   * Returns the TargetData for an active target (i.e. a target that the user
   * is still interested in that has no outstanding target change requests).
   */
  st(e) {
    const t = this.Ge.get(e);
    return t && t.Oe ? null : this.We.Et(e);
  }
  /**
   * Resets the state of a Watch target to its initial state (e.g. sets
   * 'current' to false, clears the resume token and removes its target mapping
   * from all documents).
   */
  rt(e) {
    this.Ge.set(e, new __PRIVATE_TargetState());
    this.We.getRemoteKeysForTarget(e).forEach((t) => {
      this.Xe(
        e,
        t,
        /*updatedDocument=*/
        null
      );
    });
  }
  /**
   * Returns whether the LocalStore considers the document to be part of the
   * specified target.
   */
  It(e, t) {
    return this.We.getRemoteKeysForTarget(e).has(t);
  }
}
function __PRIVATE_documentTargetMap() {
  return new SortedMap(DocumentKey.comparator);
}
function __PRIVATE_snapshotChangesMap() {
  return new SortedMap(DocumentKey.comparator);
}
const wt = /* @__PURE__ */ (() => {
  const e = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return e;
})(), St = /* @__PURE__ */ (() => {
  const e = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return e;
})(), bt = /* @__PURE__ */ (() => {
  const e = {
    and: "AND",
    or: "OR"
  };
  return e;
})();
class JsonProtoSerializer {
  constructor(e, t) {
    this.databaseId = e, this.useProto3Json = t;
  }
}
function __PRIVATE_toInt32Proto(e, t) {
  return e.useProto3Json || __PRIVATE_isNullOrUndefined(t) ? t : {
    value: t
  };
}
function toTimestamp(e, t) {
  if (e.useProto3Json) {
    return `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + t.seconds,
    nanos: t.nanoseconds
  };
}
function __PRIVATE_toBytes(e, t) {
  return e.useProto3Json ? t.toBase64() : t.toUint8Array();
}
function __PRIVATE_toVersion(e, t) {
  return toTimestamp(e, t.toTimestamp());
}
function __PRIVATE_fromVersion(e) {
  return __PRIVATE_hardAssert(!!e, 49232), SnapshotVersion.fromTimestamp(function fromTimestamp(e2) {
    const t = __PRIVATE_normalizeTimestamp(e2);
    return new Timestamp(t.seconds, t.nanos);
  }(e));
}
function __PRIVATE_toResourceName(e, t) {
  return __PRIVATE_toResourcePath(e, t).canonicalString();
}
function __PRIVATE_toResourcePath(e, t) {
  const n = function __PRIVATE_fullyQualifiedPrefixPath(e2) {
    return new ResourcePath(["projects", e2.projectId, "databases", e2.database]);
  }(e).child("documents");
  return void 0 === t ? n : n.child(t);
}
function __PRIVATE_fromResourceName(e) {
  const t = ResourcePath.fromString(e);
  return __PRIVATE_hardAssert(__PRIVATE_isValidResourceName(t), 10190, {
    key: t.toString()
  }), t;
}
function __PRIVATE_toName(e, t) {
  return __PRIVATE_toResourceName(e.databaseId, t.path);
}
function fromName(e, t) {
  const n = __PRIVATE_fromResourceName(t);
  if (n.get(1) !== e.databaseId.projectId) throw new FirestoreError(N.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + e.databaseId.projectId);
  if (n.get(3) !== e.databaseId.database) throw new FirestoreError(N.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + e.databaseId.database);
  return new DocumentKey(__PRIVATE_extractLocalPathFromResourceName(n));
}
function __PRIVATE_toQueryPath(e, t) {
  return __PRIVATE_toResourceName(e.databaseId, t);
}
function __PRIVATE_fromQueryPath(e) {
  const t = __PRIVATE_fromResourceName(e);
  return 4 === t.length ? ResourcePath.emptyPath() : __PRIVATE_extractLocalPathFromResourceName(t);
}
function __PRIVATE_getEncodedDatabaseId(e) {
  return new ResourcePath(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString();
}
function __PRIVATE_extractLocalPathFromResourceName(e) {
  return __PRIVATE_hardAssert(e.length > 4 && "documents" === e.get(4), 29091, {
    key: e.toString()
  }), e.popFirst(5);
}
function __PRIVATE_toMutationDocument(e, t, n) {
  return {
    name: __PRIVATE_toName(e, t),
    fields: n.value.mapValue.fields
  };
}
function __PRIVATE_fromWatchChange(e, t) {
  let n;
  if ("targetChange" in t) {
    t.targetChange;
    const r = function __PRIVATE_fromWatchTargetChangeState(e2) {
      return "NO_CHANGE" === e2 ? 0 : "ADD" === e2 ? 1 : "REMOVE" === e2 ? 2 : "CURRENT" === e2 ? 3 : "RESET" === e2 ? 4 : fail(39313, {
        state: e2
      });
    }(t.targetChange.targetChangeType || "NO_CHANGE"), i = t.targetChange.targetIds || [], s = function __PRIVATE_fromBytes(e2, t2) {
      return e2.useProto3Json ? (__PRIVATE_hardAssert(void 0 === t2 || "string" == typeof t2, 58123), ByteString.fromBase64String(t2 || "")) : (__PRIVATE_hardAssert(void 0 === t2 || // Check if the value is an instance of both Buffer and Uint8Array,
      // despite the fact that Buffer extends Uint8Array. In some
      // environments, such as jsdom, the prototype chain of Buffer
      // does not indicate that it extends Uint8Array.
      t2 instanceof Buffer || t2 instanceof Uint8Array, 16193), ByteString.fromUint8Array(t2 || new Uint8Array()));
    }(e, t.targetChange.resumeToken), o = t.targetChange.cause, _ = o && function __PRIVATE_fromRpcStatus(e2) {
      const t2 = void 0 === e2.code ? N.UNKNOWN : __PRIVATE_mapCodeFromRpcCode(e2.code);
      return new FirestoreError(t2, e2.message || "");
    }(o);
    n = new __PRIVATE_WatchTargetChange(r, i, s, _ || null);
  } else if ("documentChange" in t) {
    t.documentChange;
    const r = t.documentChange;
    r.document, r.document.name, r.document.updateTime;
    const i = fromName(e, r.document.name), s = __PRIVATE_fromVersion(r.document.updateTime), o = r.document.createTime ? __PRIVATE_fromVersion(r.document.createTime) : SnapshotVersion.min(), _ = new ObjectValue({
      mapValue: {
        fields: r.document.fields
      }
    }), a = MutableDocument.newFoundDocument(i, s, o, _), u = r.targetIds || [], c = r.removedTargetIds || [];
    n = new __PRIVATE_DocumentWatchChange(u, c, a.key, a);
  } else if ("documentDelete" in t) {
    t.documentDelete;
    const r = t.documentDelete;
    r.document;
    const i = fromName(e, r.document), s = r.readTime ? __PRIVATE_fromVersion(r.readTime) : SnapshotVersion.min(), o = MutableDocument.newNoDocument(i, s), _ = r.removedTargetIds || [];
    n = new __PRIVATE_DocumentWatchChange([], _, o.key, o);
  } else if ("documentRemove" in t) {
    t.documentRemove;
    const r = t.documentRemove;
    r.document;
    const i = fromName(e, r.document), s = r.removedTargetIds || [];
    n = new __PRIVATE_DocumentWatchChange([], s, i, null);
  } else {
    if (!("filter" in t)) return fail(11601, {
      At: t
    });
    {
      t.filter;
      const e2 = t.filter;
      e2.targetId;
      const { count: r = 0, unchangedNames: i } = e2, s = new ExistenceFilter(r, i), o = e2.targetId;
      n = new __PRIVATE_ExistenceFilterChange(o, s);
    }
  }
  return n;
}
function toMutation(e, t) {
  let n;
  if (t instanceof __PRIVATE_SetMutation) n = {
    update: __PRIVATE_toMutationDocument(e, t.key, t.value)
  };
  else if (t instanceof __PRIVATE_DeleteMutation) n = {
    delete: __PRIVATE_toName(e, t.key)
  };
  else if (t instanceof __PRIVATE_PatchMutation) n = {
    update: __PRIVATE_toMutationDocument(e, t.key, t.data),
    updateMask: __PRIVATE_toDocumentMask(t.fieldMask)
  };
  else {
    if (!(t instanceof __PRIVATE_VerifyMutation)) return fail(16599, {
      Rt: t.type
    });
    n = {
      verify: __PRIVATE_toName(e, t.key)
    };
  }
  return t.fieldTransforms.length > 0 && (n.updateTransforms = t.fieldTransforms.map((e2) => function __PRIVATE_toFieldTransform(e3, t2) {
    const n2 = t2.transform;
    if (n2 instanceof __PRIVATE_ServerTimestampTransform) return {
      fieldPath: t2.field.canonicalString(),
      setToServerValue: "REQUEST_TIME"
    };
    if (n2 instanceof __PRIVATE_ArrayUnionTransformOperation) return {
      fieldPath: t2.field.canonicalString(),
      appendMissingElements: {
        values: n2.elements
      }
    };
    if (n2 instanceof __PRIVATE_ArrayRemoveTransformOperation) return {
      fieldPath: t2.field.canonicalString(),
      removeAllFromArray: {
        values: n2.elements
      }
    };
    if (n2 instanceof __PRIVATE_NumericIncrementTransformOperation) return {
      fieldPath: t2.field.canonicalString(),
      increment: n2.Ee
    };
    throw fail(20930, {
      transform: t2.transform
    });
  }(0, e2))), t.precondition.isNone || (n.currentDocument = function __PRIVATE_toPrecondition(e2, t2) {
    return void 0 !== t2.updateTime ? {
      updateTime: __PRIVATE_toVersion(e2, t2.updateTime)
    } : void 0 !== t2.exists ? {
      exists: t2.exists
    } : fail(27497);
  }(e, t.precondition)), n;
}
function __PRIVATE_fromWriteResults(e, t) {
  return e && e.length > 0 ? (__PRIVATE_hardAssert(void 0 !== t, 14353), e.map((e2) => function __PRIVATE_fromWriteResult(e3, t2) {
    let n = e3.updateTime ? __PRIVATE_fromVersion(e3.updateTime) : __PRIVATE_fromVersion(t2);
    return n.isEqual(SnapshotVersion.min()) && // The Firestore Emulator currently returns an update time of 0 for
    // deletes of non-existing documents (rather than null). This breaks the
    // test "get deleted doc while offline with source=cache" as NoDocuments
    // with version 0 are filtered by IndexedDb's RemoteDocumentCache.
    // TODO(#2149): Remove this when Emulator is fixed
    (n = __PRIVATE_fromVersion(t2)), new MutationResult(n, e3.transformResults || []);
  }(e2, t))) : [];
}
function __PRIVATE_toDocumentsTarget(e, t) {
  return {
    documents: [__PRIVATE_toQueryPath(e, t.path)]
  };
}
function __PRIVATE_toQueryTarget(e, t) {
  const n = {
    structuredQuery: {}
  }, r = t.path;
  let i;
  null !== t.collectionGroup ? (i = r, n.structuredQuery.from = [{
    collectionId: t.collectionGroup,
    allDescendants: true
  }]) : (i = r.popLast(), n.structuredQuery.from = [{
    collectionId: r.lastSegment()
  }]), n.parent = __PRIVATE_toQueryPath(e, i);
  const s = function __PRIVATE_toFilters(e2) {
    if (0 === e2.length) return;
    return __PRIVATE_toFilter(CompositeFilter.create(
      e2,
      "and"
      /* CompositeOperator.AND */
    ));
  }(t.filters);
  s && (n.structuredQuery.where = s);
  const o = function __PRIVATE_toOrder(e2) {
    if (0 === e2.length) return;
    return e2.map((e3) => (
      // visible for testing
      function __PRIVATE_toPropertyOrder(e4) {
        return {
          field: __PRIVATE_toFieldPathReference(e4.field),
          direction: __PRIVATE_toDirection(e4.dir)
        };
      }(e3)
    ));
  }(t.orderBy);
  o && (n.structuredQuery.orderBy = o);
  const _ = __PRIVATE_toInt32Proto(e, t.limit);
  return null !== _ && (n.structuredQuery.limit = _), t.startAt && (n.structuredQuery.startAt = function __PRIVATE_toStartAtCursor(e2) {
    return {
      before: e2.inclusive,
      values: e2.position
    };
  }(t.startAt)), t.endAt && (n.structuredQuery.endAt = function __PRIVATE_toEndAtCursor(e2) {
    return {
      before: !e2.inclusive,
      values: e2.position
    };
  }(t.endAt)), {
    Vt: n,
    parent: i
  };
}
function __PRIVATE_convertQueryTargetToQuery(e) {
  let t = __PRIVATE_fromQueryPath(e.parent);
  const n = e.structuredQuery, r = n.from ? n.from.length : 0;
  let i = null;
  if (r > 0) {
    __PRIVATE_hardAssert(1 === r, 65062);
    const e2 = n.from[0];
    e2.allDescendants ? i = e2.collectionId : t = t.child(e2.collectionId);
  }
  let s = [];
  n.where && (s = function __PRIVATE_fromFilters(e2) {
    const t2 = __PRIVATE_fromFilter(e2);
    if (t2 instanceof CompositeFilter && __PRIVATE_compositeFilterIsFlatConjunction(t2)) return t2.getFilters();
    return [t2];
  }(n.where));
  let o = [];
  n.orderBy && (o = function __PRIVATE_fromOrder(e2) {
    return e2.map((e3) => function __PRIVATE_fromPropertyOrder(e4) {
      return new OrderBy(
        __PRIVATE_fromFieldPathReference(e4.field),
        // visible for testing
        function __PRIVATE_fromDirection(e5) {
          switch (e5) {
            case "ASCENDING":
              return "asc";
            case "DESCENDING":
              return "desc";
            default:
              return;
          }
        }(e4.direction)
      );
    }(e3));
  }(n.orderBy));
  let _ = null;
  n.limit && (_ = function __PRIVATE_fromInt32Proto(e2) {
    let t2;
    return t2 = "object" == typeof e2 ? e2.value : e2, __PRIVATE_isNullOrUndefined(t2) ? null : t2;
  }(n.limit));
  let a = null;
  n.startAt && (a = function __PRIVATE_fromStartAtCursor(e2) {
    const t2 = !!e2.before, n2 = e2.values || [];
    return new Bound(n2, t2);
  }(n.startAt));
  let u = null;
  return n.endAt && (u = function __PRIVATE_fromEndAtCursor(e2) {
    const t2 = !e2.before, n2 = e2.values || [];
    return new Bound(n2, t2);
  }(n.endAt)), __PRIVATE_newQuery(t, i, o, s, _, "F", a, u);
}
function __PRIVATE_toListenRequestLabels(e, t) {
  const n = function __PRIVATE_toLabel(e2) {
    switch (e2) {
      case "TargetPurposeListen":
        return null;
      case "TargetPurposeExistenceFilterMismatch":
        return "existence-filter-mismatch";
      case "TargetPurposeExistenceFilterMismatchBloom":
        return "existence-filter-mismatch-bloom";
      case "TargetPurposeLimboResolution":
        return "limbo-document";
      default:
        return fail(28987, {
          purpose: e2
        });
    }
  }(t.purpose);
  return null == n ? null : {
    "goog-listen-tags": n
  };
}
function __PRIVATE_fromFilter(e) {
  return void 0 !== e.unaryFilter ? function __PRIVATE_fromUnaryFilter(e2) {
    switch (e2.unaryFilter.op) {
      case "IS_NAN":
        const t = __PRIVATE_fromFieldPathReference(e2.unaryFilter.field);
        return FieldFilter.create(t, "==", {
          doubleValue: NaN
        });
      case "IS_NULL":
        const n = __PRIVATE_fromFieldPathReference(e2.unaryFilter.field);
        return FieldFilter.create(n, "==", {
          nullValue: "NULL_VALUE"
        });
      case "IS_NOT_NAN":
        const r = __PRIVATE_fromFieldPathReference(e2.unaryFilter.field);
        return FieldFilter.create(r, "!=", {
          doubleValue: NaN
        });
      case "IS_NOT_NULL":
        const i = __PRIVATE_fromFieldPathReference(e2.unaryFilter.field);
        return FieldFilter.create(i, "!=", {
          nullValue: "NULL_VALUE"
        });
      case "OPERATOR_UNSPECIFIED":
        return fail(61313);
      default:
        return fail(60726);
    }
  }(e) : void 0 !== e.fieldFilter ? function __PRIVATE_fromFieldFilter(e2) {
    return FieldFilter.create(__PRIVATE_fromFieldPathReference(e2.fieldFilter.field), function __PRIVATE_fromOperatorName(e3) {
      switch (e3) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        case "OPERATOR_UNSPECIFIED":
          return fail(58110);
        default:
          return fail(50506);
      }
    }(e2.fieldFilter.op), e2.fieldFilter.value);
  }(e) : void 0 !== e.compositeFilter ? function __PRIVATE_fromCompositeFilter(e2) {
    return CompositeFilter.create(e2.compositeFilter.filters.map((e3) => __PRIVATE_fromFilter(e3)), function __PRIVATE_fromCompositeOperatorName(e3) {
      switch (e3) {
        case "AND":
          return "and";
        case "OR":
          return "or";
        default:
          return fail(1026);
      }
    }(e2.compositeFilter.op));
  }(e) : fail(30097, {
    filter: e
  });
}
function __PRIVATE_toDirection(e) {
  return wt[e];
}
function __PRIVATE_toOperatorName(e) {
  return St[e];
}
function __PRIVATE_toCompositeOperatorName(e) {
  return bt[e];
}
function __PRIVATE_toFieldPathReference(e) {
  return {
    fieldPath: e.canonicalString()
  };
}
function __PRIVATE_fromFieldPathReference(e) {
  return FieldPath$1.fromServerFormat(e.fieldPath);
}
function __PRIVATE_toFilter(e) {
  return e instanceof FieldFilter ? function __PRIVATE_toUnaryOrFieldFilter(e2) {
    if ("==" === e2.op) {
      if (__PRIVATE_isNanValue(e2.value)) return {
        unaryFilter: {
          field: __PRIVATE_toFieldPathReference(e2.field),
          op: "IS_NAN"
        }
      };
      if (__PRIVATE_isNullValue(e2.value)) return {
        unaryFilter: {
          field: __PRIVATE_toFieldPathReference(e2.field),
          op: "IS_NULL"
        }
      };
    } else if ("!=" === e2.op) {
      if (__PRIVATE_isNanValue(e2.value)) return {
        unaryFilter: {
          field: __PRIVATE_toFieldPathReference(e2.field),
          op: "IS_NOT_NAN"
        }
      };
      if (__PRIVATE_isNullValue(e2.value)) return {
        unaryFilter: {
          field: __PRIVATE_toFieldPathReference(e2.field),
          op: "IS_NOT_NULL"
        }
      };
    }
    return {
      fieldFilter: {
        field: __PRIVATE_toFieldPathReference(e2.field),
        op: __PRIVATE_toOperatorName(e2.op),
        value: e2.value
      }
    };
  }(e) : e instanceof CompositeFilter ? function __PRIVATE_toCompositeFilter(e2) {
    const t = e2.getFilters().map((e3) => __PRIVATE_toFilter(e3));
    if (1 === t.length) return t[0];
    return {
      compositeFilter: {
        op: __PRIVATE_toCompositeOperatorName(e2.op),
        filters: t
      }
    };
  }(e) : fail(54877, {
    filter: e
  });
}
function __PRIVATE_toDocumentMask(e) {
  const t = [];
  return e.fields.forEach((e2) => t.push(e2.canonicalString())), {
    fieldPaths: t
  };
}
function __PRIVATE_isValidResourceName(e) {
  return e.length >= 4 && "projects" === e.get(0) && "databases" === e.get(2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TargetData {
  constructor(e, t, n, r, i = SnapshotVersion.min(), s = SnapshotVersion.min(), o = ByteString.EMPTY_BYTE_STRING, _ = null) {
    this.target = e, this.targetId = t, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = s, this.resumeToken = o, this.expectedCount = _;
  }
  /** Creates a new target data instance with an updated sequence number. */
  withSequenceNumber(e) {
    return new TargetData(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);
  }
  /**
   * Creates a new target data instance with an updated resume token and
   * snapshot version.
   */
  withResumeToken(e, t) {
    return new TargetData(
      this.target,
      this.targetId,
      this.purpose,
      this.sequenceNumber,
      t,
      this.lastLimboFreeSnapshotVersion,
      e,
      /* expectedCount= */
      null
    );
  }
  /**
   * Creates a new target data instance with an updated expected count.
   */
  withExpectedCount(e) {
    return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, e);
  }
  /**
   * Creates a new target data instance with an updated last limbo free
   * snapshot version number.
   */
  withLastLimboFreeSnapshotVersion(e) {
    return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_LocalSerializer {
  constructor(e) {
    this.gt = e;
  }
}
function __PRIVATE_fromBundledQuery(e) {
  const t = __PRIVATE_convertQueryTargetToQuery({
    parent: e.parent,
    structuredQuery: e.structuredQuery
  });
  return "LAST" === e.limitType ? __PRIVATE_queryWithLimit(
    t,
    t.limit,
    "L"
    /* LimitType.Last */
  ) : t;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryIndexManager {
  constructor() {
    this.Dn = new __PRIVATE_MemoryCollectionParentIndex();
  }
  addToCollectionParentIndex(e, t) {
    return this.Dn.add(t), PersistencePromise.resolve();
  }
  getCollectionParents(e, t) {
    return PersistencePromise.resolve(this.Dn.getEntries(t));
  }
  addFieldIndex(e, t) {
    return PersistencePromise.resolve();
  }
  deleteFieldIndex(e, t) {
    return PersistencePromise.resolve();
  }
  deleteAllFieldIndexes(e) {
    return PersistencePromise.resolve();
  }
  createTargetIndexes(e, t) {
    return PersistencePromise.resolve();
  }
  getDocumentsMatchingTarget(e, t) {
    return PersistencePromise.resolve(null);
  }
  getIndexType(e, t) {
    return PersistencePromise.resolve(
      0
      /* IndexType.NONE */
    );
  }
  getFieldIndexes(e, t) {
    return PersistencePromise.resolve([]);
  }
  getNextCollectionGroupToUpdate(e) {
    return PersistencePromise.resolve(null);
  }
  getMinOffset(e, t) {
    return PersistencePromise.resolve(IndexOffset.min());
  }
  getMinOffsetFromCollectionGroup(e, t) {
    return PersistencePromise.resolve(IndexOffset.min());
  }
  updateCollectionGroup(e, t, n) {
    return PersistencePromise.resolve();
  }
  updateIndexEntries(e, t) {
    return PersistencePromise.resolve();
  }
}
class __PRIVATE_MemoryCollectionParentIndex {
  constructor() {
    this.index = {};
  }
  // Returns false if the entry already existed.
  add(e) {
    const t = e.lastSegment(), n = e.popLast(), r = this.index[t] || new SortedSet(ResourcePath.comparator), i = !r.has(n);
    return this.index[t] = r.add(n), i;
  }
  has(e) {
    const t = e.lastSegment(), n = e.popLast(), r = this.index[t];
    return r && r.has(n);
  }
  getEntries(e) {
    return (this.index[e] || new SortedSet(ResourcePath.comparator)).toArray();
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ft = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
}, Mt = 41943040;
class LruParams {
  static withCacheSize(e) {
    return new LruParams(e, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
  constructor(e, t, n) {
    this.cacheSizeCollectionThreshold = e, this.percentileToCollect = t, this.maximumSequenceNumbersToCollect = n;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
LruParams.DEFAULT_COLLECTION_PERCENTILE = 10, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, LruParams.DEFAULT = new LruParams(Mt, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), LruParams.DISABLED = new LruParams(-1, 0, 0);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_TargetIdGenerator {
  constructor(e) {
    this._r = e;
  }
  next() {
    return this._r += 2, this._r;
  }
  static ar() {
    return new __PRIVATE_TargetIdGenerator(0);
  }
  static ur() {
    return new __PRIVATE_TargetIdGenerator(-1);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xt = "LruGarbageCollector", Ot = 1048576;
function __PRIVATE_bufferEntryComparator([e, t], [n, r]) {
  const i = __PRIVATE_primitiveComparator(e, n);
  return 0 === i ? __PRIVATE_primitiveComparator(t, r) : i;
}
class __PRIVATE_RollingSequenceNumberBuffer {
  constructor(e) {
    this.Tr = e, this.buffer = new SortedSet(__PRIVATE_bufferEntryComparator), this.Ir = 0;
  }
  dr() {
    return ++this.Ir;
  }
  Er(e) {
    const t = [e, this.dr()];
    if (this.buffer.size < this.Tr) this.buffer = this.buffer.add(t);
    else {
      const e2 = this.buffer.last();
      __PRIVATE_bufferEntryComparator(t, e2) < 0 && (this.buffer = this.buffer.delete(e2).add(t));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
}
class __PRIVATE_LruScheduler {
  constructor(e, t, n) {
    this.garbageCollector = e, this.asyncQueue = t, this.localStore = n, this.Ar = null;
  }
  start() {
    -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Rr(6e4);
  }
  stop() {
    this.Ar && (this.Ar.cancel(), this.Ar = null);
  }
  get started() {
    return null !== this.Ar;
  }
  Rr(e) {
    __PRIVATE_logDebug(xt, `Garbage collection scheduled in ${e}ms`), this.Ar = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.Ar = null;
      try {
        await this.localStore.collectGarbage(this.garbageCollector);
      } catch (e2) {
        __PRIVATE_isIndexedDbTransactionError(e2) ? __PRIVATE_logDebug(xt, "Ignoring IndexedDB error during garbage collection: ", e2) : await __PRIVATE_ignoreIfPrimaryLeaseLoss(e2);
      }
      await this.Rr(3e5);
    });
  }
}
class __PRIVATE_LruGarbageCollectorImpl {
  constructor(e, t) {
    this.Vr = e, this.params = t;
  }
  calculateTargetCount(e, t) {
    return this.Vr.mr(e).next((e2) => Math.floor(t / 100 * e2));
  }
  nthSequenceNumber(e, t) {
    if (0 === t) return PersistencePromise.resolve(__PRIVATE_ListenSequence.ue);
    const n = new __PRIVATE_RollingSequenceNumberBuffer(t);
    return this.Vr.forEachTarget(e, (e2) => n.Er(e2.sequenceNumber)).next(() => this.Vr.gr(e, (e2) => n.Er(e2))).next(() => n.maxValue);
  }
  removeTargets(e, t, n) {
    return this.Vr.removeTargets(e, t, n);
  }
  removeOrphanedDocuments(e, t) {
    return this.Vr.removeOrphanedDocuments(e, t);
  }
  collect(e, t) {
    return -1 === this.params.cacheSizeCollectionThreshold ? (__PRIVATE_logDebug("LruGarbageCollector", "Garbage collection skipped; disabled"), PersistencePromise.resolve(Ft)) : this.getCacheSize(e).next((n) => n < this.params.cacheSizeCollectionThreshold ? (__PRIVATE_logDebug("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), Ft) : this.pr(e, t));
  }
  getCacheSize(e) {
    return this.Vr.getCacheSize(e);
  }
  pr(e, t) {
    let n, r, i, s, o, _, u;
    const c = Date.now();
    return this.calculateTargetCount(e, this.params.percentileToCollect).next((t2) => (
      // Cap at the configured max
      (t2 > this.params.maximumSequenceNumbersToCollect ? (__PRIVATE_logDebug("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t2}`), r = this.params.maximumSequenceNumbersToCollect) : r = t2, s = Date.now(), this.nthSequenceNumber(e, r))
    )).next((r2) => (n = r2, o = Date.now(), this.removeTargets(e, n, t))).next((t2) => (i = t2, _ = Date.now(), this.removeOrphanedDocuments(e, n))).next((e2) => {
      if (u = Date.now(), __PRIVATE_getLogLevel() <= LogLevel.DEBUG) {
        __PRIVATE_logDebug("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${s - c}ms
	Determined least recently used ${r} in ` + (o - s) + `ms
	Removed ${i} targets in ` + (_ - o) + `ms
	Removed ${e2} documents in ` + (u - _) + `ms
Total Duration: ${u - c}ms`);
      }
      return PersistencePromise.resolve({
        didRun: true,
        sequenceNumbersCollected: r,
        targetsRemoved: i,
        documentsRemoved: e2
      });
    });
  }
}
function __PRIVATE_newLruGarbageCollector(e, t) {
  return new __PRIVATE_LruGarbageCollectorImpl(e, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RemoteDocumentChangeBuffer {
  constructor() {
    this.changes = new ObjectMap((e) => e.toString(), (e, t) => e.isEqual(t)), this.changesApplied = false;
  }
  /**
   * Buffers a `RemoteDocumentCache.addEntry()` call.
   *
   * You can only modify documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  addEntry(e) {
    this.assertNotApplied(), this.changes.set(e.key, e);
  }
  /**
   * Buffers a `RemoteDocumentCache.removeEntry()` call.
   *
   * You can only remove documents that have already been retrieved via
   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
   */
  removeEntry(e, t) {
    this.assertNotApplied(), this.changes.set(e, MutableDocument.newInvalidDocument(e).setReadTime(t));
  }
  /**
   * Looks up an entry in the cache. The buffered changes will first be checked,
   * and if no buffered change applies, this will forward to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKey - The key of the entry to look up.
   * @returns The cached document or an invalid document if we have nothing
   * cached.
   */
  getEntry(e, t) {
    this.assertNotApplied();
    const n = this.changes.get(t);
    return void 0 !== n ? PersistencePromise.resolve(n) : this.getFromCache(e, t);
  }
  /**
   * Looks up several entries in the cache, forwarding to
   * `RemoteDocumentCache.getEntry()`.
   *
   * @param transaction - The transaction in which to perform any persistence
   *     operations.
   * @param documentKeys - The keys of the entries to look up.
   * @returns A map of cached documents, indexed by key. If an entry cannot be
   *     found, the corresponding key will be mapped to an invalid document.
   */
  getEntries(e, t) {
    return this.getAllFromCache(e, t);
  }
  /**
   * Applies buffered changes to the underlying RemoteDocumentCache, using
   * the provided transaction.
   */
  apply(e) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(e);
  }
  /** Helper to assert this.changes is not null  */
  assertNotApplied() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OverlayedDocument {
  constructor(e, t) {
    this.overlayedDocument = e, this.mutatedFields = t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LocalDocumentsView {
  constructor(e, t, n, r) {
    this.remoteDocumentCache = e, this.mutationQueue = t, this.documentOverlayCache = n, this.indexManager = r;
  }
  /**
   * Get the local view of the document identified by `key`.
   *
   * @returns Local view of the document or null if we don't have any cached
   * state for it.
   */
  getDocument(e, t) {
    let n = null;
    return this.documentOverlayCache.getOverlay(e, t).next((r) => (n = r, this.remoteDocumentCache.getEntry(e, t))).next((e2) => (null !== n && __PRIVATE_mutationApplyToLocalView(n.mutation, e2, FieldMask.empty(), Timestamp.now()), e2));
  }
  /**
   * Gets the local view of the documents identified by `keys`.
   *
   * If we don't have cached state for a document in `keys`, a NoDocument will
   * be stored for that key in the resulting set.
   */
  getDocuments(e, t) {
    return this.remoteDocumentCache.getEntries(e, t).next((t2) => this.getLocalViewOfDocuments(e, t2, __PRIVATE_documentKeySet()).next(() => t2));
  }
  /**
   * Similar to `getDocuments`, but creates the local view from the given
   * `baseDocs` without retrieving documents from the local store.
   *
   * @param transaction - The transaction this operation is scoped to.
   * @param docs - The documents to apply local mutations to get the local views.
   * @param existenceStateChanged - The set of document keys whose existence state
   *   is changed. This is useful to determine if some documents overlay needs
   *   to be recalculated.
   */
  getLocalViewOfDocuments(e, t, n = __PRIVATE_documentKeySet()) {
    const r = __PRIVATE_newOverlayMap();
    return this.populateOverlays(e, r, t).next(() => this.computeViews(e, t, r, n).next((e2) => {
      let t2 = documentMap();
      return e2.forEach((e3, n2) => {
        t2 = t2.insert(e3, n2.overlayedDocument);
      }), t2;
    }));
  }
  /**
   * Gets the overlayed documents for the given document map, which will include
   * the local view of those documents and a `FieldMask` indicating which fields
   * are mutated locally, `null` if overlay is a Set or Delete mutation.
   */
  getOverlayedDocuments(e, t) {
    const n = __PRIVATE_newOverlayMap();
    return this.populateOverlays(e, n, t).next(() => this.computeViews(e, t, n, __PRIVATE_documentKeySet()));
  }
  /**
   * Fetches the overlays for {@code docs} and adds them to provided overlay map
   * if the map does not already contain an entry for the given document key.
   */
  populateOverlays(e, t, n) {
    const r = [];
    return n.forEach((e2) => {
      t.has(e2) || r.push(e2);
    }), this.documentOverlayCache.getOverlays(e, r).next((e2) => {
      e2.forEach((e3, n2) => {
        t.set(e3, n2);
      });
    });
  }
  /**
   * Computes the local view for the given documents.
   *
   * @param docs - The documents to compute views for. It also has the base
   *   version of the documents.
   * @param overlays - The overlays that need to be applied to the given base
   *   version of the documents.
   * @param existenceStateChanged - A set of documents whose existence states
   *   might have changed. This is used to determine if we need to re-calculate
   *   overlays from mutation queues.
   * @return A map represents the local documents view.
   */
  computeViews(e, t, n, r) {
    let i = __PRIVATE_mutableDocumentMap();
    const s = __PRIVATE_newDocumentKeyMap(), o = function __PRIVATE_newOverlayedDocumentMap() {
      return __PRIVATE_newDocumentKeyMap();
    }();
    return t.forEach((e2, t2) => {
      const o2 = n.get(t2.key);
      r.has(t2.key) && (void 0 === o2 || o2.mutation instanceof __PRIVATE_PatchMutation) ? i = i.insert(t2.key, t2) : void 0 !== o2 ? (s.set(t2.key, o2.mutation.getFieldMask()), __PRIVATE_mutationApplyToLocalView(o2.mutation, t2, o2.mutation.getFieldMask(), Timestamp.now())) : (
        // no overlay exists
        // Using EMPTY to indicate there is no overlay for the document.
        s.set(t2.key, FieldMask.empty())
      );
    }), this.recalculateAndSaveOverlays(e, i).next((e2) => (e2.forEach((e3, t2) => s.set(e3, t2)), t.forEach((e3, t2) => {
      var n2;
      return o.set(e3, new OverlayedDocument(t2, null !== (n2 = s.get(e3)) && void 0 !== n2 ? n2 : null));
    }), o));
  }
  recalculateAndSaveOverlays(e, t) {
    const n = __PRIVATE_newDocumentKeyMap();
    let r = new SortedMap((e2, t2) => e2 - t2), i = __PRIVATE_documentKeySet();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next((e2) => {
      for (const i2 of e2) i2.keys().forEach((e3) => {
        const s = t.get(e3);
        if (null === s) return;
        let o = n.get(e3) || FieldMask.empty();
        o = i2.applyToLocalView(s, o), n.set(e3, o);
        const _ = (r.get(i2.batchId) || __PRIVATE_documentKeySet()).add(e3);
        r = r.insert(i2.batchId, _);
      });
    }).next(() => {
      const s = [], o = r.getReverseIterator();
      for (; o.hasNext(); ) {
        const r2 = o.getNext(), _ = r2.key, a = r2.value, u = __PRIVATE_newMutationMap();
        a.forEach((e2) => {
          if (!i.has(e2)) {
            const r3 = __PRIVATE_calculateOverlayMutation(t.get(e2), n.get(e2));
            null !== r3 && u.set(e2, r3), i = i.add(e2);
          }
        }), s.push(this.documentOverlayCache.saveOverlays(e, _, u));
      }
      return PersistencePromise.waitFor(s);
    }).next(() => n);
  }
  /**
   * Recalculates overlays by reading the documents from remote document cache
   * first, and saves them after they are calculated.
   */
  recalculateAndSaveOverlaysForDocumentKeys(e, t) {
    return this.remoteDocumentCache.getEntries(e, t).next((t2) => this.recalculateAndSaveOverlays(e, t2));
  }
  /**
   * Performs a query against the local view of all documents.
   *
   * @param transaction - The persistence transaction.
   * @param query - The query to match documents against.
   * @param offset - Read time and key to start scanning by (exclusive).
   * @param context - A optional tracker to keep a record of important details
   *   during database local query execution.
   */
  getDocumentsMatchingQuery(e, t, n, r) {
    return function __PRIVATE_isDocumentQuery$1(e2) {
      return DocumentKey.isDocumentKey(e2.path) && null === e2.collectionGroup && 0 === e2.filters.length;
    }(t) ? this.getDocumentsMatchingDocumentQuery(e, t.path) : __PRIVATE_isCollectionGroupQuery(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, n, r) : this.getDocumentsMatchingCollectionQuery(e, t, n, r);
  }
  /**
   * Given a collection group, returns the next documents that follow the provided offset, along
   * with an updated batch ID.
   *
   * <p>The documents returned by this method are ordered by remote version from the provided
   * offset. If there are no more remote documents after the provided offset, documents with
   * mutations in order of batch id from the offset are returned. Since all documents in a batch are
   * returned together, the total number of documents returned can exceed {@code count}.
   *
   * @param transaction
   * @param collectionGroup The collection group for the documents.
   * @param offset The offset to index into.
   * @param count The number of documents to return
   * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.
   */
  getNextDocuments(e, t, n, r) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, n, r).next((i) => {
      const s = r - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, n.largestBatchId, r - i.size) : PersistencePromise.resolve(__PRIVATE_newOverlayMap());
      let o = Q, _ = i;
      return s.next((t2) => PersistencePromise.forEach(t2, (t3, n2) => (o < n2.largestBatchId && (o = n2.largestBatchId), i.get(t3) ? PersistencePromise.resolve() : this.remoteDocumentCache.getEntry(e, t3).next((e2) => {
        _ = _.insert(t3, e2);
      }))).next(() => this.populateOverlays(e, t2, i)).next(() => this.computeViews(e, _, t2, __PRIVATE_documentKeySet())).next((e2) => ({
        batchId: o,
        changes: __PRIVATE_convertOverlayedDocumentMapToDocumentMap(e2)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(e, t) {
    return this.getDocument(e, new DocumentKey(t)).next((e2) => {
      let t2 = documentMap();
      return e2.isFoundDocument() && (t2 = t2.insert(e2.key, e2)), t2;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(e, t, n, r) {
    const i = t.collectionGroup;
    let s = documentMap();
    return this.indexManager.getCollectionParents(e, i).next((o) => PersistencePromise.forEach(o, (o2) => {
      const _ = function __PRIVATE_asCollectionQueryAtPath(e2, t2) {
        return new __PRIVATE_QueryImpl(
          t2,
          /*collectionGroup=*/
          null,
          e2.explicitOrderBy.slice(),
          e2.filters.slice(),
          e2.limit,
          e2.limitType,
          e2.startAt,
          e2.endAt
        );
      }(t, o2.child(i));
      return this.getDocumentsMatchingCollectionQuery(e, _, n, r).next((e2) => {
        e2.forEach((e3, t2) => {
          s = s.insert(e3, t2);
        });
      });
    }).next(() => s));
  }
  getDocumentsMatchingCollectionQuery(e, t, n, r) {
    let i;
    return this.documentOverlayCache.getOverlaysForCollection(e, t.path, n.largestBatchId).next((s) => (i = s, this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, n, i, r))).next((e2) => {
      i.forEach((t2, n3) => {
        const r2 = n3.getKey();
        null === e2.get(r2) && (e2 = e2.insert(r2, MutableDocument.newInvalidDocument(r2)));
      });
      let n2 = documentMap();
      return e2.forEach((e3, r2) => {
        const s = i.get(e3);
        void 0 !== s && __PRIVATE_mutationApplyToLocalView(s.mutation, r2, FieldMask.empty(), Timestamp.now()), // Finally, insert the documents that still match the query
        __PRIVATE_queryMatches(t, r2) && (n2 = n2.insert(e3, r2));
      }), n2;
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryBundleCache {
  constructor(e) {
    this.serializer = e, this.Br = /* @__PURE__ */ new Map(), this.Lr = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(e, t) {
    return PersistencePromise.resolve(this.Br.get(t));
  }
  saveBundleMetadata(e, t) {
    return this.Br.set(
      t.id,
      /** Decodes a BundleMetadata proto into a BundleMetadata object. */
      function __PRIVATE_fromBundleMetadata(e2) {
        return {
          id: e2.id,
          version: e2.version,
          createTime: __PRIVATE_fromVersion(e2.createTime)
        };
      }(t)
    ), PersistencePromise.resolve();
  }
  getNamedQuery(e, t) {
    return PersistencePromise.resolve(this.Lr.get(t));
  }
  saveNamedQuery(e, t) {
    return this.Lr.set(t.name, function __PRIVATE_fromProtoNamedQuery(e2) {
      return {
        name: e2.name,
        query: __PRIVATE_fromBundledQuery(e2.bundledQuery),
        readTime: __PRIVATE_fromVersion(e2.readTime)
      };
    }(t)), PersistencePromise.resolve();
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryDocumentOverlayCache {
  constructor() {
    this.overlays = new SortedMap(DocumentKey.comparator), this.kr = /* @__PURE__ */ new Map();
  }
  getOverlay(e, t) {
    return PersistencePromise.resolve(this.overlays.get(t));
  }
  getOverlays(e, t) {
    const n = __PRIVATE_newOverlayMap();
    return PersistencePromise.forEach(t, (t2) => this.getOverlay(e, t2).next((e2) => {
      null !== e2 && n.set(t2, e2);
    })).next(() => n);
  }
  saveOverlays(e, t, n) {
    return n.forEach((n2, r) => {
      this.wt(e, t, r);
    }), PersistencePromise.resolve();
  }
  removeOverlaysForBatchId(e, t, n) {
    const r = this.kr.get(n);
    return void 0 !== r && (r.forEach((e2) => this.overlays = this.overlays.remove(e2)), this.kr.delete(n)), PersistencePromise.resolve();
  }
  getOverlaysForCollection(e, t, n) {
    const r = __PRIVATE_newOverlayMap(), i = t.length + 1, s = new DocumentKey(t.child("")), o = this.overlays.getIteratorFrom(s);
    for (; o.hasNext(); ) {
      const e2 = o.getNext().value, s2 = e2.getKey();
      if (!t.isPrefixOf(s2.path)) break;
      s2.path.length === i && (e2.largestBatchId > n && r.set(e2.getKey(), e2));
    }
    return PersistencePromise.resolve(r);
  }
  getOverlaysForCollectionGroup(e, t, n, r) {
    let i = new SortedMap((e2, t2) => e2 - t2);
    const s = this.overlays.getIterator();
    for (; s.hasNext(); ) {
      const e2 = s.getNext().value;
      if (e2.getKey().getCollectionGroup() === t && e2.largestBatchId > n) {
        let t2 = i.get(e2.largestBatchId);
        null === t2 && (t2 = __PRIVATE_newOverlayMap(), i = i.insert(e2.largestBatchId, t2)), t2.set(e2.getKey(), e2);
      }
    }
    const o = __PRIVATE_newOverlayMap(), _ = i.getIterator();
    for (; _.hasNext(); ) {
      if (_.getNext().value.forEach((e2, t2) => o.set(e2, t2)), o.size() >= r) break;
    }
    return PersistencePromise.resolve(o);
  }
  wt(e, t, n) {
    const r = this.overlays.get(n.key);
    if (null !== r) {
      const e2 = this.kr.get(r.largestBatchId).delete(n.key);
      this.kr.set(r.largestBatchId, e2);
    }
    this.overlays = this.overlays.insert(n.key, new Overlay(t, n));
    let i = this.kr.get(t);
    void 0 === i && (i = __PRIVATE_documentKeySet(), this.kr.set(t, i)), this.kr.set(t, i.add(n.key));
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryGlobalsCache {
  constructor() {
    this.sessionToken = ByteString.EMPTY_BYTE_STRING;
  }
  getSessionToken(e) {
    return PersistencePromise.resolve(this.sessionToken);
  }
  setSessionToken(e, t) {
    return this.sessionToken = t, PersistencePromise.resolve();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_ReferenceSet {
  constructor() {
    this.qr = new SortedSet(__PRIVATE_DocReference.Qr), // A set of outstanding references to a document sorted by target id.
    this.$r = new SortedSet(__PRIVATE_DocReference.Ur);
  }
  /** Returns true if the reference set contains no references. */
  isEmpty() {
    return this.qr.isEmpty();
  }
  /** Adds a reference to the given document key for the given ID. */
  addReference(e, t) {
    const n = new __PRIVATE_DocReference(e, t);
    this.qr = this.qr.add(n), this.$r = this.$r.add(n);
  }
  /** Add references to the given document keys for the given ID. */
  Kr(e, t) {
    e.forEach((e2) => this.addReference(e2, t));
  }
  /**
   * Removes a reference to the given document key for the given
   * ID.
   */
  removeReference(e, t) {
    this.Wr(new __PRIVATE_DocReference(e, t));
  }
  Gr(e, t) {
    e.forEach((e2) => this.removeReference(e2, t));
  }
  /**
   * Clears all references with a given ID. Calls removeRef() for each key
   * removed.
   */
  zr(e) {
    const t = new DocumentKey(new ResourcePath([])), n = new __PRIVATE_DocReference(t, e), r = new __PRIVATE_DocReference(t, e + 1), i = [];
    return this.$r.forEachInRange([n, r], (e2) => {
      this.Wr(e2), i.push(e2.key);
    }), i;
  }
  jr() {
    this.qr.forEach((e) => this.Wr(e));
  }
  Wr(e) {
    this.qr = this.qr.delete(e), this.$r = this.$r.delete(e);
  }
  Jr(e) {
    const t = new DocumentKey(new ResourcePath([])), n = new __PRIVATE_DocReference(t, e), r = new __PRIVATE_DocReference(t, e + 1);
    let i = __PRIVATE_documentKeySet();
    return this.$r.forEachInRange([n, r], (e2) => {
      i = i.add(e2.key);
    }), i;
  }
  containsKey(e) {
    const t = new __PRIVATE_DocReference(e, 0), n = this.qr.firstAfterOrEqual(t);
    return null !== n && e.isEqual(n.key);
  }
}
class __PRIVATE_DocReference {
  constructor(e, t) {
    this.key = e, this.Hr = t;
  }
  /** Compare by key then by ID */
  static Qr(e, t) {
    return DocumentKey.comparator(e.key, t.key) || __PRIVATE_primitiveComparator(e.Hr, t.Hr);
  }
  /** Compare by ID then by key */
  static Ur(e, t) {
    return __PRIVATE_primitiveComparator(e.Hr, t.Hr) || DocumentKey.comparator(e.key, t.key);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryMutationQueue {
  constructor(e, t) {
    this.indexManager = e, this.referenceDelegate = t, /**
     * The set of all mutations that have been sent but not yet been applied to
     * the backend.
     */
    this.mutationQueue = [], /** Next value to use when assigning sequential IDs to each mutation batch. */
    this.er = 1, /** An ordered mapping between documents and the mutations batch IDs. */
    this.Yr = new SortedSet(__PRIVATE_DocReference.Qr);
  }
  checkEmpty(e) {
    return PersistencePromise.resolve(0 === this.mutationQueue.length);
  }
  addMutationBatch(e, t, n, r) {
    const i = this.er;
    this.er++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const s = new MutationBatch(i, t, n, r);
    this.mutationQueue.push(s);
    for (const t2 of r) this.Yr = this.Yr.add(new __PRIVATE_DocReference(t2.key, i)), this.indexManager.addToCollectionParentIndex(e, t2.key.path.popLast());
    return PersistencePromise.resolve(s);
  }
  lookupMutationBatch(e, t) {
    return PersistencePromise.resolve(this.Zr(t));
  }
  getNextMutationBatchAfterBatchId(e, t) {
    const n = t + 1, r = this.Xr(n), i = r < 0 ? 0 : r;
    return PersistencePromise.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return PersistencePromise.resolve(0 === this.mutationQueue.length ? G : this.er - 1);
  }
  getAllMutationBatches(e) {
    return PersistencePromise.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(e, t) {
    const n = new __PRIVATE_DocReference(t, 0), r = new __PRIVATE_DocReference(t, Number.POSITIVE_INFINITY), i = [];
    return this.Yr.forEachInRange([n, r], (e2) => {
      const t2 = this.Zr(e2.Hr);
      i.push(t2);
    }), PersistencePromise.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(e, t) {
    let n = new SortedSet(__PRIVATE_primitiveComparator);
    return t.forEach((e2) => {
      const t2 = new __PRIVATE_DocReference(e2, 0), r = new __PRIVATE_DocReference(e2, Number.POSITIVE_INFINITY);
      this.Yr.forEachInRange([t2, r], (e3) => {
        n = n.add(e3.Hr);
      });
    }), PersistencePromise.resolve(this.ei(n));
  }
  getAllMutationBatchesAffectingQuery(e, t) {
    const n = t.path, r = n.length + 1;
    let i = n;
    DocumentKey.isDocumentKey(i) || (i = i.child(""));
    const s = new __PRIVATE_DocReference(new DocumentKey(i), 0);
    let o = new SortedSet(__PRIVATE_primitiveComparator);
    return this.Yr.forEachWhile((e2) => {
      const t2 = e2.key.path;
      return !!n.isPrefixOf(t2) && // Rows with document keys more than one segment longer than the query
      // path can't be matches. For example, a query on 'rooms' can't match
      // the document /rooms/abc/messages/xyx.
      // TODO(mcg): we'll need a different scanner when we implement
      // ancestor queries.
      (t2.length === r && (o = o.add(e2.Hr)), true);
    }, s), PersistencePromise.resolve(this.ei(o));
  }
  ei(e) {
    const t = [];
    return e.forEach((e2) => {
      const n = this.Zr(e2);
      null !== n && t.push(n);
    }), t;
  }
  removeMutationBatch(e, t) {
    __PRIVATE_hardAssert(0 === this.ti(t.batchId, "removed"), 55003), this.mutationQueue.shift();
    let n = this.Yr;
    return PersistencePromise.forEach(t.mutations, (r) => {
      const i = new __PRIVATE_DocReference(r.key, t.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(e, r.key);
    }).next(() => {
      this.Yr = n;
    });
  }
  rr(e) {
  }
  containsKey(e, t) {
    const n = new __PRIVATE_DocReference(t, 0), r = this.Yr.firstAfterOrEqual(n);
    return PersistencePromise.resolve(t.isEqual(r && r.key));
  }
  performConsistencyCheck(e) {
    return this.mutationQueue.length, PersistencePromise.resolve();
  }
  /**
   * Finds the index of the given batchId in the mutation queue and asserts that
   * the resulting index is within the bounds of the queue.
   *
   * @param batchId - The batchId to search for
   * @param action - A description of what the caller is doing, phrased in passive
   * form (e.g. "acknowledged" in a routine that acknowledges batches).
   */
  ti(e, t) {
    return this.Xr(e);
  }
  /**
   * Finds the index of the given batchId in the mutation queue. This operation
   * is O(1).
   *
   * @returns The computed index of the batch with the given batchId, based on
   * the state of the queue. Note this index can be negative if the requested
   * batchId has already been removed from the queue or past the end of the
   * queue if the batchId is larger than the last added batch.
   */
  Xr(e) {
    if (0 === this.mutationQueue.length)
      return 0;
    return e - this.mutationQueue[0].batchId;
  }
  /**
   * A version of lookupMutationBatch that doesn't return a promise, this makes
   * other functions that uses this code easier to read and more efficient.
   */
  Zr(e) {
    const t = this.Xr(e);
    if (t < 0 || t >= this.mutationQueue.length) return null;
    return this.mutationQueue[t];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryRemoteDocumentCacheImpl {
  /**
   * @param sizer - Used to assess the size of a document. For eager GC, this is
   * expected to just return 0 to avoid unnecessarily doing the work of
   * calculating the size.
   */
  constructor(e) {
    this.ni = e, /** Underlying cache of documents and their read times. */
    this.docs = function __PRIVATE_documentEntryMap() {
      return new SortedMap(DocumentKey.comparator);
    }(), /** Size of all cached documents. */
    this.size = 0;
  }
  setIndexManager(e) {
    this.indexManager = e;
  }
  /**
   * Adds the supplied entry to the cache and updates the cache size as appropriate.
   *
   * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  addEntry(e, t) {
    const n = t.key, r = this.docs.get(n), i = r ? r.size : 0, s = this.ni(t);
    return this.docs = this.docs.insert(n, {
      document: t.mutableCopy(),
      size: s
    }), this.size += s - i, this.indexManager.addToCollectionParentIndex(e, n.path.popLast());
  }
  /**
   * Removes the specified entry from the cache and updates the cache size as appropriate.
   *
   * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
   * returned by `newChangeBuffer()`.
   */
  removeEntry(e) {
    const t = this.docs.get(e);
    t && (this.docs = this.docs.remove(e), this.size -= t.size);
  }
  getEntry(e, t) {
    const n = this.docs.get(t);
    return PersistencePromise.resolve(n ? n.document.mutableCopy() : MutableDocument.newInvalidDocument(t));
  }
  getEntries(e, t) {
    let n = __PRIVATE_mutableDocumentMap();
    return t.forEach((e2) => {
      const t2 = this.docs.get(e2);
      n = n.insert(e2, t2 ? t2.document.mutableCopy() : MutableDocument.newInvalidDocument(e2));
    }), PersistencePromise.resolve(n);
  }
  getDocumentsMatchingQuery(e, t, n, r) {
    let i = __PRIVATE_mutableDocumentMap();
    const s = t.path, o = new DocumentKey(s.child("__id-9223372036854775808__")), _ = this.docs.getIteratorFrom(o);
    for (; _.hasNext(); ) {
      const { key: e2, value: { document: o2 } } = _.getNext();
      if (!s.isPrefixOf(e2.path)) break;
      e2.path.length > s.length + 1 || (__PRIVATE_indexOffsetComparator(__PRIVATE_newIndexOffsetFromDocument(o2), n) <= 0 || (r.has(o2.key) || __PRIVATE_queryMatches(t, o2)) && (i = i.insert(o2.key, o2.mutableCopy())));
    }
    return PersistencePromise.resolve(i);
  }
  getAllFromCollectionGroup(e, t, n, r) {
    fail(9500);
  }
  ri(e, t) {
    return PersistencePromise.forEach(this.docs, (e2) => t(e2));
  }
  newChangeBuffer(e) {
    return new __PRIVATE_MemoryRemoteDocumentChangeBuffer(this);
  }
  getSize(e) {
    return PersistencePromise.resolve(this.size);
  }
}
class __PRIVATE_MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {
  constructor(e) {
    super(), this.Or = e;
  }
  applyChanges(e) {
    const t = [];
    return this.changes.forEach((n, r) => {
      r.isValidDocument() ? t.push(this.Or.addEntry(e, r)) : this.Or.removeEntry(n);
    }), PersistencePromise.waitFor(t);
  }
  getFromCache(e, t) {
    return this.Or.getEntry(e, t);
  }
  getAllFromCache(e, t) {
    return this.Or.getEntries(e, t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryTargetCache {
  constructor(e) {
    this.persistence = e, /**
     * Maps a target to the data about that target
     */
    this.ii = new ObjectMap((e2) => __PRIVATE_canonifyTarget(e2), __PRIVATE_targetEquals), /** The last received snapshot version. */
    this.lastRemoteSnapshotVersion = SnapshotVersion.min(), /** The highest numbered target ID encountered. */
    this.highestTargetId = 0, /** The highest sequence number encountered. */
    this.si = 0, /**
     * A ordered bidirectional mapping between documents and the remote target
     * IDs.
     */
    this.oi = new __PRIVATE_ReferenceSet(), this.targetCount = 0, this._i = __PRIVATE_TargetIdGenerator.ar();
  }
  forEachTarget(e, t) {
    return this.ii.forEach((e2, n) => t(n)), PersistencePromise.resolve();
  }
  getLastRemoteSnapshotVersion(e) {
    return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(e) {
    return PersistencePromise.resolve(this.si);
  }
  allocateTargetId(e) {
    return this.highestTargetId = this._i.next(), PersistencePromise.resolve(this.highestTargetId);
  }
  setTargetsMetadata(e, t, n) {
    return n && (this.lastRemoteSnapshotVersion = n), t > this.si && (this.si = t), PersistencePromise.resolve();
  }
  hr(e) {
    this.ii.set(e.target, e);
    const t = e.targetId;
    t > this.highestTargetId && (this._i = new __PRIVATE_TargetIdGenerator(t), this.highestTargetId = t), e.sequenceNumber > this.si && (this.si = e.sequenceNumber);
  }
  addTargetData(e, t) {
    return this.hr(t), this.targetCount += 1, PersistencePromise.resolve();
  }
  updateTargetData(e, t) {
    return this.hr(t), PersistencePromise.resolve();
  }
  removeTargetData(e, t) {
    return this.ii.delete(t.target), this.oi.zr(t.targetId), this.targetCount -= 1, PersistencePromise.resolve();
  }
  removeTargets(e, t, n) {
    let r = 0;
    const i = [];
    return this.ii.forEach((s, o) => {
      o.sequenceNumber <= t && null === n.get(o.targetId) && (this.ii.delete(s), i.push(this.removeMatchingKeysForTargetId(e, o.targetId)), r++);
    }), PersistencePromise.waitFor(i).next(() => r);
  }
  getTargetCount(e) {
    return PersistencePromise.resolve(this.targetCount);
  }
  getTargetData(e, t) {
    const n = this.ii.get(t) || null;
    return PersistencePromise.resolve(n);
  }
  addMatchingKeys(e, t, n) {
    return this.oi.Kr(t, n), PersistencePromise.resolve();
  }
  removeMatchingKeys(e, t, n) {
    this.oi.Gr(t, n);
    const r = this.persistence.referenceDelegate, i = [];
    return r && t.forEach((t2) => {
      i.push(r.markPotentiallyOrphaned(e, t2));
    }), PersistencePromise.waitFor(i);
  }
  removeMatchingKeysForTargetId(e, t) {
    return this.oi.zr(t), PersistencePromise.resolve();
  }
  getMatchingKeysForTargetId(e, t) {
    const n = this.oi.Jr(t);
    return PersistencePromise.resolve(n);
  }
  containsKey(e, t) {
    return PersistencePromise.resolve(this.oi.containsKey(t));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_MemoryPersistence {
  /**
   * The constructor accepts a factory for creating a reference delegate. This
   * allows both the delegate and this instance to have strong references to
   * each other without having nullable fields that would then need to be
   * checked or asserted on every access.
   */
  constructor(e, t) {
    this.ai = {}, this.overlays = {}, this.ui = new __PRIVATE_ListenSequence(0), this.ci = false, this.ci = true, this.li = new __PRIVATE_MemoryGlobalsCache(), this.referenceDelegate = e(this), this.hi = new __PRIVATE_MemoryTargetCache(this);
    this.indexManager = new __PRIVATE_MemoryIndexManager(), this.remoteDocumentCache = function __PRIVATE_newMemoryRemoteDocumentCache(e2) {
      return new __PRIVATE_MemoryRemoteDocumentCacheImpl(e2);
    }((e2) => this.referenceDelegate.Pi(e2)), this.serializer = new __PRIVATE_LocalSerializer(t), this.Ti = new __PRIVATE_MemoryBundleCache(this.serializer);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.ci = false, Promise.resolve();
  }
  get started() {
    return this.ci;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(e) {
    return this.indexManager;
  }
  getDocumentOverlayCache(e) {
    let t = this.overlays[e.toKey()];
    return t || (t = new __PRIVATE_MemoryDocumentOverlayCache(), this.overlays[e.toKey()] = t), t;
  }
  getMutationQueue(e, t) {
    let n = this.ai[e.toKey()];
    return n || (n = new __PRIVATE_MemoryMutationQueue(t, this.referenceDelegate), this.ai[e.toKey()] = n), n;
  }
  getGlobalsCache() {
    return this.li;
  }
  getTargetCache() {
    return this.hi;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.Ti;
  }
  runTransaction(e, t, n) {
    __PRIVATE_logDebug("MemoryPersistence", "Starting transaction:", e);
    const r = new __PRIVATE_MemoryTransaction(this.ui.next());
    return this.referenceDelegate.Ii(), n(r).next((e2) => this.referenceDelegate.di(r).next(() => e2)).toPromise().then((e2) => (r.raiseOnCommittedEvent(), e2));
  }
  Ei(e, t) {
    return PersistencePromise.or(Object.values(this.ai).map((n) => () => n.containsKey(e, t)));
  }
}
class __PRIVATE_MemoryTransaction extends PersistenceTransaction {
  constructor(e) {
    super(), this.currentSequenceNumber = e;
  }
}
class __PRIVATE_MemoryEagerDelegate {
  constructor(e) {
    this.persistence = e, /** Tracks all documents that are active in Query views. */
    this.Ai = new __PRIVATE_ReferenceSet(), /** The list of documents that are potentially GCed after each transaction. */
    this.Ri = null;
  }
  static Vi(e) {
    return new __PRIVATE_MemoryEagerDelegate(e);
  }
  get mi() {
    if (this.Ri) return this.Ri;
    throw fail(60996);
  }
  addReference(e, t, n) {
    return this.Ai.addReference(n, t), this.mi.delete(n.toString()), PersistencePromise.resolve();
  }
  removeReference(e, t, n) {
    return this.Ai.removeReference(n, t), this.mi.add(n.toString()), PersistencePromise.resolve();
  }
  markPotentiallyOrphaned(e, t) {
    return this.mi.add(t.toString()), PersistencePromise.resolve();
  }
  removeTarget(e, t) {
    this.Ai.zr(t.targetId).forEach((e2) => this.mi.add(e2.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(e, t.targetId).next((e2) => {
      e2.forEach((e3) => this.mi.add(e3.toString()));
    }).next(() => n.removeTargetData(e, t));
  }
  Ii() {
    this.Ri = /* @__PURE__ */ new Set();
  }
  di(e) {
    const t = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return PersistencePromise.forEach(this.mi, (n) => {
      const r = DocumentKey.fromPath(n);
      return this.fi(e, r).next((e2) => {
        e2 || t.removeEntry(r, SnapshotVersion.min());
      });
    }).next(() => (this.Ri = null, t.apply(e)));
  }
  updateLimboDocument(e, t) {
    return this.fi(e, t).next((e2) => {
      e2 ? this.mi.delete(t.toString()) : this.mi.add(t.toString());
    });
  }
  Pi(e) {
    return 0;
  }
  fi(e, t) {
    return PersistencePromise.or([() => PersistencePromise.resolve(this.Ai.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Ei(e, t)]);
  }
}
class __PRIVATE_MemoryLruDelegate {
  constructor(e, t) {
    this.persistence = e, this.gi = new ObjectMap((e2) => __PRIVATE_encodeResourcePath(e2.path), (e2, t2) => e2.isEqual(t2)), this.garbageCollector = __PRIVATE_newLruGarbageCollector(this, t);
  }
  static Vi(e, t) {
    return new __PRIVATE_MemoryLruDelegate(e, t);
  }
  // No-ops, present so memory persistence doesn't have to care which delegate
  // it has.
  Ii() {
  }
  di(e) {
    return PersistencePromise.resolve();
  }
  forEachTarget(e, t) {
    return this.persistence.getTargetCache().forEachTarget(e, t);
  }
  mr(e) {
    const t = this.yr(e);
    return this.persistence.getTargetCache().getTargetCount(e).next((e2) => t.next((t2) => e2 + t2));
  }
  yr(e) {
    let t = 0;
    return this.gr(e, (e2) => {
      t++;
    }).next(() => t);
  }
  gr(e, t) {
    return PersistencePromise.forEach(this.gi, (n, r) => this.Sr(e, n, r).next((e2) => e2 ? PersistencePromise.resolve() : t(r)));
  }
  removeTargets(e, t, n) {
    return this.persistence.getTargetCache().removeTargets(e, t, n);
  }
  removeOrphanedDocuments(e, t) {
    let n = 0;
    const r = this.persistence.getRemoteDocumentCache(), i = r.newChangeBuffer();
    return r.ri(e, (r2) => this.Sr(e, r2, t).next((e2) => {
      e2 || (n++, i.removeEntry(r2, SnapshotVersion.min()));
    })).next(() => i.apply(e)).next(() => n);
  }
  markPotentiallyOrphaned(e, t) {
    return this.gi.set(t, e.currentSequenceNumber), PersistencePromise.resolve();
  }
  removeTarget(e, t) {
    const n = t.withSequenceNumber(e.currentSequenceNumber);
    return this.persistence.getTargetCache().updateTargetData(e, n);
  }
  addReference(e, t, n) {
    return this.gi.set(n, e.currentSequenceNumber), PersistencePromise.resolve();
  }
  removeReference(e, t, n) {
    return this.gi.set(n, e.currentSequenceNumber), PersistencePromise.resolve();
  }
  updateLimboDocument(e, t) {
    return this.gi.set(t, e.currentSequenceNumber), PersistencePromise.resolve();
  }
  Pi(e) {
    let t = e.key.toString().length;
    return e.isFoundDocument() && (t += __PRIVATE_estimateByteSize(e.data.value)), t;
  }
  Sr(e, t, n) {
    return PersistencePromise.or([() => this.persistence.Ei(e, t), () => this.persistence.getTargetCache().containsKey(e, t), () => {
      const e2 = this.gi.get(t);
      return PersistencePromise.resolve(void 0 !== e2 && e2 > n);
    }]);
  }
  getCacheSize(e) {
    return this.persistence.getRemoteDocumentCache().getSize(e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_LocalViewChanges {
  constructor(e, t, n, r) {
    this.targetId = e, this.fromCache = t, this.Is = n, this.ds = r;
  }
  static Es(e, t) {
    let n = __PRIVATE_documentKeySet(), r = __PRIVATE_documentKeySet();
    for (const e2 of t.docChanges) switch (e2.type) {
      case 0:
        n = n.add(e2.doc.key);
        break;
      case 1:
        r = r.add(e2.doc.key);
    }
    return new __PRIVATE_LocalViewChanges(e, t.fromCache, n, r);
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class QueryContext {
  constructor() {
    this._documentReadCount = 0;
  }
  get documentReadCount() {
    return this._documentReadCount;
  }
  incrementDocumentReadCount(e) {
    this._documentReadCount += e;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_QueryEngine {
  constructor() {
    this.As = false, this.Rs = false, /**
     * SDK only decides whether it should create index when collection size is
     * larger than this.
     */
    this.Vs = 100, this.fs = /**
    * This cost represents the evaluation result of
    * (([index, docKey] + [docKey, docContent]) per document in the result set)
    * / ([docKey, docContent] per documents in full collection scan) coming from
    * experiment [enter PR experiment URL here].
    */
    function __PRIVATE_getDefaultRelativeIndexReadCostPerDocument() {
      return isSafari() ? 8 : __PRIVATE_getAndroidVersion(getUA()) > 0 ? 6 : 4;
    }();
  }
  /** Sets the document view to query against. */
  initialize(e, t) {
    this.gs = e, this.indexManager = t, this.As = true;
  }
  /** Returns all local documents matching the specified query. */
  getDocumentsMatchingQuery(e, t, n, r) {
    const i = {
      result: null
    };
    return this.ps(e, t).next((e2) => {
      i.result = e2;
    }).next(() => {
      if (!i.result) return this.ys(e, t, r, n).next((e2) => {
        i.result = e2;
      });
    }).next(() => {
      if (i.result) return;
      const n2 = new QueryContext();
      return this.ws(e, t, n2).next((r2) => {
        if (i.result = r2, this.Rs) return this.Ss(e, t, n2, r2.size);
      });
    }).next(() => i.result);
  }
  Ss(e, t, n, r) {
    return n.documentReadCount < this.Vs ? (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "SDK will not create cache indexes for query:", __PRIVATE_stringifyQuery(t), "since it only creates cache indexes for collection contains", "more than or equal to", this.Vs, "documents"), PersistencePromise.resolve()) : (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "Query:", __PRIVATE_stringifyQuery(t), "scans", n.documentReadCount, "local documents and returns", r, "documents as results."), n.documentReadCount > this.fs * r ? (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "The SDK decides to create cache indexes for query:", __PRIVATE_stringifyQuery(t), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(e, __PRIVATE_queryToTarget(t))) : PersistencePromise.resolve());
  }
  /**
   * Performs an indexed query that evaluates the query based on a collection's
   * persisted index values. Returns `null` if an index is not available.
   */
  ps(e, t) {
    if (__PRIVATE_queryMatchesAllDocuments(t))
      return PersistencePromise.resolve(null);
    let n = __PRIVATE_queryToTarget(t);
    return this.indexManager.getIndexType(e, n).next((r) => 0 === r ? null : (null !== t.limit && 1 === r && // We cannot apply a limit for targets that are served using a partial
    // index. If a partial index will be used to serve the target, the
    // query may return a superset of documents that match the target
    // (e.g. if the index doesn't include all the target's filters), or
    // may return the correct set of documents in the wrong order (e.g. if
    // the index doesn't include a segment for one of the orderBys).
    // Therefore, a limit should not be applied in such cases.
    (t = __PRIVATE_queryWithLimit(
      t,
      null,
      "F"
      /* LimitType.First */
    ), n = __PRIVATE_queryToTarget(t)), this.indexManager.getDocumentsMatchingTarget(e, n).next((r2) => {
      const i = __PRIVATE_documentKeySet(...r2);
      return this.gs.getDocuments(e, i).next((r3) => this.indexManager.getMinOffset(e, n).next((n2) => {
        const s = this.bs(t, r3);
        return this.Ds(t, s, i, n2.readTime) ? this.ps(e, __PRIVATE_queryWithLimit(
          t,
          null,
          "F"
          /* LimitType.First */
        )) : this.vs(e, s, t, n2);
      }));
    })));
  }
  /**
   * Performs a query based on the target's persisted query mapping. Returns
   * `null` if the mapping is not available or cannot be used.
   */
  ys(e, t, n, r) {
    return __PRIVATE_queryMatchesAllDocuments(t) || r.isEqual(SnapshotVersion.min()) ? PersistencePromise.resolve(null) : this.gs.getDocuments(e, n).next((i) => {
      const s = this.bs(t, i);
      return this.Ds(t, s, n, r) ? PersistencePromise.resolve(null) : (__PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "Re-using previous result from %s to execute query: %s", r.toString(), __PRIVATE_stringifyQuery(t)), this.vs(e, s, t, __PRIVATE_newIndexOffsetSuccessorFromReadTime(r, Q)).next((e2) => e2));
    });
  }
  /** Applies the query filter and sorting to the provided documents.  */
  bs(e, t) {
    let n = new SortedSet(__PRIVATE_newQueryComparator(e));
    return t.forEach((t2, r) => {
      __PRIVATE_queryMatches(e, r) && (n = n.add(r));
    }), n;
  }
  /**
   * Determines if a limit query needs to be refilled from cache, making it
   * ineligible for index-free execution.
   *
   * @param query - The query.
   * @param sortedPreviousResults - The documents that matched the query when it
   * was last synchronized, sorted by the query's comparator.
   * @param remoteKeys - The document keys that matched the query at the last
   * snapshot.
   * @param limboFreeSnapshotVersion - The version of the snapshot when the
   * query was last synchronized.
   */
  Ds(e, t, n, r) {
    if (null === e.limit)
      return false;
    if (n.size !== t.size)
      return true;
    const i = "F" === e.limitType ? t.last() : t.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0);
  }
  ws(e, t, n) {
    return __PRIVATE_getLogLevel() <= LogLevel.DEBUG && __PRIVATE_logDebug("QueryEngine", "Using full collection scan to execute query:", __PRIVATE_stringifyQuery(t)), this.gs.getDocumentsMatchingQuery(e, t, IndexOffset.min(), n);
  }
  /**
   * Combines the results from an indexed execution with the remaining documents
   * that have not yet been indexed.
   */
  vs(e, t, n, r) {
    return this.gs.getDocumentsMatchingQuery(e, n, r).next((e2) => (
      // Merge with existing results
      (t.forEach((t2) => {
        e2 = e2.insert(t2.key, t2);
      }), e2)
    ));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Qt = "LocalStore", $t = 3e8;
class __PRIVATE_LocalStoreImpl {
  constructor(e, t, n, r) {
    this.persistence = e, this.Cs = t, this.serializer = r, /**
     * Maps a targetID to data about its target.
     *
     * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
     * of `applyRemoteEvent()` idempotent.
     */
    this.Fs = new SortedMap(__PRIVATE_primitiveComparator), /** Maps a target to its targetID. */
    // TODO(wuandy): Evaluate if TargetId can be part of Target.
    this.Ms = new ObjectMap((e2) => __PRIVATE_canonifyTarget(e2), __PRIVATE_targetEquals), /**
     * A per collection group index of the last read time processed by
     * `getNewDocumentChanges()`.
     *
     * PORTING NOTE: This is only used for multi-tab synchronization.
     */
    this.xs = /* @__PURE__ */ new Map(), this.Os = e.getRemoteDocumentCache(), this.hi = e.getTargetCache(), this.Ti = e.getBundleCache(), this.Ns(n);
  }
  Ns(e) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new LocalDocumentsView(this.Os, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Os.setIndexManager(this.indexManager), this.Cs.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(e) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (t) => e.collect(t, this.Fs));
  }
}
function __PRIVATE_newLocalStore(e, t, n, r) {
  return new __PRIVATE_LocalStoreImpl(e, t, n, r);
}
async function __PRIVATE_localStoreHandleUserChange(e, t) {
  const n = __PRIVATE_debugCast(e);
  return await n.persistence.runTransaction("Handle user change", "readonly", (e2) => {
    let r;
    return n.mutationQueue.getAllMutationBatches(e2).next((i) => (r = i, n.Ns(t), n.mutationQueue.getAllMutationBatches(e2))).next((t2) => {
      const i = [], s = [];
      let o = __PRIVATE_documentKeySet();
      for (const e3 of r) {
        i.push(e3.batchId);
        for (const t3 of e3.mutations) o = o.add(t3.key);
      }
      for (const e3 of t2) {
        s.push(e3.batchId);
        for (const t3 of e3.mutations) o = o.add(t3.key);
      }
      return n.localDocuments.getDocuments(e2, o).next((e3) => ({
        Bs: e3,
        removedBatchIds: i,
        addedBatchIds: s
      }));
    });
  });
}
function __PRIVATE_localStoreAcknowledgeBatch(e, t) {
  const n = __PRIVATE_debugCast(e);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (e2) => {
    const r = t.batch.keys(), i = n.Os.newChangeBuffer({
      trackRemovals: true
    });
    return function __PRIVATE_applyWriteToRemoteDocuments(e3, t2, n2, r2) {
      const i2 = n2.batch, s = i2.keys();
      let o = PersistencePromise.resolve();
      return s.forEach((e4) => {
        o = o.next(() => r2.getEntry(t2, e4)).next((t3) => {
          const s2 = n2.docVersions.get(e4);
          __PRIVATE_hardAssert(null !== s2, 48541), t3.version.compareTo(s2) < 0 && (i2.applyToRemoteDocument(t3, n2), t3.isValidDocument() && // We use the commitVersion as the readTime rather than the
          // document's updateTime since the updateTime is not advanced
          // for updates that do not modify the underlying document.
          (t3.setReadTime(n2.commitVersion), r2.addEntry(t3)));
        });
      }), o.next(() => e3.mutationQueue.removeMutationBatch(t2, i2));
    }(n, e2, t, i).next(() => i.apply(e2)).next(() => n.mutationQueue.performConsistencyCheck(e2)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(e2, r, t.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e2, function __PRIVATE_getKeysWithTransformResults(e3) {
      let t2 = __PRIVATE_documentKeySet();
      for (let n2 = 0; n2 < e3.mutationResults.length; ++n2) {
        e3.mutationResults[n2].transformResults.length > 0 && (t2 = t2.add(e3.batch.mutations[n2].key));
      }
      return t2;
    }(t))).next(() => n.localDocuments.getDocuments(e2, r));
  });
}
function __PRIVATE_localStoreGetLastRemoteSnapshotVersion(e) {
  const t = __PRIVATE_debugCast(e);
  return t.persistence.runTransaction("Get last remote snapshot version", "readonly", (e2) => t.hi.getLastRemoteSnapshotVersion(e2));
}
function __PRIVATE_localStoreApplyRemoteEventToLocalCache(e, t) {
  const n = __PRIVATE_debugCast(e), r = t.snapshotVersion;
  let i = n.Fs;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (e2) => {
    const s = n.Os.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Fs;
    const o = [];
    t.targetChanges.forEach((s2, _2) => {
      const a2 = i.get(_2);
      if (!a2) return;
      o.push(n.hi.removeMatchingKeys(e2, s2.removedDocuments, _2).next(() => n.hi.addMatchingKeys(e2, s2.addedDocuments, _2)));
      let u = a2.withSequenceNumber(e2.currentSequenceNumber);
      null !== t.targetMismatches.get(_2) ? u = u.withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min()).withLastLimboFreeSnapshotVersion(SnapshotVersion.min()) : s2.resumeToken.approximateByteSize() > 0 && (u = u.withResumeToken(s2.resumeToken, r)), i = i.insert(_2, u), // Update the target data if there are target changes (or if
      // sufficient time has passed since the last update).
      /**
      * Returns true if the newTargetData should be persisted during an update of
      * an active target. TargetData should always be persisted when a target is
      * being released and should not call this function.
      *
      * While the target is active, TargetData updates can be omitted when nothing
      * about the target has changed except metadata like the resume token or
      * snapshot version. Occasionally it's worth the extra write to prevent these
      * values from getting too stale after a crash, but this doesn't have to be
      * too frequent.
      */
      function __PRIVATE_shouldPersistTargetData(e3, t2, n2) {
        if (0 === e3.resumeToken.approximateByteSize()) return true;
        const r2 = t2.snapshotVersion.toMicroseconds() - e3.snapshotVersion.toMicroseconds();
        if (r2 >= $t) return true;
        const i2 = n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size;
        return i2 > 0;
      }(a2, u, s2) && o.push(n.hi.updateTargetData(e2, u));
    });
    let _ = __PRIVATE_mutableDocumentMap(), a = __PRIVATE_documentKeySet();
    if (t.documentUpdates.forEach((r2) => {
      t.resolvedLimboDocuments.has(r2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(e2, r2));
    }), // Each loop iteration only affects its "own" doc, so it's safe to get all
    // the remote documents in advance in a single call.
    o.push(__PRIVATE_populateDocumentChangeBuffer(e2, s, t.documentUpdates).next((e3) => {
      _ = e3.Ls, a = e3.ks;
    })), !r.isEqual(SnapshotVersion.min())) {
      const t2 = n.hi.getLastRemoteSnapshotVersion(e2).next((t3) => n.hi.setTargetsMetadata(e2, e2.currentSequenceNumber, r));
      o.push(t2);
    }
    return PersistencePromise.waitFor(o).next(() => s.apply(e2)).next(() => n.localDocuments.getLocalViewOfDocuments(e2, _, a)).next(() => _);
  }).then((e2) => (n.Fs = i, e2));
}
function __PRIVATE_populateDocumentChangeBuffer(e, t, n) {
  let r = __PRIVATE_documentKeySet(), i = __PRIVATE_documentKeySet();
  return n.forEach((e2) => r = r.add(e2)), t.getEntries(e, r).next((e2) => {
    let r2 = __PRIVATE_mutableDocumentMap();
    return n.forEach((n2, s) => {
      const o = e2.get(n2);
      s.isFoundDocument() !== o.isFoundDocument() && (i = i.add(n2)), // Note: The order of the steps below is important, since we want
      // to ensure that rejected limbo resolutions (which fabricate
      // NoDocuments with SnapshotVersion.min()) never add documents to
      // cache.
      s.isNoDocument() && s.version.isEqual(SnapshotVersion.min()) ? (
        // NoDocuments with SnapshotVersion.min() are used in manufactured
        // events. We remove these documents from cache since we lost
        // access.
        (t.removeEntry(n2, s.readTime), r2 = r2.insert(n2, s))
      ) : !o.isValidDocument() || s.version.compareTo(o.version) > 0 || 0 === s.version.compareTo(o.version) && o.hasPendingWrites ? (t.addEntry(s), r2 = r2.insert(n2, s)) : __PRIVATE_logDebug(Qt, "Ignoring outdated watch update for ", n2, ". Current version:", o.version, " Watch version:", s.version);
    }), {
      Ls: r2,
      ks: i
    };
  });
}
function __PRIVATE_localStoreGetNextMutationBatch(e, t) {
  const n = __PRIVATE_debugCast(e);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (e2) => (void 0 === t && (t = G), n.mutationQueue.getNextMutationBatchAfterBatchId(e2, t)));
}
function __PRIVATE_localStoreAllocateTarget(e, t) {
  const n = __PRIVATE_debugCast(e);
  return n.persistence.runTransaction("Allocate target", "readwrite", (e2) => {
    let r;
    return n.hi.getTargetData(e2, t).next((i) => i ? (
      // This target has been listened to previously, so reuse the
      // previous targetID.
      // TODO(mcg): freshen last accessed date?
      (r = i, PersistencePromise.resolve(r))
    ) : n.hi.allocateTargetId(e2).next((i2) => (r = new TargetData(t, i2, "TargetPurposeListen", e2.currentSequenceNumber), n.hi.addTargetData(e2, r).next(() => r))));
  }).then((e2) => {
    const r = n.Fs.get(e2.targetId);
    return (null === r || e2.snapshotVersion.compareTo(r.snapshotVersion) > 0) && (n.Fs = n.Fs.insert(e2.targetId, e2), n.Ms.set(t, e2.targetId)), e2;
  });
}
async function __PRIVATE_localStoreReleaseTarget(e, t, n) {
  const r = __PRIVATE_debugCast(e), i = r.Fs.get(t), s = n ? "readwrite" : "readwrite-primary";
  try {
    n || await r.persistence.runTransaction("Release target", s, (e2) => r.persistence.referenceDelegate.removeTarget(e2, i));
  } catch (e2) {
    if (!__PRIVATE_isIndexedDbTransactionError(e2)) throw e2;
    __PRIVATE_logDebug(Qt, `Failed to update sequence numbers for target ${t}: ${e2}`);
  }
  r.Fs = r.Fs.remove(t), r.Ms.delete(i.target);
}
function __PRIVATE_localStoreExecuteQuery(e, t, n) {
  const r = __PRIVATE_debugCast(e);
  let i = SnapshotVersion.min(), s = __PRIVATE_documentKeySet();
  return r.persistence.runTransaction(
    "Execute query",
    "readwrite",
    // Use readwrite instead of readonly so indexes can be created
    // Use readwrite instead of readonly so indexes can be created
    (e2) => function __PRIVATE_localStoreGetTargetData(e3, t2, n2) {
      const r2 = __PRIVATE_debugCast(e3), i2 = r2.Ms.get(n2);
      return void 0 !== i2 ? PersistencePromise.resolve(r2.Fs.get(i2)) : r2.hi.getTargetData(t2, n2);
    }(r, e2, __PRIVATE_queryToTarget(t)).next((t2) => {
      if (t2) return i = t2.lastLimboFreeSnapshotVersion, r.hi.getMatchingKeysForTargetId(e2, t2.targetId).next((e3) => {
        s = e3;
      });
    }).next(() => r.Cs.getDocumentsMatchingQuery(e2, t, n ? i : SnapshotVersion.min(), n ? s : __PRIVATE_documentKeySet())).next((e3) => (__PRIVATE_setMaxReadTime(r, __PRIVATE_queryCollectionGroup(t), e3), {
      documents: e3,
      qs: s
    }))
  );
}
function __PRIVATE_setMaxReadTime(e, t, n) {
  let r = e.xs.get(t) || SnapshotVersion.min();
  n.forEach((e2, t2) => {
    t2.readTime.compareTo(r) > 0 && (r = t2.readTime);
  }), e.xs.set(t, r);
}
class __PRIVATE_LocalClientState {
  constructor() {
    this.activeTargetIds = __PRIVATE_targetIdSet();
  }
  Gs(e) {
    this.activeTargetIds = this.activeTargetIds.add(e);
  }
  zs(e) {
    this.activeTargetIds = this.activeTargetIds.delete(e);
  }
  /**
   * Converts this entry into a JSON-encoded format we can use for WebStorage.
   * Does not encode `clientId` as it is part of the key in WebStorage.
   */
  Ws() {
    const e = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(e);
  }
}
class __PRIVATE_MemorySharedClientState {
  constructor() {
    this.Fo = new __PRIVATE_LocalClientState(), this.Mo = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(e) {
  }
  updateMutationState(e, t, n) {
  }
  addLocalQueryTarget(e, t = true) {
    return t && this.Fo.Gs(e), this.Mo[e] || "not-current";
  }
  updateQueryState(e, t, n) {
    this.Mo[e] = t;
  }
  removeLocalQueryTarget(e) {
    this.Fo.zs(e);
  }
  isLocalQueryTarget(e) {
    return this.Fo.activeTargetIds.has(e);
  }
  clearQueryState(e) {
    delete this.Mo[e];
  }
  getAllActiveQueryTargets() {
    return this.Fo.activeTargetIds;
  }
  isActiveQueryTarget(e) {
    return this.Fo.activeTargetIds.has(e);
  }
  start() {
    return this.Fo = new __PRIVATE_LocalClientState(), Promise.resolve();
  }
  handleUserChange(e, t, n) {
  }
  setOnlineState(e) {
  }
  shutdown() {
  }
  writeSequenceNumber(e) {
  }
  notifyBundleLoaded(e) {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_NoopConnectivityMonitor {
  xo(e) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zt = "ConnectivityMonitor";
class __PRIVATE_BrowserConnectivityMonitor {
  constructor() {
    this.Oo = () => this.No(), this.Bo = () => this.Lo(), this.ko = [], this.qo();
  }
  xo(e) {
    this.ko.push(e);
  }
  shutdown() {
    window.removeEventListener("online", this.Oo), window.removeEventListener("offline", this.Bo);
  }
  qo() {
    window.addEventListener("online", this.Oo), window.addEventListener("offline", this.Bo);
  }
  No() {
    __PRIVATE_logDebug(zt, "Network connectivity changed: AVAILABLE");
    for (const e of this.ko) e(
      0
      /* NetworkStatus.AVAILABLE */
    );
  }
  Lo() {
    __PRIVATE_logDebug(zt, "Network connectivity changed: UNAVAILABLE");
    for (const e of this.ko) e(
      1
      /* NetworkStatus.UNAVAILABLE */
    );
  }
  // TODO(chenbrian): Consider passing in window either into this component or
  // here for testing via FakeWindow.
  /** Checks that all used attributes of window are available. */
  static C() {
    return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let jt = null;
function __PRIVATE_generateUniqueDebugId() {
  return null === jt ? jt = function __PRIVATE_generateInitialUniqueDebugId() {
    return 268435456 + Math.round(2147483648 * Math.random());
  }() : jt++, "0x" + jt.toString(16);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jt = "RestConnection", Ht = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
class __PRIVATE_RestConnection {
  get Qo() {
    return false;
  }
  constructor(e) {
    this.databaseInfo = e, this.databaseId = e.databaseId;
    const t = e.ssl ? "https" : "http", n = encodeURIComponent(this.databaseId.projectId), r = encodeURIComponent(this.databaseId.database);
    this.$o = t + "://" + e.host, this.Uo = `projects/${n}/databases/${r}`, this.Ko = this.databaseId.database === ut ? `project_id=${n}` : `project_id=${n}&database_id=${r}`;
  }
  Wo(e, t, n, r, i) {
    const s = __PRIVATE_generateUniqueDebugId(), o = this.Go(e, t.toUriEncodedString());
    __PRIVATE_logDebug(Jt, `Sending RPC '${e}' ${s}:`, o, n);
    const _ = {
      "google-cloud-resource-prefix": this.Uo,
      "x-goog-request-params": this.Ko
    };
    this.zo(_, r, i);
    const { host: a } = new URL(o), u = isCloudWorkstation(a);
    return this.jo(e, o, _, n, u).then((t2) => (__PRIVATE_logDebug(Jt, `Received RPC '${e}' ${s}: `, t2), t2), (t2) => {
      throw __PRIVATE_logWarn(Jt, `RPC '${e}' ${s} failed with error: `, t2, "url: ", o, "request:", n), t2;
    });
  }
  Jo(e, t, n, r, i, s) {
    return this.Wo(e, t, n, r, i);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  zo(e, t, n) {
    e["X-Goog-Api-Client"] = // SDK_VERSION is updated to different value at runtime depending on the entry point,
    // so we need to get its value when we need it in a function.
    function __PRIVATE_getGoogApiClientValue() {
      return "gl-js/ fire/" + x;
    }(), // Content-Type: text/plain will avoid preflight requests which might
    // mess with CORS and redirects by proxies. If we add custom headers
    // we will need to change this code to potentially use the $httpOverwrite
    // parameter supported by ESF to avoid triggering preflight requests.
    e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach((t2, n2) => e[n2] = t2), n && n.headers.forEach((t2, n2) => e[n2] = t2);
  }
  Go(e, t) {
    const n = Ht[e];
    return `${this.$o}/v1/${t}:${n}`;
  }
  /**
   * Closes and cleans up any resources associated with the connection. This
   * implementation is a no-op because there are no resources associated
   * with the RestConnection that need to be cleaned up.
   */
  terminate() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_StreamBridge {
  constructor(e) {
    this.Ho = e.Ho, this.Yo = e.Yo;
  }
  Zo(e) {
    this.Xo = e;
  }
  e_(e) {
    this.t_ = e;
  }
  n_(e) {
    this.r_ = e;
  }
  onMessage(e) {
    this.i_ = e;
  }
  close() {
    this.Yo();
  }
  send(e) {
    this.Ho(e);
  }
  s_() {
    this.Xo();
  }
  o_() {
    this.t_();
  }
  __(e) {
    this.r_(e);
  }
  a_(e) {
    this.i_(e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yt = "WebChannelConnection";
class __PRIVATE_WebChannelConnection extends __PRIVATE_RestConnection {
  constructor(e) {
    super(e), /** A collection of open WebChannel instances */
    this.u_ = [], this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams, this.longPollingOptions = e.longPollingOptions;
  }
  jo(e, t, n, r, i) {
    const s = __PRIVATE_generateUniqueDebugId();
    return new Promise((i2, o) => {
      const _ = new XhrIo();
      _.setWithCredentials(true), _.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (_.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const t2 = _.getResponseJson();
              __PRIVATE_logDebug(Yt, `XHR for RPC '${e}' ${s} received:`, JSON.stringify(t2)), i2(t2);
              break;
            case ErrorCode.TIMEOUT:
              __PRIVATE_logDebug(Yt, `RPC '${e}' ${s} timed out`), o(new FirestoreError(N.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = _.getStatus();
              if (__PRIVATE_logDebug(Yt, `RPC '${e}' ${s} failed with status:`, n2, "response text:", _.getResponseText()), n2 > 0) {
                let e2 = _.getResponseJson();
                Array.isArray(e2) && (e2 = e2[0]);
                const t3 = null == e2 ? void 0 : e2.error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function __PRIVATE_mapCodeFromHttpResponseErrorStatus(e4) {
                    const t4 = e4.toLowerCase().replace(/_/g, "-");
                    return Object.values(N).indexOf(t4) >= 0 ? t4 : N.UNKNOWN;
                  }(t3.status);
                  o(new FirestoreError(e3, t3.message));
                } else o(new FirestoreError(N.UNKNOWN, "Server responded with status " + _.getStatus()));
              } else
                o(new FirestoreError(N.UNAVAILABLE, "Connection failed."));
              break;
            default:
              fail(9055, {
                c_: e,
                streamId: s,
                l_: _.getLastErrorCode(),
                h_: _.getLastError()
              });
          }
        } finally {
          __PRIVATE_logDebug(Yt, `RPC '${e}' ${s} completed.`);
        }
      });
      const a = JSON.stringify(r);
      __PRIVATE_logDebug(Yt, `RPC '${e}' ${s} sending request:`, r), _.send(t, "POST", a, n, 15);
    });
  }
  P_(e, t, n) {
    const r = __PRIVATE_generateUniqueDebugId(), i = [this.$o, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], s = createWebChannelTransport(), o = getStatEventTarget(), _ = {
      // Required for backend stickiness, routing behavior is based on this
      // parameter.
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        // This param is used to improve routing and project isolation by the
        // backend and must be included in every request.
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        // Override the default timeout (randomized between 10-20 seconds) since
        // a large write batch on a slow internet connection may take a long
        // time to send to the backend. Rather than have WebChannel impose a
        // tight timeout which could lead to infinite timeouts and retries, we
        // set it very large (5-10 minutes) and rely on the browser's builtin
        // timeouts to kick in if the request isn't working.
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    }, a = this.longPollingOptions.timeoutSeconds;
    void 0 !== a && (_.longPollingTimeout = Math.round(1e3 * a)), this.useFetchStreams && (_.useFetchStreams = true), this.zo(_.initMessageHeaders, t, n), // Sending the custom headers we just added to request.initMessageHeaders
    // (Authorization, etc.) will trigger the browser to make a CORS preflight
    // request because the XHR will no longer meet the criteria for a "simple"
    // CORS request:
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests
    // Therefore to avoid the CORS preflight request (an extra network
    // roundtrip), we use the encodeInitMessageHeaders option to specify that
    // the headers should instead be encoded in the request's POST payload,
    // which is recognized by the webchannel backend.
    _.encodeInitMessageHeaders = true;
    const u = i.join("");
    __PRIVATE_logDebug(Yt, `Creating RPC '${e}' stream ${r}: ${u}`, _);
    const c = s.createWebChannel(u, _);
    this.T_(c);
    let l = false, h = false;
    const P = new __PRIVATE_StreamBridge({
      Ho: (t2) => {
        h ? __PRIVATE_logDebug(Yt, `Not sending because RPC '${e}' stream ${r} is closed:`, t2) : (l || (__PRIVATE_logDebug(Yt, `Opening RPC '${e}' stream ${r} transport.`), c.open(), l = true), __PRIVATE_logDebug(Yt, `RPC '${e}' stream ${r} sending:`, t2), c.send(t2));
      },
      Yo: () => c.close()
    }), __PRIVATE_unguardedEventListen = (e2, t2, n2) => {
      e2.listen(t2, (e3) => {
        try {
          n2(e3);
        } catch (e4) {
          setTimeout(() => {
            throw e4;
          }, 0);
        }
      });
    };
    return __PRIVATE_unguardedEventListen(c, WebChannel.EventType.OPEN, () => {
      h || (__PRIVATE_logDebug(Yt, `RPC '${e}' stream ${r} transport opened.`), P.s_());
    }), __PRIVATE_unguardedEventListen(c, WebChannel.EventType.CLOSE, () => {
      h || (h = true, __PRIVATE_logDebug(Yt, `RPC '${e}' stream ${r} transport closed`), P.__(), this.I_(c));
    }), __PRIVATE_unguardedEventListen(c, WebChannel.EventType.ERROR, (t2) => {
      h || (h = true, __PRIVATE_logWarn(Yt, `RPC '${e}' stream ${r} transport errored. Name:`, t2.name, "Message:", t2.message), P.__(new FirestoreError(N.UNAVAILABLE, "The operation could not be completed")));
    }), __PRIVATE_unguardedEventListen(c, WebChannel.EventType.MESSAGE, (t2) => {
      var n2;
      if (!h) {
        const i2 = t2.data[0];
        __PRIVATE_hardAssert(!!i2, 16349);
        const s2 = i2, o2 = (null == s2 ? void 0 : s2.error) || (null === (n2 = s2[0]) || void 0 === n2 ? void 0 : n2.error);
        if (o2) {
          __PRIVATE_logDebug(Yt, `RPC '${e}' stream ${r} received error:`, o2);
          const t3 = o2.status;
          let n3 = (
            /**
            * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
            *
            * @returns The Code equivalent to the given status string or undefined if
            *     there is no match.
            */
            function __PRIVATE_mapCodeFromRpcStatus(e2) {
              const t4 = ft[e2];
              if (void 0 !== t4) return __PRIVATE_mapCodeFromRpcCode(t4);
            }(t3)
          ), i3 = o2.message;
          void 0 === n3 && (n3 = N.INTERNAL, i3 = "Unknown error status: " + t3 + " with message " + o2.message), // Mark closed so no further events are propagated
          h = true, P.__(new FirestoreError(n3, i3)), c.close();
        } else __PRIVATE_logDebug(Yt, `RPC '${e}' stream ${r} received:`, i2), P.a_(i2);
      }
    }), __PRIVATE_unguardedEventListen(o, Event$1.STAT_EVENT, (t2) => {
      t2.stat === Stat.PROXY ? __PRIVATE_logDebug(Yt, `RPC '${e}' stream ${r} detected buffering proxy`) : t2.stat === Stat.NOPROXY && __PRIVATE_logDebug(Yt, `RPC '${e}' stream ${r} detected no buffering proxy`);
    }), setTimeout(() => {
      P.o_();
    }, 0), P;
  }
  /**
   * Closes and cleans up any resources associated with the connection.
   */
  terminate() {
    this.u_.forEach((e) => e.close()), this.u_ = [];
  }
  /**
   * Add a WebChannel instance to the collection of open instances.
   * @param webChannel
   */
  T_(e) {
    this.u_.push(e);
  }
  /**
   * Remove a WebChannel instance from the collection of open instances.
   * @param webChannel
   */
  I_(e) {
    this.u_ = this.u_.filter((t) => t === e);
  }
}
function getDocument() {
  return "undefined" != typeof document ? document : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_newSerializer(e) {
  return new JsonProtoSerializer(
    e,
    /* useProto3Json= */
    true
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_ExponentialBackoff {
  constructor(e, t, n = 1e3, r = 1.5, i = 6e4) {
    this.Fi = e, this.timerId = t, this.d_ = n, this.E_ = r, this.A_ = i, this.R_ = 0, this.V_ = null, /** The last backoff attempt, as epoch milliseconds. */
    this.m_ = Date.now(), this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.R_ = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  f_() {
    this.R_ = this.A_;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  g_(e) {
    this.cancel();
    const t = Math.floor(this.R_ + this.p_()), n = Math.max(0, Date.now() - this.m_), r = Math.max(0, t - n);
    r > 0 && __PRIVATE_logDebug("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this.R_} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`), this.V_ = this.Fi.enqueueAfterDelay(this.timerId, r, () => (this.m_ = Date.now(), e())), // Apply backoff factor to determine next delay and ensure it is within
    // bounds.
    this.R_ *= this.E_, this.R_ < this.d_ && (this.R_ = this.d_), this.R_ > this.A_ && (this.R_ = this.A_);
  }
  y_() {
    null !== this.V_ && (this.V_.skipDelay(), this.V_ = null);
  }
  cancel() {
    null !== this.V_ && (this.V_.cancel(), this.V_ = null);
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  p_() {
    return (Math.random() - 0.5) * this.R_;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Zt = "PersistentStream";
class __PRIVATE_PersistentStream {
  constructor(e, t, n, r, i, s, o, _) {
    this.Fi = e, this.w_ = n, this.S_ = r, this.connection = i, this.authCredentialsProvider = s, this.appCheckCredentialsProvider = o, this.listener = _, this.state = 0, /**
     * A close count that's incremented every time the stream is closed; used by
     * getCloseGuardedDispatcher() to invalidate callbacks that happen after
     * close.
     */
    this.b_ = 0, this.D_ = null, this.v_ = null, this.stream = null, /**
     * Count of response messages received.
     */
    this.C_ = 0, this.F_ = new __PRIVATE_ExponentialBackoff(e, t);
  }
  /**
   * Returns true if start() has been called and no error has occurred. True
   * indicates the stream is open or in the process of opening (which
   * encompasses respecting backoff, getting auth tokens, and starting the
   * actual RPC). Use isOpen() to determine if the stream is open and ready for
   * outbound requests.
   */
  M_() {
    return 1 === this.state || 5 === this.state || this.x_();
  }
  /**
   * Returns true if the underlying RPC is open (the onOpen() listener has been
   * called) and the stream is ready for outbound requests.
   */
  x_() {
    return 2 === this.state || 3 === this.state;
  }
  /**
   * Starts the RPC. Only allowed if isStarted() returns false. The stream is
   * not immediately ready for use: onOpen() will be invoked when the RPC is
   * ready for outbound requests, at which point isOpen() will return true.
   *
   * When start returns, isStarted() will return true.
   */
  start() {
    this.C_ = 0, 4 !== this.state ? this.auth() : this.O_();
  }
  /**
   * Stops the RPC. This call is idempotent and allowed regardless of the
   * current isStarted() state.
   *
   * When stop returns, isStarted() and isOpen() will both return false.
   */
  async stop() {
    this.M_() && await this.close(
      0
      /* PersistentStreamState.Initial */
    );
  }
  /**
   * After an error the stream will usually back off on the next attempt to
   * start it. If the error warrants an immediate restart of the stream, the
   * sender can use this to indicate that the receiver should not back off.
   *
   * Each error will call the onClose() listener. That function can decide to
   * inhibit backoff if required.
   */
  N_() {
    this.state = 0, this.F_.reset();
  }
  /**
   * Marks this stream as idle. If no further actions are performed on the
   * stream for one minute, the stream will automatically close itself and
   * notify the stream's onClose() handler with Status.OK. The stream will then
   * be in a !isStarted() state, requiring the caller to start the stream again
   * before further use.
   *
   * Only streams that are in state 'Open' can be marked idle, as all other
   * states imply pending network operations.
   */
  B_() {
    this.x_() && null === this.D_ && (this.D_ = this.Fi.enqueueAfterDelay(this.w_, 6e4, () => this.L_()));
  }
  /** Sends a message to the underlying stream. */
  k_(e) {
    this.q_(), this.stream.send(e);
  }
  /** Called by the idle timer when the stream should close due to inactivity. */
  async L_() {
    if (this.x_())
      return this.close(
        0
        /* PersistentStreamState.Initial */
      );
  }
  /** Marks the stream as active again. */
  q_() {
    this.D_ && (this.D_.cancel(), this.D_ = null);
  }
  /** Cancels the health check delayed operation. */
  Q_() {
    this.v_ && (this.v_.cancel(), this.v_ = null);
  }
  /**
   * Closes the stream and cleans up as necessary:
   *
   * * closes the underlying GRPC stream;
   * * calls the onClose handler with the given 'error';
   * * sets internal stream state to 'finalState';
   * * adjusts the backoff timer based on the error
   *
   * A new stream can be opened by calling start().
   *
   * @param finalState - the intended state of the stream after closing.
   * @param error - the error the connection was closed with.
   */
  async close(e, t) {
    this.q_(), this.Q_(), this.F_.cancel(), // Invalidates any stream-related callbacks (e.g. from auth or the
    // underlying stream), guaranteeing they won't execute.
    this.b_++, 4 !== e ? (
      // If this is an intentional close ensure we don't delay our next connection attempt.
      this.F_.reset()
    ) : t && t.code === N.RESOURCE_EXHAUSTED ? (
      // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
      (__PRIVATE_logError(t.toString()), __PRIVATE_logError("Using maximum backoff delay to prevent overloading the backend."), this.F_.f_())
    ) : t && t.code === N.UNAUTHENTICATED && 3 !== this.state && // "unauthenticated" error means the token was rejected. This should rarely
    // happen since both Auth and AppCheck ensure a sufficient TTL when we
    // request a token. If a user manually resets their system clock this can
    // fail, however. In this case, we should get a Code.UNAUTHENTICATED error
    // before we received the first message and we need to invalidate the token
    // to ensure that we fetch a new token.
    (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), // Clean up the underlying stream because we are no longer interested in events.
    null !== this.stream && (this.U_(), this.stream.close(), this.stream = null), // This state must be assigned before calling onClose() to allow the callback to
    // inhibit backoff or otherwise manipulate the state in its non-started state.
    this.state = e, // Notify the listener that the stream closed.
    await this.listener.n_(t);
  }
  /**
   * Can be overridden to perform additional cleanup before the stream is closed.
   * Calling super.tearDown() is not required.
   */
  U_() {
  }
  auth() {
    this.state = 1;
    const e = this.K_(this.b_), t = this.b_;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([e2, n]) => {
      this.b_ === t && // Normally we'd have to schedule the callback on the AsyncQueue.
      // However, the following calls are safe to be called outside the
      // AsyncQueue since they don't chain asynchronous calls
      this.W_(e2, n);
    }, (t2) => {
      e(() => {
        const e2 = new FirestoreError(N.UNKNOWN, "Fetching auth token failed: " + t2.message);
        return this.G_(e2);
      });
    });
  }
  W_(e, t) {
    const n = this.K_(this.b_);
    this.stream = this.z_(e, t), this.stream.Zo(() => {
      n(() => this.listener.Zo());
    }), this.stream.e_(() => {
      n(() => (this.state = 2, this.v_ = this.Fi.enqueueAfterDelay(this.S_, 1e4, () => (this.x_() && (this.state = 3), Promise.resolve())), this.listener.e_()));
    }), this.stream.n_((e2) => {
      n(() => this.G_(e2));
    }), this.stream.onMessage((e2) => {
      n(() => 1 == ++this.C_ ? this.j_(e2) : this.onNext(e2));
    });
  }
  O_() {
    this.state = 5, this.F_.g_(async () => {
      this.state = 0, this.start();
    });
  }
  // Visible for tests
  G_(e) {
    return __PRIVATE_logDebug(Zt, `close with error: ${e}`), this.stream = null, this.close(4, e);
  }
  /**
   * Returns a "dispatcher" function that dispatches operations onto the
   * AsyncQueue but only runs them if closeCount remains unchanged. This allows
   * us to turn auth / stream callbacks into no-ops if the stream is closed /
   * re-opened, etc.
   */
  K_(e) {
    return (t) => {
      this.Fi.enqueueAndForget(() => this.b_ === e ? t() : (__PRIVATE_logDebug(Zt, "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
}
class __PRIVATE_PersistentListenStream extends __PRIVATE_PersistentStream {
  constructor(e, t, n, r, i, s) {
    super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, n, r, s), this.serializer = i;
  }
  z_(e, t) {
    return this.connection.P_("Listen", e, t);
  }
  j_(e) {
    return this.onNext(e);
  }
  onNext(e) {
    this.F_.reset();
    const t = __PRIVATE_fromWatchChange(this.serializer, e), n = function __PRIVATE_versionFromListenResponse(e2) {
      if (!("targetChange" in e2)) return SnapshotVersion.min();
      const t2 = e2.targetChange;
      return t2.targetIds && t2.targetIds.length ? SnapshotVersion.min() : t2.readTime ? __PRIVATE_fromVersion(t2.readTime) : SnapshotVersion.min();
    }(e);
    return this.listener.J_(t, n);
  }
  /**
   * Registers interest in the results of the given target. If the target
   * includes a resumeToken it will be included in the request. Results that
   * affect the target will be streamed back as WatchChange messages that
   * reference the targetId.
   */
  H_(e) {
    const t = {};
    t.database = __PRIVATE_getEncodedDatabaseId(this.serializer), t.addTarget = function __PRIVATE_toTarget(e2, t2) {
      let n2;
      const r = t2.target;
      if (n2 = __PRIVATE_targetIsDocumentTarget(r) ? {
        documents: __PRIVATE_toDocumentsTarget(e2, r)
      } : {
        query: __PRIVATE_toQueryTarget(e2, r).Vt
      }, n2.targetId = t2.targetId, t2.resumeToken.approximateByteSize() > 0) {
        n2.resumeToken = __PRIVATE_toBytes(e2, t2.resumeToken);
        const r2 = __PRIVATE_toInt32Proto(e2, t2.expectedCount);
        null !== r2 && (n2.expectedCount = r2);
      } else if (t2.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
        n2.readTime = toTimestamp(e2, t2.snapshotVersion.toTimestamp());
        const r2 = __PRIVATE_toInt32Proto(e2, t2.expectedCount);
        null !== r2 && (n2.expectedCount = r2);
      }
      return n2;
    }(this.serializer, e);
    const n = __PRIVATE_toListenRequestLabels(this.serializer, e);
    n && (t.labels = n), this.k_(t);
  }
  /**
   * Unregisters interest in the results of the target associated with the
   * given targetId.
   */
  Y_(e) {
    const t = {};
    t.database = __PRIVATE_getEncodedDatabaseId(this.serializer), t.removeTarget = e, this.k_(t);
  }
}
class __PRIVATE_PersistentWriteStream extends __PRIVATE_PersistentStream {
  constructor(e, t, n, r, i, s) {
    super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, n, r, s), this.serializer = i;
  }
  /**
   * Tracks whether or not a handshake has been successfully exchanged and
   * the stream is ready to accept mutations.
   */
  get Z_() {
    return this.C_ > 0;
  }
  // Override of PersistentStream.start
  start() {
    this.lastStreamToken = void 0, super.start();
  }
  U_() {
    this.Z_ && this.X_([]);
  }
  z_(e, t) {
    return this.connection.P_("Write", e, t);
  }
  j_(e) {
    return __PRIVATE_hardAssert(!!e.streamToken, 31322), this.lastStreamToken = e.streamToken, // The first response is always the handshake response
    __PRIVATE_hardAssert(!e.writeResults || 0 === e.writeResults.length, 55816), this.listener.ea();
  }
  onNext(e) {
    __PRIVATE_hardAssert(!!e.streamToken, 12678), this.lastStreamToken = e.streamToken, // A successful first write response means the stream is healthy,
    // Note, that we could consider a successful handshake healthy, however,
    // the write itself might be causing an error we want to back off from.
    this.F_.reset();
    const t = __PRIVATE_fromWriteResults(e.writeResults, e.commitTime), n = __PRIVATE_fromVersion(e.commitTime);
    return this.listener.ta(n, t);
  }
  /**
   * Sends an initial streamToken to the server, performing the handshake
   * required to make the StreamingWrite RPC work. Subsequent
   * calls should wait until onHandshakeComplete was called.
   */
  na() {
    const e = {};
    e.database = __PRIVATE_getEncodedDatabaseId(this.serializer), this.k_(e);
  }
  /** Sends a group of mutations to the Firestore backend to apply. */
  X_(e) {
    const t = {
      streamToken: this.lastStreamToken,
      writes: e.map((e2) => toMutation(this.serializer, e2))
    };
    this.k_(t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Datastore {
}
class __PRIVATE_DatastoreImpl extends Datastore {
  constructor(e, t, n, r) {
    super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = n, this.serializer = r, this.ra = false;
  }
  ia() {
    if (this.ra) throw new FirestoreError(N.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  Wo(e, t, n, r) {
    return this.ia(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, s]) => this.connection.Wo(e, __PRIVATE_toResourcePath(t, n), r, i, s)).catch((e2) => {
      throw "FirebaseError" === e2.name ? (e2.code === N.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e2) : new FirestoreError(N.UNKNOWN, e2.toString());
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  Jo(e, t, n, r, i) {
    return this.ia(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, o]) => this.connection.Jo(e, __PRIVATE_toResourcePath(t, n), r, s, o, i)).catch((e2) => {
      throw "FirebaseError" === e2.name ? (e2.code === N.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e2) : new FirestoreError(N.UNKNOWN, e2.toString());
    });
  }
  terminate() {
    this.ra = true, this.connection.terminate();
  }
}
class __PRIVATE_OnlineStateTracker {
  constructor(e, t) {
    this.asyncQueue = e, this.onlineStateHandler = t, /** The current OnlineState. */
    this.state = "Unknown", /**
     * A count of consecutive failures to open the stream. If it reaches the
     * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
     * Offline.
     */
    this.sa = 0, /**
     * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
     * transition from OnlineState.Unknown to OnlineState.Offline without waiting
     * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
     */
    this.oa = null, /**
     * Whether the client should log a warning message if it fails to connect to
     * the backend (initially true, cleared after a successful stream, or if we've
     * logged the message already).
     */
    this._a = true;
  }
  /**
   * Called by RemoteStore when a watch stream is started (including on each
   * backoff attempt).
   *
   * If this is the first attempt, it sets the OnlineState to Unknown and starts
   * the onlineStateTimer.
   */
  aa() {
    0 === this.sa && (this.ua(
      "Unknown"
      /* OnlineState.Unknown */
    ), this.oa = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.oa = null, this.ca("Backend didn't respond within 10 seconds."), this.ua(
      "Offline"
      /* OnlineState.Offline */
    ), Promise.resolve())));
  }
  /**
   * Updates our OnlineState as appropriate after the watch stream reports a
   * failure. The first failure moves us to the 'Unknown' state. We then may
   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
   * actually transition to the 'Offline' state.
   */
  la(e) {
    "Online" === this.state ? this.ua(
      "Unknown"
      /* OnlineState.Unknown */
    ) : (this.sa++, this.sa >= 1 && (this.ha(), this.ca(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.ua(
      "Offline"
      /* OnlineState.Offline */
    )));
  }
  /**
   * Explicitly sets the OnlineState to the specified state.
   *
   * Note that this resets our timers / failure counters, etc. used by our
   * Offline heuristics, so must not be used in place of
   * handleWatchStreamStart() and handleWatchStreamFailure().
   */
  set(e) {
    this.ha(), this.sa = 0, "Online" === e && // We've connected to watch at least once. Don't warn the developer
    // about being offline going forward.
    (this._a = false), this.ua(e);
  }
  ua(e) {
    e !== this.state && (this.state = e, this.onlineStateHandler(e));
  }
  ca(e) {
    const t = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this._a ? (__PRIVATE_logError(t), this._a = false) : __PRIVATE_logDebug("OnlineStateTracker", t);
  }
  ha() {
    null !== this.oa && (this.oa.cancel(), this.oa = null);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Xt = "RemoteStore";
class __PRIVATE_RemoteStoreImpl {
  constructor(e, t, n, r, i) {
    this.localStore = e, this.datastore = t, this.asyncQueue = n, this.remoteSyncer = {}, /**
     * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
     * LocalStore via fillWritePipeline() and have or will send to the write
     * stream.
     *
     * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
     * restart the write stream. When the stream is established the writes in the
     * pipeline will be sent in order.
     *
     * Writes remain in writePipeline until they are acknowledged by the backend
     * and thus will automatically be re-sent if the stream is interrupted /
     * restarted before they're acknowledged.
     *
     * Write responses from the backend are linked to their originating request
     * purely based on order, and so we can just shift() writes from the front of
     * the writePipeline as we receive responses.
     */
    this.Pa = [], /**
     * A mapping of watched targets that the client cares about tracking and the
     * user has explicitly called a 'listen' for this target.
     *
     * These targets may or may not have been sent to or acknowledged by the
     * server. On re-establishing the listen stream, these targets should be sent
     * to the server. The targets removed with unlistens are removed eagerly
     * without waiting for confirmation from the listen stream.
     */
    this.Ta = /* @__PURE__ */ new Map(), /**
     * A set of reasons for why the RemoteStore may be offline. If empty, the
     * RemoteStore may start its network connections.
     */
    this.Ia = /* @__PURE__ */ new Set(), /**
     * Event handlers that get called when the network is disabled or enabled.
     *
     * PORTING NOTE: These functions are used on the Web client to create the
     * underlying streams (to support tree-shakeable streams). On Android and iOS,
     * the streams are created during construction of RemoteStore.
     */
    this.da = [], this.Ea = i, this.Ea.xo((e2) => {
      n.enqueueAndForget(async () => {
        __PRIVATE_canUseNetwork(this) && (__PRIVATE_logDebug(Xt, "Restarting streams for network reachability change."), await async function __PRIVATE_restartNetwork(e3) {
          const t2 = __PRIVATE_debugCast(e3);
          t2.Ia.add(
            4
            /* OfflineCause.ConnectivityChange */
          ), await __PRIVATE_disableNetworkInternal(t2), t2.Aa.set(
            "Unknown"
            /* OnlineState.Unknown */
          ), t2.Ia.delete(
            4
            /* OfflineCause.ConnectivityChange */
          ), await __PRIVATE_enableNetworkInternal(t2);
        }(this));
      });
    }), this.Aa = new __PRIVATE_OnlineStateTracker(n, r);
  }
}
async function __PRIVATE_enableNetworkInternal(e) {
  if (__PRIVATE_canUseNetwork(e)) for (const t of e.da) await t(
    /* enabled= */
    true
  );
}
async function __PRIVATE_disableNetworkInternal(e) {
  for (const t of e.da) await t(
    /* enabled= */
    false
  );
}
function __PRIVATE_remoteStoreListen(e, t) {
  const n = __PRIVATE_debugCast(e);
  n.Ta.has(t.targetId) || // Mark this as something the client is currently listening for.
  (n.Ta.set(t.targetId, t), __PRIVATE_shouldStartWatchStream(n) ? (
    // The listen will be sent in onWatchStreamOpen
    __PRIVATE_startWatchStream(n)
  ) : __PRIVATE_ensureWatchStream(n).x_() && __PRIVATE_sendWatchRequest(n, t));
}
function __PRIVATE_remoteStoreUnlisten(e, t) {
  const n = __PRIVATE_debugCast(e), r = __PRIVATE_ensureWatchStream(n);
  n.Ta.delete(t), r.x_() && __PRIVATE_sendUnwatchRequest(n, t), 0 === n.Ta.size && (r.x_() ? r.B_() : __PRIVATE_canUseNetwork(n) && // Revert to OnlineState.Unknown if the watch stream is not open and we
  // have no listeners, since without any listens to send we cannot
  // confirm if the stream is healthy and upgrade to OnlineState.Online.
  n.Aa.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function __PRIVATE_sendWatchRequest(e, t) {
  if (e.Ra.$e(t.targetId), t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
    const n = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;
    t = t.withExpectedCount(n);
  }
  __PRIVATE_ensureWatchStream(e).H_(t);
}
function __PRIVATE_sendUnwatchRequest(e, t) {
  e.Ra.$e(t), __PRIVATE_ensureWatchStream(e).Y_(t);
}
function __PRIVATE_startWatchStream(e) {
  e.Ra = new __PRIVATE_WatchChangeAggregator({
    getRemoteKeysForTarget: (t) => e.remoteSyncer.getRemoteKeysForTarget(t),
    Et: (t) => e.Ta.get(t) || null,
    lt: () => e.datastore.serializer.databaseId
  }), __PRIVATE_ensureWatchStream(e).start(), e.Aa.aa();
}
function __PRIVATE_shouldStartWatchStream(e) {
  return __PRIVATE_canUseNetwork(e) && !__PRIVATE_ensureWatchStream(e).M_() && e.Ta.size > 0;
}
function __PRIVATE_canUseNetwork(e) {
  return 0 === __PRIVATE_debugCast(e).Ia.size;
}
function __PRIVATE_cleanUpWatchStreamState(e) {
  e.Ra = void 0;
}
async function __PRIVATE_onWatchStreamConnected(e) {
  e.Aa.set(
    "Online"
    /* OnlineState.Online */
  );
}
async function __PRIVATE_onWatchStreamOpen(e) {
  e.Ta.forEach((t, n) => {
    __PRIVATE_sendWatchRequest(e, t);
  });
}
async function __PRIVATE_onWatchStreamClose(e, t) {
  __PRIVATE_cleanUpWatchStreamState(e), // If we still need the watch stream, retry the connection.
  __PRIVATE_shouldStartWatchStream(e) ? (e.Aa.la(t), __PRIVATE_startWatchStream(e)) : (
    // No need to restart watch stream because there are no active targets.
    // The online state is set to unknown because there is no active attempt
    // at establishing a connection
    e.Aa.set(
      "Unknown"
      /* OnlineState.Unknown */
    )
  );
}
async function __PRIVATE_onWatchStreamChange(e, t, n) {
  if (
    // Mark the client as online since we got a message from the server
    e.Aa.set(
      "Online"
      /* OnlineState.Online */
    ), t instanceof __PRIVATE_WatchTargetChange && 2 === t.state && t.cause
  )
    try {
      await async function __PRIVATE_handleTargetError(e2, t2) {
        const n2 = t2.cause;
        for (const r of t2.targetIds)
          e2.Ta.has(r) && (await e2.remoteSyncer.rejectListen(r, n2), e2.Ta.delete(r), e2.Ra.removeTarget(r));
      }(e, t);
    } catch (n2) {
      __PRIVATE_logDebug(Xt, "Failed to remove targets %s: %s ", t.targetIds.join(","), n2), await __PRIVATE_disableNetworkUntilRecovery(e, n2);
    }
  else if (t instanceof __PRIVATE_DocumentWatchChange ? e.Ra.Ye(t) : t instanceof __PRIVATE_ExistenceFilterChange ? e.Ra.it(t) : e.Ra.et(t), !n.isEqual(SnapshotVersion.min())) try {
    const t2 = await __PRIVATE_localStoreGetLastRemoteSnapshotVersion(e.localStore);
    n.compareTo(t2) >= 0 && // We have received a target change with a global snapshot if the snapshot
    // version is not equal to SnapshotVersion.min().
    /**
    * Takes a batch of changes from the Datastore, repackages them as a
    * RemoteEvent, and passes that on to the listener, which is typically the
    * SyncEngine.
    */
    await function __PRIVATE_raiseWatchSnapshot(e2, t3) {
      const n2 = e2.Ra.Pt(t3);
      return n2.targetChanges.forEach((n3, r) => {
        if (n3.resumeToken.approximateByteSize() > 0) {
          const i = e2.Ta.get(r);
          i && e2.Ta.set(r, i.withResumeToken(n3.resumeToken, t3));
        }
      }), // Re-establish listens for the targets that have been invalidated by
      // existence filter mismatches.
      n2.targetMismatches.forEach((t4, n3) => {
        const r = e2.Ta.get(t4);
        if (!r)
          return;
        e2.Ta.set(t4, r.withResumeToken(ByteString.EMPTY_BYTE_STRING, r.snapshotVersion)), // Cause a hard reset by unwatching and rewatching immediately, but
        // deliberately don't send a resume token so that we get a full update.
        __PRIVATE_sendUnwatchRequest(e2, t4);
        const i = new TargetData(r.target, t4, n3, r.sequenceNumber);
        __PRIVATE_sendWatchRequest(e2, i);
      }), e2.remoteSyncer.applyRemoteEvent(n2);
    }(e, n);
  } catch (t2) {
    __PRIVATE_logDebug(Xt, "Failed to raise snapshot:", t2), await __PRIVATE_disableNetworkUntilRecovery(e, t2);
  }
}
async function __PRIVATE_disableNetworkUntilRecovery(e, t, n) {
  if (!__PRIVATE_isIndexedDbTransactionError(t)) throw t;
  e.Ia.add(
    1
    /* OfflineCause.IndexedDbFailed */
  ), // Disable network and raise offline snapshots
  await __PRIVATE_disableNetworkInternal(e), e.Aa.set(
    "Offline"
    /* OnlineState.Offline */
  ), n || // Use a simple read operation to determine if IndexedDB recovered.
  // Ideally, we would expose a health check directly on SimpleDb, but
  // RemoteStore only has access to persistence through LocalStore.
  (n = () => __PRIVATE_localStoreGetLastRemoteSnapshotVersion(e.localStore)), // Probe IndexedDB periodically and re-enable network
  e.asyncQueue.enqueueRetryable(async () => {
    __PRIVATE_logDebug(Xt, "Retrying IndexedDB access"), await n(), e.Ia.delete(
      1
      /* OfflineCause.IndexedDbFailed */
    ), await __PRIVATE_enableNetworkInternal(e);
  });
}
function __PRIVATE_executeWithRecovery(e, t) {
  return t().catch((n) => __PRIVATE_disableNetworkUntilRecovery(e, n, t));
}
async function __PRIVATE_fillWritePipeline(e) {
  const t = __PRIVATE_debugCast(e), n = __PRIVATE_ensureWriteStream(t);
  let r = t.Pa.length > 0 ? t.Pa[t.Pa.length - 1].batchId : G;
  for (; __PRIVATE_canAddToWritePipeline(t); ) try {
    const e2 = await __PRIVATE_localStoreGetNextMutationBatch(t.localStore, r);
    if (null === e2) {
      0 === t.Pa.length && n.B_();
      break;
    }
    r = e2.batchId, __PRIVATE_addToWritePipeline(t, e2);
  } catch (e2) {
    await __PRIVATE_disableNetworkUntilRecovery(t, e2);
  }
  __PRIVATE_shouldStartWriteStream(t) && __PRIVATE_startWriteStream(t);
}
function __PRIVATE_canAddToWritePipeline(e) {
  return __PRIVATE_canUseNetwork(e) && e.Pa.length < 10;
}
function __PRIVATE_addToWritePipeline(e, t) {
  e.Pa.push(t);
  const n = __PRIVATE_ensureWriteStream(e);
  n.x_() && n.Z_ && n.X_(t.mutations);
}
function __PRIVATE_shouldStartWriteStream(e) {
  return __PRIVATE_canUseNetwork(e) && !__PRIVATE_ensureWriteStream(e).M_() && e.Pa.length > 0;
}
function __PRIVATE_startWriteStream(e) {
  __PRIVATE_ensureWriteStream(e).start();
}
async function __PRIVATE_onWriteStreamOpen(e) {
  __PRIVATE_ensureWriteStream(e).na();
}
async function __PRIVATE_onWriteHandshakeComplete(e) {
  const t = __PRIVATE_ensureWriteStream(e);
  for (const n of e.Pa) t.X_(n.mutations);
}
async function __PRIVATE_onMutationResult(e, t, n) {
  const r = e.Pa.shift(), i = MutationBatchResult.from(r, t, n);
  await __PRIVATE_executeWithRecovery(e, () => e.remoteSyncer.applySuccessfulWrite(i)), // It's possible that with the completion of this mutation another
  // slot has freed up.
  await __PRIVATE_fillWritePipeline(e);
}
async function __PRIVATE_onWriteStreamClose(e, t) {
  t && __PRIVATE_ensureWriteStream(e).Z_ && // This error affects the actual write.
  await async function __PRIVATE_handleWriteError(e2, t2) {
    if (function __PRIVATE_isPermanentWriteError(e3) {
      return __PRIVATE_isPermanentError(e3) && e3 !== N.ABORTED;
    }(t2.code)) {
      const n = e2.Pa.shift();
      __PRIVATE_ensureWriteStream(e2).N_(), await __PRIVATE_executeWithRecovery(e2, () => e2.remoteSyncer.rejectFailedWrite(n.batchId, t2)), // It's possible that with the completion of this mutation
      // another slot has freed up.
      await __PRIVATE_fillWritePipeline(e2);
    }
  }(e, t), // The write stream might have been started by refilling the write
  // pipeline for failed writes
  __PRIVATE_shouldStartWriteStream(e) && __PRIVATE_startWriteStream(e);
}
async function __PRIVATE_remoteStoreHandleCredentialChange(e, t) {
  const n = __PRIVATE_debugCast(e);
  n.asyncQueue.verifyOperationInProgress(), __PRIVATE_logDebug(Xt, "RemoteStore received new credentials");
  const r = __PRIVATE_canUseNetwork(n);
  n.Ia.add(
    3
    /* OfflineCause.CredentialChange */
  ), await __PRIVATE_disableNetworkInternal(n), r && // Don't set the network status to Unknown if we are offline.
  n.Aa.set(
    "Unknown"
    /* OnlineState.Unknown */
  ), await n.remoteSyncer.handleCredentialChange(t), n.Ia.delete(
    3
    /* OfflineCause.CredentialChange */
  ), await __PRIVATE_enableNetworkInternal(n);
}
async function __PRIVATE_remoteStoreApplyPrimaryState(e, t) {
  const n = __PRIVATE_debugCast(e);
  t ? (n.Ia.delete(
    2
    /* OfflineCause.IsSecondary */
  ), await __PRIVATE_enableNetworkInternal(n)) : t || (n.Ia.add(
    2
    /* OfflineCause.IsSecondary */
  ), await __PRIVATE_disableNetworkInternal(n), n.Aa.set(
    "Unknown"
    /* OnlineState.Unknown */
  ));
}
function __PRIVATE_ensureWatchStream(e) {
  return e.Va || // Create stream (but note that it is not started yet).
  (e.Va = function __PRIVATE_newPersistentWatchStream(e2, t, n) {
    const r = __PRIVATE_debugCast(e2);
    return r.ia(), new __PRIVATE_PersistentListenStream(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n);
  }(e.datastore, e.asyncQueue, {
    Zo: __PRIVATE_onWatchStreamConnected.bind(null, e),
    e_: __PRIVATE_onWatchStreamOpen.bind(null, e),
    n_: __PRIVATE_onWatchStreamClose.bind(null, e),
    J_: __PRIVATE_onWatchStreamChange.bind(null, e)
  }), e.da.push(async (t) => {
    t ? (e.Va.N_(), __PRIVATE_shouldStartWatchStream(e) ? __PRIVATE_startWatchStream(e) : e.Aa.set(
      "Unknown"
      /* OnlineState.Unknown */
    )) : (await e.Va.stop(), __PRIVATE_cleanUpWatchStreamState(e));
  })), e.Va;
}
function __PRIVATE_ensureWriteStream(e) {
  return e.ma || // Create stream (but note that it is not started yet).
  (e.ma = function __PRIVATE_newPersistentWriteStream(e2, t, n) {
    const r = __PRIVATE_debugCast(e2);
    return r.ia(), new __PRIVATE_PersistentWriteStream(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n);
  }(e.datastore, e.asyncQueue, {
    Zo: () => Promise.resolve(),
    e_: __PRIVATE_onWriteStreamOpen.bind(null, e),
    n_: __PRIVATE_onWriteStreamClose.bind(null, e),
    ea: __PRIVATE_onWriteHandshakeComplete.bind(null, e),
    ta: __PRIVATE_onMutationResult.bind(null, e)
  }), e.da.push(async (t) => {
    t ? (e.ma.N_(), // This will start the write stream if necessary.
    await __PRIVATE_fillWritePipeline(e)) : (await e.ma.stop(), e.Pa.length > 0 && (__PRIVATE_logDebug(Xt, `Stopping write stream with ${e.Pa.length} pending writes`), e.Pa = []));
  })), e.ma;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DelayedOperation {
  constructor(e, t, n, r, i) {
    this.asyncQueue = e, this.timerId = t, this.targetTimeMs = n, this.op = r, this.removalCallback = i, this.deferred = new __PRIVATE_Deferred(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
    // and so we attach a dummy catch callback to avoid
    // 'UnhandledPromiseRejectionWarning' log spam.
    this.deferred.promise.catch((e2) => {
    });
  }
  get promise() {
    return this.deferred.promise;
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(e, t, n, r, i) {
    const s = Date.now() + n, o = new DelayedOperation(e, t, s, r, i);
    return o.start(n), o;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(e) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(e) {
    null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new FirestoreError(N.CANCELLED, "Operation cancelled" + (e ? ": " + e : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((e) => this.deferred.resolve(e))) : Promise.resolve());
  }
  clearTimeout() {
    null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
function __PRIVATE_wrapInUserErrorIfRecoverable(e, t) {
  if (__PRIVATE_logError("AsyncQueue", `${t}: ${e}`), __PRIVATE_isIndexedDbTransactionError(e)) return new FirestoreError(N.UNAVAILABLE, `${t}: ${e}`);
  throw e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentSet {
  /**
   * Returns an empty copy of the existing DocumentSet, using the same
   * comparator.
   */
  static emptySet(e) {
    return new DocumentSet(e.comparator);
  }
  /** The default ordering is by key if the comparator is omitted */
  constructor(e) {
    this.comparator = e ? (t, n) => e(t, n) || DocumentKey.comparator(t.key, n.key) : (e2, t) => DocumentKey.comparator(e2.key, t.key), this.keyedMap = documentMap(), this.sortedSet = new SortedMap(this.comparator);
  }
  has(e) {
    return null != this.keyedMap.get(e);
  }
  get(e) {
    return this.keyedMap.get(e);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  /**
   * Returns the index of the provided key in the document set, or -1 if the
   * document key is not present in the set;
   */
  indexOf(e) {
    const t = this.keyedMap.get(e);
    return t ? this.sortedSet.indexOf(t) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  /** Iterates documents in order defined by "comparator" */
  forEach(e) {
    this.sortedSet.inorderTraversal((t, n) => (e(t), false));
  }
  /** Inserts or updates a document with the same key */
  add(e) {
    const t = this.delete(e.key);
    return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null));
  }
  /** Deletes a document with a given key */
  delete(e) {
    const t = this.get(e);
    return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this;
  }
  isEqual(e) {
    if (!(e instanceof DocumentSet)) return false;
    if (this.size !== e.size) return false;
    const t = this.sortedSet.getIterator(), n = e.sortedSet.getIterator();
    for (; t.hasNext(); ) {
      const e2 = t.getNext().key, r = n.getNext().key;
      if (!e2.isEqual(r)) return false;
    }
    return true;
  }
  toString() {
    const e = [];
    return this.forEach((t) => {
      e.push(t.toString());
    }), 0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)";
  }
  copy(e, t) {
    const n = new DocumentSet();
    return n.comparator = this.comparator, n.keyedMap = e, n.sortedSet = t, n;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_DocumentChangeSet {
  constructor() {
    this.fa = new SortedMap(DocumentKey.comparator);
  }
  track(e) {
    const t = e.doc.key, n = this.fa.get(t);
    n ? (
      // Merge the new change with the existing change.
      0 !== e.type && 3 === n.type ? this.fa = this.fa.insert(t, e) : 3 === e.type && 1 !== n.type ? this.fa = this.fa.insert(t, {
        type: n.type,
        doc: e.doc
      }) : 2 === e.type && 2 === n.type ? this.fa = this.fa.insert(t, {
        type: 2,
        doc: e.doc
      }) : 2 === e.type && 0 === n.type ? this.fa = this.fa.insert(t, {
        type: 0,
        doc: e.doc
      }) : 1 === e.type && 0 === n.type ? this.fa = this.fa.remove(t) : 1 === e.type && 2 === n.type ? this.fa = this.fa.insert(t, {
        type: 1,
        doc: n.doc
      }) : 0 === e.type && 1 === n.type ? this.fa = this.fa.insert(t, {
        type: 2,
        doc: e.doc
      }) : (
        // This includes these cases, which don't make sense:
        // Added->Added
        // Removed->Removed
        // Modified->Added
        // Removed->Modified
        // Metadata->Added
        // Removed->Metadata
        fail(63341, {
          At: e,
          ga: n
        })
      )
    ) : this.fa = this.fa.insert(t, e);
  }
  pa() {
    const e = [];
    return this.fa.inorderTraversal((t, n) => {
      e.push(n);
    }), e;
  }
}
class ViewSnapshot {
  constructor(e, t, n, r, i, s, o, _, a) {
    this.query = e, this.docs = t, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = i, this.fromCache = s, this.syncStateChanged = o, this.excludesMetadataChanges = _, this.hasCachedResults = a;
  }
  /** Returns a view snapshot as if all documents in the snapshot were added. */
  static fromInitialDocuments(e, t, n, r, i) {
    const s = [];
    return t.forEach((e2) => {
      s.push({
        type: 0,
        doc: e2
      });
    }), new ViewSnapshot(
      e,
      t,
      DocumentSet.emptySet(t),
      s,
      n,
      r,
      /* syncStateChanged= */
      true,
      /* excludesMetadataChanges= */
      false,
      i
    );
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(e) {
    if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && __PRIVATE_queryEquals(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return false;
    const t = this.docChanges, n = e.docChanges;
    if (t.length !== n.length) return false;
    for (let e2 = 0; e2 < t.length; e2++) if (t[e2].type !== n[e2].type || !t[e2].doc.isEqual(n[e2].doc)) return false;
    return true;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_QueryListenersInfo {
  constructor() {
    this.ya = void 0, this.wa = [];
  }
  // Helper methods that checks if the query has listeners that listening to remote store
  Sa() {
    return this.wa.some((e) => e.ba());
  }
}
class __PRIVATE_EventManagerImpl {
  constructor() {
    this.queries = __PRIVATE_newQueriesObjectMap(), this.onlineState = "Unknown", this.Da = /* @__PURE__ */ new Set();
  }
  terminate() {
    !function __PRIVATE_errorAllTargets(e, t) {
      const n = __PRIVATE_debugCast(e), r = n.queries;
      n.queries = __PRIVATE_newQueriesObjectMap(), r.forEach((e2, n2) => {
        for (const e3 of n2.wa) e3.onError(t);
      });
    }(this, new FirestoreError(N.ABORTED, "Firestore shutting down"));
  }
}
function __PRIVATE_newQueriesObjectMap() {
  return new ObjectMap((e) => __PRIVATE_canonifyQuery(e), __PRIVATE_queryEquals);
}
async function __PRIVATE_eventManagerListen(e, t) {
  const n = __PRIVATE_debugCast(e);
  let r = 3;
  const i = t.query;
  let s = n.queries.get(i);
  s ? !s.Sa() && t.ba() && // Query has been listening to local cache, and tries to add a new listener sourced from watch.
  (r = 2) : (s = new __PRIVATE_QueryListenersInfo(), r = t.ba() ? 0 : 1);
  try {
    switch (r) {
      case 0:
        s.ya = await n.onListen(
          i,
          /** enableRemoteListen= */
          true
        );
        break;
      case 1:
        s.ya = await n.onListen(
          i,
          /** enableRemoteListen= */
          false
        );
        break;
      case 2:
        await n.onFirstRemoteStoreListen(i);
    }
  } catch (e2) {
    const n2 = __PRIVATE_wrapInUserErrorIfRecoverable(e2, `Initialization of query '${__PRIVATE_stringifyQuery(t.query)}' failed`);
    return void t.onError(n2);
  }
  if (n.queries.set(i, s), s.wa.push(t), // Run global snapshot listeners if a consistent snapshot has been emitted.
  t.va(n.onlineState), s.ya) {
    t.Ca(s.ya) && __PRIVATE_raiseSnapshotsInSyncEvent(n);
  }
}
async function __PRIVATE_eventManagerUnlisten(e, t) {
  const n = __PRIVATE_debugCast(e), r = t.query;
  let i = 3;
  const s = n.queries.get(r);
  if (s) {
    const e2 = s.wa.indexOf(t);
    e2 >= 0 && (s.wa.splice(e2, 1), 0 === s.wa.length ? i = t.ba() ? 0 : 1 : !s.Sa() && t.ba() && // The removed listener is the last one that sourced from watch.
    (i = 2));
  }
  switch (i) {
    case 0:
      return n.queries.delete(r), n.onUnlisten(
        r,
        /** disableRemoteListen= */
        true
      );
    case 1:
      return n.queries.delete(r), n.onUnlisten(
        r,
        /** disableRemoteListen= */
        false
      );
    case 2:
      return n.onLastRemoteStoreUnlisten(r);
    default:
      return;
  }
}
function __PRIVATE_eventManagerOnWatchChange(e, t) {
  const n = __PRIVATE_debugCast(e);
  let r = false;
  for (const e2 of t) {
    const t2 = e2.query, i = n.queries.get(t2);
    if (i) {
      for (const t3 of i.wa) t3.Ca(e2) && (r = true);
      i.ya = e2;
    }
  }
  r && __PRIVATE_raiseSnapshotsInSyncEvent(n);
}
function __PRIVATE_eventManagerOnWatchError(e, t, n) {
  const r = __PRIVATE_debugCast(e), i = r.queries.get(t);
  if (i) for (const e2 of i.wa) e2.onError(n);
  r.queries.delete(t);
}
function __PRIVATE_raiseSnapshotsInSyncEvent(e) {
  e.Da.forEach((e2) => {
    e2.next();
  });
}
var en, tn;
(tn = en || (en = {})).Fa = "default", /** Listen to changes in cache only */
tn.Cache = "cache";
class __PRIVATE_QueryListener {
  constructor(e, t, n) {
    this.query = e, this.Ma = t, /**
     * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
     * observer. This flag is set to true once we've actually raised an event.
     */
    this.xa = false, this.Oa = null, this.onlineState = "Unknown", this.options = n || {};
  }
  /**
   * Applies the new ViewSnapshot to this listener, raising a user-facing event
   * if applicable (depending on what changed, whether the user has opted into
   * metadata-only changes, etc.). Returns true if a user-facing event was
   * indeed raised.
   */
  Ca(e) {
    if (!this.options.includeMetadataChanges) {
      const t2 = [];
      for (const n of e.docChanges) 3 !== n.type && t2.push(n);
      e = new ViewSnapshot(
        e.query,
        e.docs,
        e.oldDocs,
        t2,
        e.mutatedKeys,
        e.fromCache,
        e.syncStateChanged,
        /* excludesMetadataChanges= */
        true,
        e.hasCachedResults
      );
    }
    let t = false;
    return this.xa ? this.Na(e) && (this.Ma.next(e), t = true) : this.Ba(e, this.onlineState) && (this.La(e), t = true), this.Oa = e, t;
  }
  onError(e) {
    this.Ma.error(e);
  }
  /** Returns whether a snapshot was raised. */
  va(e) {
    this.onlineState = e;
    let t = false;
    return this.Oa && !this.xa && this.Ba(this.Oa, e) && (this.La(this.Oa), t = true), t;
  }
  Ba(e, t) {
    if (!e.fromCache) return true;
    if (!this.ba()) return true;
    const n = "Offline" !== t;
    return (!this.options.ka || !n) && (!e.docs.isEmpty() || e.hasCachedResults || "Offline" === t);
  }
  Na(e) {
    if (e.docChanges.length > 0) return true;
    const t = this.Oa && this.Oa.hasPendingWrites !== e.hasPendingWrites;
    return !(!e.syncStateChanged && !t) && true === this.options.includeMetadataChanges;
  }
  La(e) {
    e = ViewSnapshot.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.xa = true, this.Ma.next(e);
  }
  ba() {
    return this.options.source !== en.Cache;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_AddedLimboDocument {
  constructor(e) {
    this.key = e;
  }
}
class __PRIVATE_RemovedLimboDocument {
  constructor(e) {
    this.key = e;
  }
}
class __PRIVATE_View {
  constructor(e, t) {
    this.query = e, this.Ha = t, this.Ya = null, this.hasCachedResults = false, /**
     * A flag whether the view is current with the backend. A view is considered
     * current after it has seen the current flag from the backend and did not
     * lose consistency within the watch stream (e.g. because of an existence
     * filter mismatch).
     */
    this.current = false, /** Documents in the view but not in the remote target */
    this.Za = __PRIVATE_documentKeySet(), /** Document Keys that have local changes */
    this.mutatedKeys = __PRIVATE_documentKeySet(), this.Xa = __PRIVATE_newQueryComparator(e), this.eu = new DocumentSet(this.Xa);
  }
  /**
   * The set of remote documents that the server has told us belongs to the target associated with
   * this view.
   */
  get tu() {
    return this.Ha;
  }
  /**
   * Iterates over a set of doc changes, applies the query limit, and computes
   * what the new results should be, what the changes were, and whether we may
   * need to go back to the local cache for more results. Does not make any
   * changes to the view.
   * @param docChanges - The doc changes to apply to this view.
   * @param previousChanges - If this is being called with a refill, then start
   *        with this set of docs and changes instead of the current view.
   * @returns a new set of docs, changes, and refill flag.
   */
  nu(e, t) {
    const n = t ? t.ru : new __PRIVATE_DocumentChangeSet(), r = t ? t.eu : this.eu;
    let i = t ? t.mutatedKeys : this.mutatedKeys, s = r, o = false;
    const _ = "F" === this.query.limitType && r.size === this.query.limit ? r.last() : null, a = "L" === this.query.limitType && r.size === this.query.limit ? r.first() : null;
    if (e.inorderTraversal((e2, t2) => {
      const u = r.get(e2), c = __PRIVATE_queryMatches(this.query, t2) ? t2 : null, l = !!u && this.mutatedKeys.has(u.key), h = !!c && (c.hasLocalMutations || // We only consider committed mutations for documents that were
      // mutated during the lifetime of the view.
      this.mutatedKeys.has(c.key) && c.hasCommittedMutations);
      let P = false;
      if (u && c) {
        u.data.isEqual(c.data) ? l !== h && (n.track({
          type: 3,
          doc: c
        }), P = true) : this.iu(u, c) || (n.track({
          type: 2,
          doc: c
        }), P = true, (_ && this.Xa(c, _) > 0 || a && this.Xa(c, a) < 0) && // This doc moved from inside the limit to outside the limit.
        // That means there may be some other doc in the local cache
        // that should be included instead.
        (o = true));
      } else !u && c ? (n.track({
        type: 0,
        doc: c
      }), P = true) : u && !c && (n.track({
        type: 1,
        doc: u
      }), P = true, (_ || a) && // A doc was removed from a full limit query. We'll need to
      // requery from the local cache to see if we know about some other
      // doc that should be in the results.
      (o = true));
      P && (c ? (s = s.add(c), i = h ? i.add(e2) : i.delete(e2)) : (s = s.delete(e2), i = i.delete(e2)));
    }), null !== this.query.limit) for (; s.size > this.query.limit; ) {
      const e2 = "F" === this.query.limitType ? s.last() : s.first();
      s = s.delete(e2.key), i = i.delete(e2.key), n.track({
        type: 1,
        doc: e2
      });
    }
    return {
      eu: s,
      ru: n,
      Ds: o,
      mutatedKeys: i
    };
  }
  iu(e, t) {
    return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations;
  }
  /**
   * Updates the view with the given ViewDocumentChanges and optionally updates
   * limbo docs and sync state from the provided target change.
   * @param docChanges - The set of changes to make to the view's docs.
   * @param limboResolutionEnabled - Whether to update limbo documents based on
   *        this change.
   * @param targetChange - A target change to apply for computing limbo docs and
   *        sync state.
   * @param targetIsPendingReset - Whether the target is pending to reset due to
   *        existence filter mismatch. If not explicitly specified, it is treated
   *        equivalently to `false`.
   * @returns A new ViewChange with the given docs, changes, and sync state.
   */
  // PORTING NOTE: The iOS/Android clients always compute limbo document changes.
  applyChanges(e, t, n, r) {
    const i = this.eu;
    this.eu = e.eu, this.mutatedKeys = e.mutatedKeys;
    const s = e.ru.pa();
    s.sort((e2, t2) => function __PRIVATE_compareChangeType(e3, t3) {
      const order = (e4) => {
        switch (e4) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return fail(20277, {
              At: e4
            });
        }
      };
      return order(e3) - order(t3);
    }(e2.type, t2.type) || this.Xa(e2.doc, t2.doc)), this.su(n), r = null != r && r;
    const o = t && !r ? this.ou() : [], _ = 0 === this.Za.size && this.current && !r ? 1 : 0, a = _ !== this.Ya;
    if (this.Ya = _, 0 !== s.length || a) {
      return {
        snapshot: new ViewSnapshot(
          this.query,
          e.eu,
          i,
          s,
          e.mutatedKeys,
          0 === _,
          a,
          /* excludesMetadataChanges= */
          false,
          !!n && n.resumeToken.approximateByteSize() > 0
        ),
        _u: o
      };
    }
    return {
      _u: o
    };
  }
  /**
   * Applies an OnlineState change to the view, potentially generating a
   * ViewChange if the view's syncState changes as a result.
   */
  va(e) {
    return this.current && "Offline" === e ? (
      // If we're offline, set `current` to false and then call applyChanges()
      // to refresh our syncState and generate a ViewChange as appropriate. We
      // are guaranteed to get a new TargetChange that sets `current` back to
      // true once the client is back online.
      (this.current = false, this.applyChanges(
        {
          eu: this.eu,
          ru: new __PRIVATE_DocumentChangeSet(),
          mutatedKeys: this.mutatedKeys,
          Ds: false
        },
        /* limboResolutionEnabled= */
        false
      ))
    ) : {
      _u: []
    };
  }
  /**
   * Returns whether the doc for the given key should be in limbo.
   */
  au(e) {
    return !this.Ha.has(e) && // The local store doesn't think it's a result, so it shouldn't be in limbo.
    (!!this.eu.has(e) && !this.eu.get(e).hasLocalMutations);
  }
  /**
   * Updates syncedDocuments, current, and limbo docs based on the given change.
   * Returns the list of changes to which docs are in limbo.
   */
  su(e) {
    e && (e.addedDocuments.forEach((e2) => this.Ha = this.Ha.add(e2)), e.modifiedDocuments.forEach((e2) => {
    }), e.removedDocuments.forEach((e2) => this.Ha = this.Ha.delete(e2)), this.current = e.current);
  }
  ou() {
    if (!this.current) return [];
    const e = this.Za;
    this.Za = __PRIVATE_documentKeySet(), this.eu.forEach((e2) => {
      this.au(e2.key) && (this.Za = this.Za.add(e2.key));
    });
    const t = [];
    return e.forEach((e2) => {
      this.Za.has(e2) || t.push(new __PRIVATE_RemovedLimboDocument(e2));
    }), this.Za.forEach((n) => {
      e.has(n) || t.push(new __PRIVATE_AddedLimboDocument(n));
    }), t;
  }
  /**
   * Update the in-memory state of the current view with the state read from
   * persistence.
   *
   * We update the query view whenever a client's primary status changes:
   * - When a client transitions from primary to secondary, it can miss
   *   LocalStorage updates and its query views may temporarily not be
   *   synchronized with the state on disk.
   * - For secondary to primary transitions, the client needs to update the list
   *   of `syncedDocuments` since secondary clients update their query views
   *   based purely on synthesized RemoteEvents.
   *
   * @param queryResult.documents - The documents that match the query according
   * to the LocalStore.
   * @param queryResult.remoteKeys - The keys of the documents that match the
   * query according to the backend.
   *
   * @returns The ViewChange that resulted from this synchronization.
   */
  // PORTING NOTE: Multi-tab only.
  uu(e) {
    this.Ha = e.qs, this.Za = __PRIVATE_documentKeySet();
    const t = this.nu(e.documents);
    return this.applyChanges(
      t,
      /* limboResolutionEnabled= */
      true
    );
  }
  /**
   * Returns a view snapshot as if this query was just listened to. Contains
   * a document add for every existing document and the `fromCache` and
   * `hasPendingWrites` status of the already established view.
   */
  // PORTING NOTE: Multi-tab only.
  cu() {
    return ViewSnapshot.fromInitialDocuments(this.query, this.eu, this.mutatedKeys, 0 === this.Ya, this.hasCachedResults);
  }
}
const nn = "SyncEngine";
class __PRIVATE_QueryView {
  constructor(e, t, n) {
    this.query = e, this.targetId = t, this.view = n;
  }
}
class LimboResolution {
  constructor(e) {
    this.key = e, /**
     * Set to true once we've received a document. This is used in
     * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to
     * decide whether it needs to manufacture a delete event for the target once
     * the target is CURRENT.
     */
    this.lu = false;
  }
}
class __PRIVATE_SyncEngineImpl {
  constructor(e, t, n, r, i, s) {
    this.localStore = e, this.remoteStore = t, this.eventManager = n, this.sharedClientState = r, this.currentUser = i, this.maxConcurrentLimboResolutions = s, this.hu = {}, this.Pu = new ObjectMap((e2) => __PRIVATE_canonifyQuery(e2), __PRIVATE_queryEquals), this.Tu = /* @__PURE__ */ new Map(), /**
     * The keys of documents that are in limbo for which we haven't yet started a
     * limbo resolution query. The strings in this set are the result of calling
     * `key.path.canonicalString()` where `key` is a `DocumentKey` object.
     *
     * The `Set` type was chosen because it provides efficient lookup and removal
     * of arbitrary elements and it also maintains insertion order, providing the
     * desired queue-like FIFO semantics.
     */
    this.Iu = /* @__PURE__ */ new Set(), /**
     * Keeps track of the target ID for each document that is in limbo with an
     * active target.
     */
    this.du = new SortedMap(DocumentKey.comparator), /**
     * Keeps track of the information about an active limbo resolution for each
     * active target ID that was started for the purpose of limbo resolution.
     */
    this.Eu = /* @__PURE__ */ new Map(), this.Au = new __PRIVATE_ReferenceSet(), /** Stores user completion handlers, indexed by User and BatchId. */
    this.Ru = {}, /** Stores user callbacks waiting for all pending writes to be acknowledged. */
    this.Vu = /* @__PURE__ */ new Map(), this.mu = __PRIVATE_TargetIdGenerator.ur(), this.onlineState = "Unknown", // The primary state is set to `true` or `false` immediately after Firestore
    // startup. In the interim, a client should only be considered primary if
    // `isPrimary` is true.
    this.fu = void 0;
  }
  get isPrimaryClient() {
    return true === this.fu;
  }
}
async function __PRIVATE_syncEngineListen(e, t, n = true) {
  const r = __PRIVATE_ensureWatchCallbacks(e);
  let i;
  const s = r.Pu.get(t);
  return s ? (
    // PORTING NOTE: With Multi-Tab Web, it is possible that a query view
    // already exists when EventManager calls us for the first time. This
    // happens when the primary tab is already listening to this query on
    // behalf of another tab and the user of the primary also starts listening
    // to the query. EventManager will not have an assigned target ID in this
    // case and calls `listen` to obtain this ID.
    (r.sharedClientState.addLocalQueryTarget(s.targetId), i = s.view.cu())
  ) : i = await __PRIVATE_allocateTargetAndMaybeListen(
    r,
    t,
    n,
    /** shouldInitializeView= */
    true
  ), i;
}
async function __PRIVATE_triggerRemoteStoreListen(e, t) {
  const n = __PRIVATE_ensureWatchCallbacks(e);
  await __PRIVATE_allocateTargetAndMaybeListen(
    n,
    t,
    /** shouldListenToRemote= */
    true,
    /** shouldInitializeView= */
    false
  );
}
async function __PRIVATE_allocateTargetAndMaybeListen(e, t, n, r) {
  const i = await __PRIVATE_localStoreAllocateTarget(e.localStore, __PRIVATE_queryToTarget(t)), s = i.targetId, o = e.sharedClientState.addLocalQueryTarget(s, n);
  let _;
  return r && (_ = await __PRIVATE_initializeViewAndComputeSnapshot(e, t, s, "current" === o, i.resumeToken)), e.isPrimaryClient && n && __PRIVATE_remoteStoreListen(e.remoteStore, i), _;
}
async function __PRIVATE_initializeViewAndComputeSnapshot(e, t, n, r, i) {
  e.gu = (t2, n2, r2) => async function __PRIVATE_applyDocChanges(e2, t3, n3, r3) {
    let i2 = t3.view.nu(n3);
    i2.Ds && // The query has a limit and some docs were removed, so we need
    // to re-run the query against the local store to make sure we
    // didn't lose any good docs that had been past the limit.
    (i2 = await __PRIVATE_localStoreExecuteQuery(
      e2.localStore,
      t3.query,
      /* usePreviousResults= */
      false
    ).then(({ documents: e3 }) => t3.view.nu(e3, i2)));
    const s2 = r3 && r3.targetChanges.get(t3.targetId), o2 = r3 && null != r3.targetMismatches.get(t3.targetId), _2 = t3.view.applyChanges(
      i2,
      /* limboResolutionEnabled= */
      e2.isPrimaryClient,
      s2,
      o2
    );
    return __PRIVATE_updateTrackedLimbos(e2, t3.targetId, _2._u), _2.snapshot;
  }(e, t2, n2, r2);
  const s = await __PRIVATE_localStoreExecuteQuery(
    e.localStore,
    t,
    /* usePreviousResults= */
    true
  ), o = new __PRIVATE_View(t, s.qs), _ = o.nu(s.documents), a = TargetChange.createSynthesizedTargetChangeForCurrentChange(n, r && "Offline" !== e.onlineState, i), u = o.applyChanges(
    _,
    /* limboResolutionEnabled= */
    e.isPrimaryClient,
    a
  );
  __PRIVATE_updateTrackedLimbos(e, n, u._u);
  const c = new __PRIVATE_QueryView(t, n, o);
  return e.Pu.set(t, c), e.Tu.has(n) ? e.Tu.get(n).push(t) : e.Tu.set(n, [t]), u.snapshot;
}
async function __PRIVATE_syncEngineUnlisten(e, t, n) {
  const r = __PRIVATE_debugCast(e), i = r.Pu.get(t), s = r.Tu.get(i.targetId);
  if (s.length > 1) return r.Tu.set(i.targetId, s.filter((e2) => !__PRIVATE_queryEquals(e2, t))), void r.Pu.delete(t);
  if (r.isPrimaryClient) {
    r.sharedClientState.removeLocalQueryTarget(i.targetId);
    r.sharedClientState.isActiveQueryTarget(i.targetId) || await __PRIVATE_localStoreReleaseTarget(
      r.localStore,
      i.targetId,
      /*keepPersistedTargetData=*/
      false
    ).then(() => {
      r.sharedClientState.clearQueryState(i.targetId), n && __PRIVATE_remoteStoreUnlisten(r.remoteStore, i.targetId), __PRIVATE_removeAndCleanupTarget(r, i.targetId);
    }).catch(__PRIVATE_ignoreIfPrimaryLeaseLoss);
  } else __PRIVATE_removeAndCleanupTarget(r, i.targetId), await __PRIVATE_localStoreReleaseTarget(
    r.localStore,
    i.targetId,
    /*keepPersistedTargetData=*/
    true
  );
}
async function __PRIVATE_triggerRemoteStoreUnlisten(e, t) {
  const n = __PRIVATE_debugCast(e), r = n.Pu.get(t), i = n.Tu.get(r.targetId);
  n.isPrimaryClient && 1 === i.length && // PORTING NOTE: Unregister the target ID with local Firestore client as
  // watch target.
  (n.sharedClientState.removeLocalQueryTarget(r.targetId), __PRIVATE_remoteStoreUnlisten(n.remoteStore, r.targetId));
}
async function __PRIVATE_syncEngineWrite(e, t, n) {
  const r = __PRIVATE_syncEngineEnsureWriteCallbacks(e);
  try {
    const e2 = await function __PRIVATE_localStoreWriteLocally(e3, t2) {
      const n2 = __PRIVATE_debugCast(e3), r2 = Timestamp.now(), i = t2.reduce((e4, t3) => e4.add(t3.key), __PRIVATE_documentKeySet());
      let s, o;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (e4) => {
        let _ = __PRIVATE_mutableDocumentMap(), a = __PRIVATE_documentKeySet();
        return n2.Os.getEntries(e4, i).next((e5) => {
          _ = e5, _.forEach((e6, t3) => {
            t3.isValidDocument() || (a = a.add(e6));
          });
        }).next(() => n2.localDocuments.getOverlayedDocuments(e4, _)).next((i2) => {
          s = i2;
          const o2 = [];
          for (const e5 of t2) {
            const t3 = __PRIVATE_mutationExtractBaseValue(e5, s.get(e5.key).overlayedDocument);
            null != t3 && // NOTE: The base state should only be applied if there's some
            // existing document to override, so use a Precondition of
            // exists=true
            o2.push(new __PRIVATE_PatchMutation(e5.key, t3, __PRIVATE_extractFieldMask(t3.value.mapValue), Precondition.exists(true)));
          }
          return n2.mutationQueue.addMutationBatch(e4, r2, o2, t2);
        }).next((t3) => {
          o = t3;
          const r3 = t3.applyToLocalDocumentSet(s, a);
          return n2.documentOverlayCache.saveOverlays(e4, t3.batchId, r3);
        });
      }).then(() => ({
        batchId: o.batchId,
        changes: __PRIVATE_convertOverlayedDocumentMapToDocumentMap(s)
      }));
    }(r.localStore, t);
    r.sharedClientState.addPendingMutation(e2.batchId), function __PRIVATE_addMutationCallback(e3, t2, n2) {
      let r2 = e3.Ru[e3.currentUser.toKey()];
      r2 || (r2 = new SortedMap(__PRIVATE_primitiveComparator));
      r2 = r2.insert(t2, n2), e3.Ru[e3.currentUser.toKey()] = r2;
    }(r, e2.batchId, n), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(r, e2.changes), await __PRIVATE_fillWritePipeline(r.remoteStore);
  } catch (e2) {
    const t2 = __PRIVATE_wrapInUserErrorIfRecoverable(e2, "Failed to persist write");
    n.reject(t2);
  }
}
async function __PRIVATE_syncEngineApplyRemoteEvent(e, t) {
  const n = __PRIVATE_debugCast(e);
  try {
    const e2 = await __PRIVATE_localStoreApplyRemoteEventToLocalCache(n.localStore, t);
    t.targetChanges.forEach((e3, t2) => {
      const r = n.Eu.get(t2);
      r && // Since this is a limbo resolution lookup, it's for a single document
      // and it could be added, modified, or removed, but not a combination.
      (__PRIVATE_hardAssert(e3.addedDocuments.size + e3.modifiedDocuments.size + e3.removedDocuments.size <= 1, 22616), e3.addedDocuments.size > 0 ? r.lu = true : e3.modifiedDocuments.size > 0 ? __PRIVATE_hardAssert(r.lu, 14607) : e3.removedDocuments.size > 0 && (__PRIVATE_hardAssert(r.lu, 42227), r.lu = false));
    }), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(n, e2, t);
  } catch (e2) {
    await __PRIVATE_ignoreIfPrimaryLeaseLoss(e2);
  }
}
function __PRIVATE_syncEngineApplyOnlineStateChange(e, t, n) {
  const r = __PRIVATE_debugCast(e);
  if (r.isPrimaryClient && 0 === n || !r.isPrimaryClient && 1 === n) {
    const e2 = [];
    r.Pu.forEach((n2, r2) => {
      const i = r2.view.va(t);
      i.snapshot && e2.push(i.snapshot);
    }), function __PRIVATE_eventManagerOnOnlineStateChange(e3, t2) {
      const n2 = __PRIVATE_debugCast(e3);
      n2.onlineState = t2;
      let r2 = false;
      n2.queries.forEach((e4, n3) => {
        for (const e5 of n3.wa)
          e5.va(t2) && (r2 = true);
      }), r2 && __PRIVATE_raiseSnapshotsInSyncEvent(n2);
    }(r.eventManager, t), e2.length && r.hu.J_(e2), r.onlineState = t, r.isPrimaryClient && r.sharedClientState.setOnlineState(t);
  }
}
async function __PRIVATE_syncEngineRejectListen(e, t, n) {
  const r = __PRIVATE_debugCast(e);
  r.sharedClientState.updateQueryState(t, "rejected", n);
  const i = r.Eu.get(t), s = i && i.key;
  if (s) {
    let e2 = new SortedMap(DocumentKey.comparator);
    e2 = e2.insert(s, MutableDocument.newNoDocument(s, SnapshotVersion.min()));
    const n2 = __PRIVATE_documentKeySet().add(s), i2 = new RemoteEvent(
      SnapshotVersion.min(),
      /* targetChanges= */
      /* @__PURE__ */ new Map(),
      /* targetMismatches= */
      new SortedMap(__PRIVATE_primitiveComparator),
      e2,
      n2
    );
    await __PRIVATE_syncEngineApplyRemoteEvent(r, i2), // Since this query failed, we won't want to manually unlisten to it.
    // We only remove it from bookkeeping after we successfully applied the
    // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to
    // this query when the RemoteStore restarts the Watch stream, which should
    // re-trigger the target failure.
    r.du = r.du.remove(s), r.Eu.delete(t), __PRIVATE_pumpEnqueuedLimboResolutions(r);
  } else await __PRIVATE_localStoreReleaseTarget(
    r.localStore,
    t,
    /* keepPersistedTargetData */
    false
  ).then(() => __PRIVATE_removeAndCleanupTarget(r, t, n)).catch(__PRIVATE_ignoreIfPrimaryLeaseLoss);
}
async function __PRIVATE_syncEngineApplySuccessfulWrite(e, t) {
  const n = __PRIVATE_debugCast(e), r = t.batch.batchId;
  try {
    const e2 = await __PRIVATE_localStoreAcknowledgeBatch(n.localStore, t);
    __PRIVATE_processUserCallback(
      n,
      r,
      /*error=*/
      null
    ), __PRIVATE_triggerPendingWritesCallbacks(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(n, e2);
  } catch (e2) {
    await __PRIVATE_ignoreIfPrimaryLeaseLoss(e2);
  }
}
async function __PRIVATE_syncEngineRejectFailedWrite(e, t, n) {
  const r = __PRIVATE_debugCast(e);
  try {
    const e2 = await function __PRIVATE_localStoreRejectBatch(e3, t2) {
      const n2 = __PRIVATE_debugCast(e3);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (e4) => {
        let r2;
        return n2.mutationQueue.lookupMutationBatch(e4, t2).next((t3) => (__PRIVATE_hardAssert(null !== t3, 37113), r2 = t3.keys(), n2.mutationQueue.removeMutationBatch(e4, t3))).next(() => n2.mutationQueue.performConsistencyCheck(e4)).next(() => n2.documentOverlayCache.removeOverlaysForBatchId(e4, r2, t2)).next(() => n2.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e4, r2)).next(() => n2.localDocuments.getDocuments(e4, r2));
      });
    }(r.localStore, t);
    __PRIVATE_processUserCallback(r, t, n), __PRIVATE_triggerPendingWritesCallbacks(r, t), r.sharedClientState.updateMutationState(t, "rejected", n), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(r, e2);
  } catch (n2) {
    await __PRIVATE_ignoreIfPrimaryLeaseLoss(n2);
  }
}
function __PRIVATE_triggerPendingWritesCallbacks(e, t) {
  (e.Vu.get(t) || []).forEach((e2) => {
    e2.resolve();
  }), e.Vu.delete(t);
}
function __PRIVATE_processUserCallback(e, t, n) {
  const r = __PRIVATE_debugCast(e);
  let i = r.Ru[r.currentUser.toKey()];
  if (i) {
    const e2 = i.get(t);
    e2 && (n ? e2.reject(n) : e2.resolve(), i = i.remove(t)), r.Ru[r.currentUser.toKey()] = i;
  }
}
function __PRIVATE_removeAndCleanupTarget(e, t, n = null) {
  e.sharedClientState.removeLocalQueryTarget(t);
  for (const r of e.Tu.get(t)) e.Pu.delete(r), n && e.hu.pu(r, n);
  if (e.Tu.delete(t), e.isPrimaryClient) {
    e.Au.zr(t).forEach((t2) => {
      e.Au.containsKey(t2) || // We removed the last reference for this key
      __PRIVATE_removeLimboTarget(e, t2);
    });
  }
}
function __PRIVATE_removeLimboTarget(e, t) {
  e.Iu.delete(t.path.canonicalString());
  const n = e.du.get(t);
  null !== n && (__PRIVATE_remoteStoreUnlisten(e.remoteStore, n), e.du = e.du.remove(t), e.Eu.delete(n), __PRIVATE_pumpEnqueuedLimboResolutions(e));
}
function __PRIVATE_updateTrackedLimbos(e, t, n) {
  for (const r of n) if (r instanceof __PRIVATE_AddedLimboDocument) e.Au.addReference(r.key, t), __PRIVATE_trackLimboChange(e, r);
  else if (r instanceof __PRIVATE_RemovedLimboDocument) {
    __PRIVATE_logDebug(nn, "Document no longer in limbo: " + r.key), e.Au.removeReference(r.key, t);
    e.Au.containsKey(r.key) || // We removed the last reference for this key
    __PRIVATE_removeLimboTarget(e, r.key);
  } else fail(19791, {
    yu: r
  });
}
function __PRIVATE_trackLimboChange(e, t) {
  const n = t.key, r = n.path.canonicalString();
  e.du.get(n) || e.Iu.has(r) || (__PRIVATE_logDebug(nn, "New document in limbo: " + n), e.Iu.add(r), __PRIVATE_pumpEnqueuedLimboResolutions(e));
}
function __PRIVATE_pumpEnqueuedLimboResolutions(e) {
  for (; e.Iu.size > 0 && e.du.size < e.maxConcurrentLimboResolutions; ) {
    const t = e.Iu.values().next().value;
    e.Iu.delete(t);
    const n = new DocumentKey(ResourcePath.fromString(t)), r = e.mu.next();
    e.Eu.set(r, new LimboResolution(n)), e.du = e.du.insert(n, r), __PRIVATE_remoteStoreListen(e.remoteStore, new TargetData(__PRIVATE_queryToTarget(__PRIVATE_newQueryForPath(n.path)), r, "TargetPurposeLimboResolution", __PRIVATE_ListenSequence.ue));
  }
}
async function __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(e, t, n) {
  const r = __PRIVATE_debugCast(e), i = [], s = [], o = [];
  r.Pu.isEmpty() || (r.Pu.forEach((e2, _) => {
    o.push(r.gu(_, t, n).then((e3) => {
      var t2;
      if ((e3 || n) && r.isPrimaryClient) {
        const i2 = e3 ? !e3.fromCache : null === (t2 = null == n ? void 0 : n.targetChanges.get(_.targetId)) || void 0 === t2 ? void 0 : t2.current;
        r.sharedClientState.updateQueryState(_.targetId, i2 ? "current" : "not-current");
      }
      if (e3) {
        i.push(e3);
        const t3 = __PRIVATE_LocalViewChanges.Es(_.targetId, e3);
        s.push(t3);
      }
    }));
  }), await Promise.all(o), r.hu.J_(i), await async function __PRIVATE_localStoreNotifyLocalViewChanges(e2, t2) {
    const n2 = __PRIVATE_debugCast(e2);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (e3) => PersistencePromise.forEach(t2, (t3) => PersistencePromise.forEach(t3.Is, (r2) => n2.persistence.referenceDelegate.addReference(e3, t3.targetId, r2)).next(() => PersistencePromise.forEach(t3.ds, (r2) => n2.persistence.referenceDelegate.removeReference(e3, t3.targetId, r2)))));
    } catch (e3) {
      if (!__PRIVATE_isIndexedDbTransactionError(e3)) throw e3;
      __PRIVATE_logDebug(Qt, "Failed to update sequence numbers: " + e3);
    }
    for (const e3 of t2) {
      const t3 = e3.targetId;
      if (!e3.fromCache) {
        const e4 = n2.Fs.get(t3), r2 = e4.snapshotVersion, i2 = e4.withLastLimboFreeSnapshotVersion(r2);
        n2.Fs = n2.Fs.insert(t3, i2);
      }
    }
  }(r.localStore, s));
}
async function __PRIVATE_syncEngineHandleCredentialChange(e, t) {
  const n = __PRIVATE_debugCast(e);
  if (!n.currentUser.isEqual(t)) {
    __PRIVATE_logDebug(nn, "User change. New user:", t.toKey());
    const e2 = await __PRIVATE_localStoreHandleUserChange(n.localStore, t);
    n.currentUser = t, // Fails tasks waiting for pending writes requested by previous user.
    function __PRIVATE_rejectOutstandingPendingWritesCallbacks(e3, t2) {
      e3.Vu.forEach((e4) => {
        e4.forEach((e5) => {
          e5.reject(new FirestoreError(N.CANCELLED, t2));
        });
      }), e3.Vu.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), // TODO(b/114226417): Consider calling this only in the primary tab.
    n.sharedClientState.handleUserChange(t, e2.removedBatchIds, e2.addedBatchIds), await __PRIVATE_syncEngineEmitNewSnapsAndNotifyLocalStore(n, e2.Bs);
  }
}
function __PRIVATE_syncEngineGetRemoteKeysForTarget(e, t) {
  const n = __PRIVATE_debugCast(e), r = n.Eu.get(t);
  if (r && r.lu) return __PRIVATE_documentKeySet().add(r.key);
  {
    let e2 = __PRIVATE_documentKeySet();
    const r2 = n.Tu.get(t);
    if (!r2) return e2;
    for (const t2 of r2) {
      const r3 = n.Pu.get(t2);
      e2 = e2.unionWith(r3.view.tu);
    }
    return e2;
  }
}
function __PRIVATE_ensureWatchCallbacks(e) {
  const t = __PRIVATE_debugCast(e);
  return t.remoteStore.remoteSyncer.applyRemoteEvent = __PRIVATE_syncEngineApplyRemoteEvent.bind(null, t), t.remoteStore.remoteSyncer.getRemoteKeysForTarget = __PRIVATE_syncEngineGetRemoteKeysForTarget.bind(null, t), t.remoteStore.remoteSyncer.rejectListen = __PRIVATE_syncEngineRejectListen.bind(null, t), t.hu.J_ = __PRIVATE_eventManagerOnWatchChange.bind(null, t.eventManager), t.hu.pu = __PRIVATE_eventManagerOnWatchError.bind(null, t.eventManager), t;
}
function __PRIVATE_syncEngineEnsureWriteCallbacks(e) {
  const t = __PRIVATE_debugCast(e);
  return t.remoteStore.remoteSyncer.applySuccessfulWrite = __PRIVATE_syncEngineApplySuccessfulWrite.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = __PRIVATE_syncEngineRejectFailedWrite.bind(null, t), t;
}
class __PRIVATE_MemoryOfflineComponentProvider {
  constructor() {
    this.kind = "memory", this.synchronizeTabs = false;
  }
  async initialize(e) {
    this.serializer = __PRIVATE_newSerializer(e.databaseInfo.databaseId), this.sharedClientState = this.bu(e), this.persistence = this.Du(e), await this.persistence.start(), this.localStore = this.vu(e), this.gcScheduler = this.Cu(e, this.localStore), this.indexBackfillerScheduler = this.Fu(e, this.localStore);
  }
  Cu(e, t) {
    return null;
  }
  Fu(e, t) {
    return null;
  }
  vu(e) {
    return __PRIVATE_newLocalStore(this.persistence, new __PRIVATE_QueryEngine(), e.initialUser, this.serializer);
  }
  Du(e) {
    return new __PRIVATE_MemoryPersistence(__PRIVATE_MemoryEagerDelegate.Vi, this.serializer);
  }
  bu(e) {
    return new __PRIVATE_MemorySharedClientState();
  }
  async terminate() {
    var e, t;
    null === (e = this.gcScheduler) || void 0 === e || e.stop(), null === (t = this.indexBackfillerScheduler) || void 0 === t || t.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
}
__PRIVATE_MemoryOfflineComponentProvider.provider = {
  build: () => new __PRIVATE_MemoryOfflineComponentProvider()
};
class __PRIVATE_LruGcMemoryOfflineComponentProvider extends __PRIVATE_MemoryOfflineComponentProvider {
  constructor(e) {
    super(), this.cacheSizeBytes = e;
  }
  Cu(e, t) {
    __PRIVATE_hardAssert(this.persistence.referenceDelegate instanceof __PRIVATE_MemoryLruDelegate, 46915);
    const n = this.persistence.referenceDelegate.garbageCollector;
    return new __PRIVATE_LruScheduler(n, e.asyncQueue, t);
  }
  Du(e) {
    const t = void 0 !== this.cacheSizeBytes ? LruParams.withCacheSize(this.cacheSizeBytes) : LruParams.DEFAULT;
    return new __PRIVATE_MemoryPersistence((e2) => __PRIVATE_MemoryLruDelegate.Vi(e2, t), this.serializer);
  }
}
class OnlineComponentProvider {
  async initialize(e, t) {
    this.localStore || (this.localStore = e.localStore, this.sharedClientState = e.sharedClientState, this.datastore = this.createDatastore(t), this.remoteStore = this.createRemoteStore(t), this.eventManager = this.createEventManager(t), this.syncEngine = this.createSyncEngine(
      t,
      /* startAsPrimary=*/
      !e.synchronizeTabs
    ), this.sharedClientState.onlineStateHandler = (e2) => __PRIVATE_syncEngineApplyOnlineStateChange(
      this.syncEngine,
      e2,
      1
      /* OnlineStateSource.SharedClientState */
    ), this.remoteStore.remoteSyncer.handleCredentialChange = __PRIVATE_syncEngineHandleCredentialChange.bind(null, this.syncEngine), await __PRIVATE_remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(e) {
    return function __PRIVATE_newEventManager() {
      return new __PRIVATE_EventManagerImpl();
    }();
  }
  createDatastore(e) {
    const t = __PRIVATE_newSerializer(e.databaseInfo.databaseId), n = function __PRIVATE_newConnection(e2) {
      return new __PRIVATE_WebChannelConnection(e2);
    }(e.databaseInfo);
    return function __PRIVATE_newDatastore(e2, t2, n2, r) {
      return new __PRIVATE_DatastoreImpl(e2, t2, n2, r);
    }(e.authCredentials, e.appCheckCredentials, n, t);
  }
  createRemoteStore(e) {
    return function __PRIVATE_newRemoteStore(e2, t, n, r, i) {
      return new __PRIVATE_RemoteStoreImpl(e2, t, n, r, i);
    }(this.localStore, this.datastore, e.asyncQueue, (e2) => __PRIVATE_syncEngineApplyOnlineStateChange(
      this.syncEngine,
      e2,
      0
      /* OnlineStateSource.RemoteStore */
    ), function __PRIVATE_newConnectivityMonitor() {
      return __PRIVATE_BrowserConnectivityMonitor.C() ? new __PRIVATE_BrowserConnectivityMonitor() : new __PRIVATE_NoopConnectivityMonitor();
    }());
  }
  createSyncEngine(e, t) {
    return function __PRIVATE_newSyncEngine(e2, t2, n, r, i, s, o) {
      const _ = new __PRIVATE_SyncEngineImpl(e2, t2, n, r, i, s);
      return o && (_.fu = true), _;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t);
  }
  async terminate() {
    var e, t;
    await async function __PRIVATE_remoteStoreShutdown(e2) {
      const t2 = __PRIVATE_debugCast(e2);
      __PRIVATE_logDebug(Xt, "RemoteStore shutting down."), t2.Ia.add(
        5
        /* OfflineCause.Shutdown */
      ), await __PRIVATE_disableNetworkInternal(t2), t2.Ea.shutdown(), // Set the OnlineState to Unknown (rather than Offline) to avoid potentially
      // triggering spurious listener events with cached data, etc.
      t2.Aa.set(
        "Unknown"
        /* OnlineState.Unknown */
      );
    }(this.remoteStore), null === (e = this.datastore) || void 0 === e || e.terminate(), null === (t = this.eventManager) || void 0 === t || t.terminate();
  }
}
OnlineComponentProvider.provider = {
  build: () => new OnlineComponentProvider()
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class __PRIVATE_AsyncObserver {
  constructor(e) {
    this.observer = e, /**
     * When set to true, will not raise future events. Necessary to deal with
     * async detachment of listener.
     */
    this.muted = false;
  }
  next(e) {
    this.muted || this.observer.next && this.xu(this.observer.next, e);
  }
  error(e) {
    this.muted || (this.observer.error ? this.xu(this.observer.error, e) : __PRIVATE_logError("Uncaught Error in snapshot listener:", e.toString()));
  }
  Ou() {
    this.muted = true;
  }
  xu(e, t) {
    setTimeout(() => {
      this.muted || e(t);
    }, 0);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const rn = "FirestoreClient";
class FirestoreClient {
  constructor(e, t, n, r, i) {
    this.authCredentials = e, this.appCheckCredentials = t, this.asyncQueue = n, this.databaseInfo = r, this.user = User.UNAUTHENTICATED, this.clientId = __PRIVATE_AutoId.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this._uninitializedComponentsProvider = i, this.authCredentials.start(n, async (e2) => {
      __PRIVATE_logDebug(rn, "Received user=", e2.uid), await this.authCredentialListener(e2), this.user = e2;
    }), this.appCheckCredentials.start(n, (e2) => (__PRIVATE_logDebug(rn, "Received new app check token=", e2), this.appCheckCredentialListener(e2, this.user)));
  }
  get configuration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(e) {
    this.authCredentialListener = e;
  }
  setAppCheckTokenChangeListener(e) {
    this.appCheckCredentialListener = e;
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const e = new __PRIVATE_Deferred();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), // The credentials provider must be terminated after shutting down the
        // RemoteStore as it will prevent the RemoteStore from retrieving auth
        // tokens.
        this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve();
      } catch (t) {
        const n = __PRIVATE_wrapInUserErrorIfRecoverable(t, "Failed to shutdown persistence");
        e.reject(n);
      }
    }), e.promise;
  }
}
async function __PRIVATE_setOfflineComponentProvider(e, t) {
  e.asyncQueue.verifyOperationInProgress(), __PRIVATE_logDebug(rn, "Initializing OfflineComponentProvider");
  const n = e.configuration;
  await t.initialize(n);
  let r = n.initialUser;
  e.setCredentialChangeListener(async (e2) => {
    r.isEqual(e2) || (await __PRIVATE_localStoreHandleUserChange(t.localStore, e2), r = e2);
  }), t.persistence.setDatabaseDeletedListener(() => {
    __PRIVATE_logWarn("Terminating Firestore due to IndexedDb database deletion"), e.terminate().then(() => {
      __PRIVATE_logDebug("Terminating Firestore due to IndexedDb database deletion completed successfully");
    }).catch((e2) => {
      __PRIVATE_logWarn("Terminating Firestore due to IndexedDb database deletion failed", e2);
    });
  }), e._offlineComponents = t;
}
async function __PRIVATE_setOnlineComponentProvider(e, t) {
  e.asyncQueue.verifyOperationInProgress();
  const n = await __PRIVATE_ensureOfflineComponents(e);
  __PRIVATE_logDebug(rn, "Initializing OnlineComponentProvider"), await t.initialize(n, e.configuration), // The CredentialChangeListener of the online component provider takes
  // precedence over the offline component provider.
  e.setCredentialChangeListener((e2) => __PRIVATE_remoteStoreHandleCredentialChange(t.remoteStore, e2)), e.setAppCheckTokenChangeListener((e2, n2) => __PRIVATE_remoteStoreHandleCredentialChange(t.remoteStore, n2)), e._onlineComponents = t;
}
async function __PRIVATE_ensureOfflineComponents(e) {
  if (!e._offlineComponents) if (e._uninitializedComponentsProvider) {
    __PRIVATE_logDebug(rn, "Using user provided OfflineComponentProvider");
    try {
      await __PRIVATE_setOfflineComponentProvider(e, e._uninitializedComponentsProvider._offline);
    } catch (t) {
      const n = t;
      if (!function __PRIVATE_canFallbackFromIndexedDbError(e2) {
        return "FirebaseError" === e2.name ? e2.code === N.FAILED_PRECONDITION || e2.code === N.UNIMPLEMENTED : !("undefined" != typeof DOMException && e2 instanceof DOMException) || // When the browser is out of quota we could get either quota exceeded
        // or an aborted error depending on whether the error happened during
        // schema migration.
        22 === e2.code || 20 === e2.code || // Firefox Private Browsing mode disables IndexedDb and returns
        // INVALID_STATE for any usage.
        11 === e2.code;
      }(n)) throw n;
      __PRIVATE_logWarn("Error using user provided cache. Falling back to memory cache: " + n), await __PRIVATE_setOfflineComponentProvider(e, new __PRIVATE_MemoryOfflineComponentProvider());
    }
  } else __PRIVATE_logDebug(rn, "Using default OfflineComponentProvider"), await __PRIVATE_setOfflineComponentProvider(e, new __PRIVATE_LruGcMemoryOfflineComponentProvider(void 0));
  return e._offlineComponents;
}
async function __PRIVATE_ensureOnlineComponents(e) {
  return e._onlineComponents || (e._uninitializedComponentsProvider ? (__PRIVATE_logDebug(rn, "Using user provided OnlineComponentProvider"), await __PRIVATE_setOnlineComponentProvider(e, e._uninitializedComponentsProvider._online)) : (__PRIVATE_logDebug(rn, "Using default OnlineComponentProvider"), await __PRIVATE_setOnlineComponentProvider(e, new OnlineComponentProvider()))), e._onlineComponents;
}
function __PRIVATE_getSyncEngine(e) {
  return __PRIVATE_ensureOnlineComponents(e).then((e2) => e2.syncEngine);
}
async function __PRIVATE_getEventManager(e) {
  const t = await __PRIVATE_ensureOnlineComponents(e), n = t.eventManager;
  return n.onListen = __PRIVATE_syncEngineListen.bind(null, t.syncEngine), n.onUnlisten = __PRIVATE_syncEngineUnlisten.bind(null, t.syncEngine), n.onFirstRemoteStoreListen = __PRIVATE_triggerRemoteStoreListen.bind(null, t.syncEngine), n.onLastRemoteStoreUnlisten = __PRIVATE_triggerRemoteStoreUnlisten.bind(null, t.syncEngine), n;
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_cloneLongPollingOptions(e) {
  const t = {};
  return void 0 !== e.timeoutSeconds && (t.timeoutSeconds = e.timeoutSeconds), t;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sn = /* @__PURE__ */ new Map();
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const on = "firestore.googleapis.com", _n = true;
class FirestoreSettingsImpl {
  constructor(e) {
    var t, n;
    if (void 0 === e.host) {
      if (void 0 !== e.ssl) throw new FirestoreError(N.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = on, this.ssl = _n;
    } else this.host = e.host, this.ssl = null !== (t = e.ssl) && void 0 !== t ? t : _n;
    if (this.isUsingEmulator = void 0 !== e.emulatorOptions, this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.localCache = e.localCache, void 0 === e.cacheSizeBytes) this.cacheSizeBytes = Mt;
    else {
      if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < Ot) throw new FirestoreError(N.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    __PRIVATE_validateIsNotUsedTogether("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = false : void 0 === e.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = true : (
      // For backwards compatibility, coerce the value to boolean even though
      // the TypeScript compiler has narrowed the type to boolean already.
      // noinspection PointlessBooleanExpressionJS
      this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling
    ), this.experimentalLongPollingOptions = __PRIVATE_cloneLongPollingOptions(null !== (n = e.experimentalLongPollingOptions) && void 0 !== n ? n : {}), function __PRIVATE_validateLongPollingOptions(e2) {
      if (void 0 !== e2.timeoutSeconds) {
        if (isNaN(e2.timeoutSeconds)) throw new FirestoreError(N.INVALID_ARGUMENT, `invalid long polling timeout: ${e2.timeoutSeconds} (must not be NaN)`);
        if (e2.timeoutSeconds < 5) throw new FirestoreError(N.INVALID_ARGUMENT, `invalid long polling timeout: ${e2.timeoutSeconds} (minimum allowed value is 5)`);
        if (e2.timeoutSeconds > 30) throw new FirestoreError(N.INVALID_ARGUMENT, `invalid long polling timeout: ${e2.timeoutSeconds} (maximum allowed value is 30)`);
      }
    }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e.useFetchStreams;
  }
  isEqual(e) {
    return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && function __PRIVATE_longPollingOptionsEqual(e2, t) {
      return e2.timeoutSeconds === t.timeoutSeconds;
    }(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams;
  }
}
class Firestore$1 {
  /** @hideconstructor */
  constructor(e, t, n, r) {
    this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = n, this._app = r, /**
     * Whether it's a Firestore or Firestore Lite instance.
     */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new FirestoreSettingsImpl({}), this._settingsFrozen = false, this._emulatorOptions = {}, // A task that is assigned when the terminate() is invoked and resolved when
    // all components have shut down. Otherwise, Firestore is not terminated,
    // which can mean either the FirestoreClient is in the process of starting,
    // or restarting.
    this._terminateTask = "notTerminated";
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app) throw new FirestoreError(N.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return "notTerminated" !== this._terminateTask;
  }
  _setSettings(e) {
    if (this._settingsFrozen) throw new FirestoreError(N.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new FirestoreSettingsImpl(e), this._emulatorOptions = e.emulatorOptions || {}, void 0 !== e.credentials && (this._authCredentials = function __PRIVATE_makeAuthCredentialsProvider(e2) {
      if (!e2) return new __PRIVATE_EmptyAuthCredentialsProvider();
      switch (e2.type) {
        case "firstParty":
          return new __PRIVATE_FirstPartyAuthCredentialsProvider(e2.sessionIndex || "0", e2.iamToken || null, e2.authTokenFactory || null);
        case "provider":
          return e2.client;
        default:
          throw new FirestoreError(N.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _getEmulatorOptions() {
    return this._emulatorOptions;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return "notTerminated" === this._terminateTask && (this._terminateTask = this._terminate()), this._terminateTask;
  }
  async _restart() {
    "notTerminated" === this._terminateTask ? await this._terminate() : this._terminateTask = "notTerminated";
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function __PRIVATE_removeComponents(e) {
      const t = sn.get(e);
      t && (__PRIVATE_logDebug("ComponentProvider", "Removing Datastore"), sn.delete(e), t.terminate());
    }(this), Promise.resolve();
  }
}
function connectFirestoreEmulator(e, t, n, r = {}) {
  var i;
  e = __PRIVATE_cast(e, Firestore$1);
  const s = isCloudWorkstation(t), o = e._getSettings(), _ = Object.assign(Object.assign({}, o), {
    emulatorOptions: e._getEmulatorOptions()
  }), a = `${t}:${n}`;
  s && (pingServer(`https://${a}`), updateEmulatorBanner("Firestore", true)), o.host !== on && o.host !== a && __PRIVATE_logWarn("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.");
  const u = Object.assign(Object.assign({}, o), {
    host: a,
    ssl: s,
    emulatorOptions: r
  });
  if (!deepEqual(u, _) && (e._setSettings(u), r.mockUserToken)) {
    let t2, n2;
    if ("string" == typeof r.mockUserToken) t2 = r.mockUserToken, n2 = User.MOCK_USER;
    else {
      t2 = createMockUserToken(r.mockUserToken, null === (i = e._app) || void 0 === i ? void 0 : i.options.projectId);
      const s2 = r.mockUserToken.sub || r.mockUserToken.user_id;
      if (!s2) throw new FirestoreError(N.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new User(s2);
    }
    e._authCredentials = new __PRIVATE_EmulatorAuthCredentialsProvider(new __PRIVATE_OAuthToken(t2, n2));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Query {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(e, t, n) {
    this.converter = t, this._query = n, /** The type of this Firestore reference. */
    this.type = "query", this.firestore = e;
  }
  withConverter(e) {
    return new Query(this.firestore, e, this._query);
  }
}
class DocumentReference {
  /** @hideconstructor */
  constructor(e, t, n) {
    this.converter = t, this._key = n, /** The type of this Firestore reference. */
    this.type = "document", this.firestore = e;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(e) {
    return new DocumentReference(this.firestore, e, this._key);
  }
  /**
   * Returns a JSON-serializable representation of this `DocumentReference` instance.
   *
   * @returns a JSON representation of this object.
   */
  toJSON() {
    return {
      type: DocumentReference._jsonSchemaVersion,
      referencePath: this._key.toString()
    };
  }
  static fromJSON(e, t, n) {
    if (__PRIVATE_validateJSON(t, DocumentReference._jsonSchema)) return new DocumentReference(e, n || null, new DocumentKey(ResourcePath.fromString(t.referencePath)));
  }
}
DocumentReference._jsonSchemaVersion = "firestore/documentReference/1.0", DocumentReference._jsonSchema = {
  type: property("string", DocumentReference._jsonSchemaVersion),
  referencePath: property("string")
};
class CollectionReference extends Query {
  /** @hideconstructor */
  constructor(e, t, n) {
    super(e, t, __PRIVATE_newQueryForPath(n)), this._path = n, /** The type of this Firestore reference. */
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const e = this._path.popLast();
    return e.isEmpty() ? null : new DocumentReference(
      this.firestore,
      /* converter= */
      null,
      new DocumentKey(e)
    );
  }
  withConverter(e) {
    return new CollectionReference(this.firestore, e, this._path);
  }
}
function collection(e, t, ...n) {
  if (e = getModularInstance(e), __PRIVATE_validateNonEmptyArgument("collection", "path", t), e instanceof Firestore$1) {
    const r = ResourcePath.fromString(t, ...n);
    return __PRIVATE_validateCollectionPath(r), new CollectionReference(
      e,
      /* converter= */
      null,
      r
    );
  }
  {
    if (!(e instanceof DocumentReference || e instanceof CollectionReference)) throw new FirestoreError(N.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = e._path.child(ResourcePath.fromString(t, ...n));
    return __PRIVATE_validateCollectionPath(r), new CollectionReference(
      e.firestore,
      /* converter= */
      null,
      r
    );
  }
}
function doc(e, t, ...n) {
  if (e = getModularInstance(e), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  1 === arguments.length && (t = __PRIVATE_AutoId.newId()), __PRIVATE_validateNonEmptyArgument("doc", "path", t), e instanceof Firestore$1) {
    const r = ResourcePath.fromString(t, ...n);
    return __PRIVATE_validateDocumentPath(r), new DocumentReference(
      e,
      /* converter= */
      null,
      new DocumentKey(r)
    );
  }
  {
    if (!(e instanceof DocumentReference || e instanceof CollectionReference)) throw new FirestoreError(N.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = e._path.child(ResourcePath.fromString(t, ...n));
    return __PRIVATE_validateDocumentPath(r), new DocumentReference(e.firestore, e instanceof CollectionReference ? e.converter : null, new DocumentKey(r));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const an = "AsyncQueue";
class __PRIVATE_AsyncQueueImpl {
  constructor(e = Promise.resolve()) {
    this.Zu = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
    // be changed again.
    this.Xu = false, // Operations scheduled to be queued in the future. Operations are
    // automatically removed after they are run or canceled.
    this.ec = [], // visible for testing
    this.tc = null, // Flag set while there's an outstanding AsyncQueue operation, used for
    // assertion sanity-checks.
    this.nc = false, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
    this.rc = false, // List of TimerIds to fast-forward delays for.
    this.sc = [], // Backoff timer used to schedule retries for retryable operations
    this.F_ = new __PRIVATE_ExponentialBackoff(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    ), // Visibility handler that triggers an immediate retry of all retryable
    // operations. Meant to speed up recovery when we regain file system access
    // after page comes into foreground.
    this.oc = () => {
      const e2 = getDocument();
      e2 && __PRIVATE_logDebug(an, "Visibility state changed to " + e2.visibilityState), this.F_.y_();
    }, this._c = e;
    const t = getDocument();
    t && "function" == typeof t.addEventListener && t.addEventListener("visibilitychange", this.oc);
  }
  get isShuttingDown() {
    return this.Xu;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(e) {
    this.enqueue(e);
  }
  enqueueAndForgetEvenWhileRestricted(e) {
    this.ac(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.uc(e);
  }
  enterRestrictedMode(e) {
    if (!this.Xu) {
      this.Xu = true, this.rc = e || false;
      const t = getDocument();
      t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.oc);
    }
  }
  enqueue(e) {
    if (this.ac(), this.Xu)
      return new Promise(() => {
      });
    const t = new __PRIVATE_Deferred();
    return this.uc(() => this.Xu && this.rc ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise)).then(() => t.promise);
  }
  enqueueRetryable(e) {
    this.enqueueAndForget(() => (this.Zu.push(e), this.cc()));
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async cc() {
    if (0 !== this.Zu.length) {
      try {
        await this.Zu[0](), this.Zu.shift(), this.F_.reset();
      } catch (e) {
        if (!__PRIVATE_isIndexedDbTransactionError(e)) throw e;
        __PRIVATE_logDebug(an, "Operation failed with retryable error: " + e);
      }
      this.Zu.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
      // This is necessary to run retryable operations that failed during
      // their initial attempt since we don't know whether they are already
      // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
      // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
      // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
      // call scheduled here.
      // Since `backoffAndRun()` cancels an existing backoff and schedules a
      // new backoff on every call, there is only ever a single additional
      // operation in the queue.
      this.F_.g_(() => this.cc());
    }
  }
  uc(e) {
    const t = this._c.then(() => (this.nc = true, e().catch((e2) => {
      this.tc = e2, this.nc = false;
      throw __PRIVATE_logError("INTERNAL UNHANDLED ERROR: ", __PRIVATE_getMessageOrStack(e2)), e2;
    }).then((e2) => (this.nc = false, e2))));
    return this._c = t, t;
  }
  enqueueAfterDelay(e, t, n) {
    this.ac(), // Fast-forward delays for timerIds that have been overridden.
    this.sc.indexOf(e) > -1 && (t = 0);
    const r = DelayedOperation.createAndSchedule(this, e, t, n, (e2) => this.lc(e2));
    return this.ec.push(r), r;
  }
  ac() {
    this.tc && fail(47125, {
      hc: __PRIVATE_getMessageOrStack(this.tc)
    });
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async Pc() {
    let e;
    do {
      e = this._c, await e;
    } while (e !== this._c);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  Tc(e) {
    for (const t of this.ec) if (t.timerId === e) return true;
    return false;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  Ic(e) {
    return this.Pc().then(() => {
      this.ec.sort((e2, t) => e2.targetTimeMs - t.targetTimeMs);
      for (const t of this.ec) if (t.skipDelay(), "all" !== e && t.timerId === e) break;
      return this.Pc();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  dc(e) {
    this.sc.push(e);
  }
  /** Called once a DelayedOperation is run or canceled. */
  lc(e) {
    const t = this.ec.indexOf(e);
    this.ec.splice(t, 1);
  }
}
function __PRIVATE_getMessageOrStack(e) {
  let t = e.message || "";
  return e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + "\n" + e.stack), t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_isPartialObserver(e) {
  return function __PRIVATE_implementsAnyMethods(e2, t) {
    if ("object" != typeof e2 || null === e2) return false;
    const n = e2;
    for (const e3 of t) if (e3 in n && "function" == typeof n[e3]) return true;
    return false;
  }(e, ["next", "error", "complete"]);
}
class Firestore extends Firestore$1 {
  /** @hideconstructor */
  constructor(e, t, n, r) {
    super(e, t, n, r), /**
     * Whether it's a {@link Firestore} or Firestore Lite instance.
     */
    this.type = "firestore", this._queue = new __PRIVATE_AsyncQueueImpl(), this._persistenceKey = (null == r ? void 0 : r.name) || "[DEFAULT]";
  }
  async _terminate() {
    if (this._firestoreClient) {
      const e = this._firestoreClient.terminate();
      this._queue = new __PRIVATE_AsyncQueueImpl(e), this._firestoreClient = void 0, await e;
    }
  }
}
function getFirestore(e, n) {
  const r = "object" == typeof e ? e : getApp(), i = "string" == typeof e ? e : ut, s = _getProvider(r, "firestore").getImmediate({
    identifier: i
  });
  if (!s._initialized) {
    const e2 = getDefaultEmulatorHostnameAndPort("firestore");
    e2 && connectFirestoreEmulator(s, ...e2);
  }
  return s;
}
function ensureFirestoreConfigured(e) {
  if (e._terminated) throw new FirestoreError(N.FAILED_PRECONDITION, "The client has already been terminated.");
  return e._firestoreClient || __PRIVATE_configureFirestore(e), e._firestoreClient;
}
function __PRIVATE_configureFirestore(e) {
  var t, n, r;
  const i = e._freezeSettings(), s = function __PRIVATE_makeDatabaseInfo(e2, t2, n2, r2) {
    return new DatabaseInfo(e2, t2, n2, r2.host, r2.ssl, r2.experimentalForceLongPolling, r2.experimentalAutoDetectLongPolling, __PRIVATE_cloneLongPollingOptions(r2.experimentalLongPollingOptions), r2.useFetchStreams, r2.isUsingEmulator);
  }(e._databaseId, (null === (t = e._app) || void 0 === t ? void 0 : t.options.appId) || "", e._persistenceKey, i);
  e._componentsProvider || (null === (n = i.localCache) || void 0 === n ? void 0 : n._offlineComponentProvider) && (null === (r = i.localCache) || void 0 === r ? void 0 : r._onlineComponentProvider) && (e._componentsProvider = {
    _offline: i.localCache._offlineComponentProvider,
    _online: i.localCache._onlineComponentProvider
  }), e._firestoreClient = new FirestoreClient(e._authCredentials, e._appCheckCredentials, e._queue, s, e._componentsProvider && function __PRIVATE_buildComponentProvider(e2) {
    const t2 = null == e2 ? void 0 : e2._online.build();
    return {
      _offline: null == e2 ? void 0 : e2._offline.build(t2),
      _online: t2
    };
  }(e._componentsProvider));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bytes {
  /** @hideconstructor */
  constructor(e) {
    this._byteString = e;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(e) {
    try {
      return new Bytes(ByteString.fromBase64String(e));
    } catch (e2) {
      throw new FirestoreError(N.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e2);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(e) {
    return new Bytes(ByteString.fromUint8Array(e));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(e) {
    return this._byteString.isEqual(e._byteString);
  }
  /**
   * Returns a JSON-serializable representation of this `Bytes` instance.
   *
   * @returns a JSON representation of this object.
   */
  toJSON() {
    return {
      type: Bytes._jsonSchemaVersion,
      bytes: this.toBase64()
    };
  }
  /**
   * Builds a `Bytes` instance from a JSON object created by {@link Bytes.toJSON}.
   *
   * @param json a JSON object represention of a `Bytes` instance
   * @returns an instance of {@link Bytes} if the JSON object could be parsed. Throws a
   * {@link FirestoreError} if an error occurs.
   */
  static fromJSON(e) {
    if (__PRIVATE_validateJSON(e, Bytes._jsonSchema)) return Bytes.fromBase64String(e.bytes);
  }
}
Bytes._jsonSchemaVersion = "firestore/bytes/1.0", Bytes._jsonSchema = {
  type: property("string", Bytes._jsonSchemaVersion),
  bytes: property("string")
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FieldPath {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...e) {
    for (let t = 0; t < e.length; ++t) if (0 === e[t].length) throw new FirestoreError(N.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new FieldPath$1(e);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FieldValue {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(e) {
    this._methodName = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GeoPoint {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(e, t) {
    if (!isFinite(e) || e < -90 || e > 90) throw new FirestoreError(N.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e);
    if (!isFinite(t) || t < -180 || t > 180) throw new FirestoreError(N.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + t);
    this._lat = e, this._long = t;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long;
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(e) {
    return __PRIVATE_primitiveComparator(this._lat, e._lat) || __PRIVATE_primitiveComparator(this._long, e._long);
  }
  /**
   * Returns a JSON-serializable representation of this `GeoPoint` instance.
   *
   * @returns a JSON representation of this object.
   */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long,
      type: GeoPoint._jsonSchemaVersion
    };
  }
  /**
   * Builds a `GeoPoint` instance from a JSON object created by {@link GeoPoint.toJSON}.
   *
   * @param json a JSON object represention of a `GeoPoint` instance
   * @returns an instance of {@link GeoPoint} if the JSON object could be parsed. Throws a
   * {@link FirestoreError} if an error occurs.
   */
  static fromJSON(e) {
    if (__PRIVATE_validateJSON(e, GeoPoint._jsonSchema)) return new GeoPoint(e.latitude, e.longitude);
  }
}
GeoPoint._jsonSchemaVersion = "firestore/geoPoint/1.0", GeoPoint._jsonSchema = {
  type: property("string", GeoPoint._jsonSchemaVersion),
  latitude: property("number"),
  longitude: property("number")
};
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VectorValue {
  /**
   * @private
   * @internal
   */
  constructor(e) {
    this._values = (e || []).map((e2) => e2);
  }
  /**
   * Returns a copy of the raw number array form of the vector.
   */
  toArray() {
    return this._values.map((e) => e);
  }
  /**
   * Returns `true` if the two `VectorValue` values have the same raw number arrays, returns `false` otherwise.
   */
  isEqual(e) {
    return function __PRIVATE_isPrimitiveArrayEqual(e2, t) {
      if (e2.length !== t.length) return false;
      for (let n = 0; n < e2.length; ++n) if (e2[n] !== t[n]) return false;
      return true;
    }(this._values, e._values);
  }
  /**
   * Returns a JSON-serializable representation of this `VectorValue` instance.
   *
   * @returns a JSON representation of this object.
   */
  toJSON() {
    return {
      type: VectorValue._jsonSchemaVersion,
      vectorValues: this._values
    };
  }
  /**
   * Builds a `VectorValue` instance from a JSON object created by {@link VectorValue.toJSON}.
   *
   * @param json a JSON object represention of a `VectorValue` instance.
   * @returns an instance of {@link VectorValue} if the JSON object could be parsed. Throws a
   * {@link FirestoreError} if an error occurs.
   */
  static fromJSON(e) {
    if (__PRIVATE_validateJSON(e, VectorValue._jsonSchema)) {
      if (Array.isArray(e.vectorValues) && e.vectorValues.every((e2) => "number" == typeof e2)) return new VectorValue(e.vectorValues);
      throw new FirestoreError(N.INVALID_ARGUMENT, "Expected 'vectorValues' field to be a number array");
    }
  }
}
VectorValue._jsonSchemaVersion = "firestore/vectorValue/1.0", VectorValue._jsonSchema = {
  type: property("string", VectorValue._jsonSchemaVersion),
  vectorValues: property("object")
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cn = /^__.*__$/;
class ParsedSetData {
  constructor(e, t, n) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = n;
  }
  toMutation(e, t) {
    return null !== this.fieldMask ? new __PRIVATE_PatchMutation(e, this.data, this.fieldMask, t, this.fieldTransforms) : new __PRIVATE_SetMutation(e, this.data, t, this.fieldTransforms);
  }
}
class ParsedUpdateData {
  constructor(e, t, n) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = n;
  }
  toMutation(e, t) {
    return new __PRIVATE_PatchMutation(e, this.data, this.fieldMask, t, this.fieldTransforms);
  }
}
function __PRIVATE_isWrite(e) {
  switch (e) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw fail(40011, {
        Ec: e
      });
  }
}
class __PRIVATE_ParseContextImpl {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(e, t, n, r, i, s) {
    this.settings = e, this.databaseId = t, this.serializer = n, this.ignoreUndefinedProperties = r, // Minor hack: If fieldTransforms is undefined, we assume this is an
    // external call and we need to validate the entire path.
    void 0 === i && this.Ac(), this.fieldTransforms = i || [], this.fieldMask = s || [];
  }
  get path() {
    return this.settings.path;
  }
  get Ec() {
    return this.settings.Ec;
  }
  /** Returns a new context with the specified settings overwritten. */
  Rc(e) {
    return new __PRIVATE_ParseContextImpl(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Vc(e) {
    var t;
    const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.Rc({
      path: n,
      mc: false
    });
    return r.fc(e), r;
  }
  gc(e) {
    var t;
    const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.Rc({
      path: n,
      mc: false
    });
    return r.Ac(), r;
  }
  yc(e) {
    return this.Rc({
      path: void 0,
      mc: true
    });
  }
  wc(e) {
    return __PRIVATE_createError(e, this.settings.methodName, this.settings.Sc || false, this.path, this.settings.bc);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(e) {
    return void 0 !== this.fieldMask.find((t) => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find((t) => e.isPrefixOf(t.field));
  }
  Ac() {
    if (this.path) for (let e = 0; e < this.path.length; e++) this.fc(this.path.get(e));
  }
  fc(e) {
    if (0 === e.length) throw this.wc("Document fields must not be empty");
    if (__PRIVATE_isWrite(this.Ec) && cn.test(e)) throw this.wc('Document fields cannot begin and end with "__"');
  }
}
class __PRIVATE_UserDataReader {
  constructor(e, t, n) {
    this.databaseId = e, this.ignoreUndefinedProperties = t, this.serializer = n || __PRIVATE_newSerializer(e);
  }
  /** Creates a new top-level parse context. */
  Dc(e, t, n, r = false) {
    return new __PRIVATE_ParseContextImpl({
      Ec: e,
      methodName: t,
      bc: n,
      path: FieldPath$1.emptyPath(),
      mc: false,
      Sc: r
    }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  }
}
function __PRIVATE_newUserDataReader(e) {
  const t = e._freezeSettings(), n = __PRIVATE_newSerializer(e._databaseId);
  return new __PRIVATE_UserDataReader(e._databaseId, !!t.ignoreUndefinedProperties, n);
}
function __PRIVATE_parseSetData(e, t, n, r, i, s = {}) {
  const o = e.Dc(s.merge || s.mergeFields ? 2 : 0, t, n, i);
  __PRIVATE_validatePlainObject("Data must be an object, but it was:", o, r);
  const _ = __PRIVATE_parseObject(r, o);
  let a, u;
  if (s.merge) a = new FieldMask(o.fieldMask), u = o.fieldTransforms;
  else if (s.mergeFields) {
    const e2 = [];
    for (const r2 of s.mergeFields) {
      const i2 = __PRIVATE_fieldPathFromArgument$1(t, r2, n);
      if (!o.contains(i2)) throw new FirestoreError(N.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      __PRIVATE_fieldMaskContains(e2, i2) || e2.push(i2);
    }
    a = new FieldMask(e2), u = o.fieldTransforms.filter((e3) => a.covers(e3.field));
  } else a = null, u = o.fieldTransforms;
  return new ParsedSetData(new ObjectValue(_), a, u);
}
class __PRIVATE_DeleteFieldValueImpl extends FieldValue {
  _toFieldTransform(e) {
    if (2 !== e.Ec) throw 1 === e.Ec ? e.wc(`${this._methodName}() can only appear at the top level of your update data`) : e.wc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return e.fieldMask.push(e.path), null;
  }
  isEqual(e) {
    return e instanceof __PRIVATE_DeleteFieldValueImpl;
  }
}
function __PRIVATE_parseUpdateData(e, t, n, r) {
  const i = e.Dc(1, t, n);
  __PRIVATE_validatePlainObject("Data must be an object, but it was:", i, r);
  const s = [], o = ObjectValue.empty();
  forEach(r, (e2, r2) => {
    const _2 = __PRIVATE_fieldPathFromDotSeparatedString(t, e2, n);
    r2 = getModularInstance(r2);
    const a = i.gc(_2);
    if (r2 instanceof __PRIVATE_DeleteFieldValueImpl)
      s.push(_2);
    else {
      const e3 = __PRIVATE_parseData(r2, a);
      null != e3 && (s.push(_2), o.set(_2, e3));
    }
  });
  const _ = new FieldMask(s);
  return new ParsedUpdateData(o, _, i.fieldTransforms);
}
function __PRIVATE_parseUpdateVarargs(e, t, n, r, i, s) {
  const o = e.Dc(1, t, n), _ = [__PRIVATE_fieldPathFromArgument$1(t, r, n)], a = [i];
  if (s.length % 2 != 0) throw new FirestoreError(N.INVALID_ARGUMENT, `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let e2 = 0; e2 < s.length; e2 += 2) _.push(__PRIVATE_fieldPathFromArgument$1(t, s[e2])), a.push(s[e2 + 1]);
  const u = [], c = ObjectValue.empty();
  for (let e2 = _.length - 1; e2 >= 0; --e2) if (!__PRIVATE_fieldMaskContains(u, _[e2])) {
    const t2 = _[e2];
    let n2 = a[e2];
    n2 = getModularInstance(n2);
    const r2 = o.gc(t2);
    if (n2 instanceof __PRIVATE_DeleteFieldValueImpl)
      u.push(t2);
    else {
      const e3 = __PRIVATE_parseData(n2, r2);
      null != e3 && (u.push(t2), c.set(t2, e3));
    }
  }
  const l = new FieldMask(u);
  return new ParsedUpdateData(c, l, o.fieldTransforms);
}
function __PRIVATE_parseQueryValue(e, t, n, r = false) {
  return __PRIVATE_parseData(n, e.Dc(r ? 4 : 3, t));
}
function __PRIVATE_parseData(e, t) {
  if (__PRIVATE_looksLikeJsonObject(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    e = getModularInstance(e)
  )) return __PRIVATE_validatePlainObject("Unsupported field value:", t, e), __PRIVATE_parseObject(e, t);
  if (e instanceof FieldValue)
    return function __PRIVATE_parseSentinelFieldValue(e2, t2) {
      if (!__PRIVATE_isWrite(t2.Ec)) throw t2.wc(`${e2._methodName}() can only be used with update() and set()`);
      if (!t2.path) throw t2.wc(`${e2._methodName}() is not currently supported inside arrays`);
      const n = e2._toFieldTransform(t2);
      n && t2.fieldTransforms.push(n);
    }(e, t), null;
  if (void 0 === e && t.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    t.path && t.fieldMask.push(t.path), e instanceof Array
  ) {
    if (t.settings.mc && 4 !== t.Ec) throw t.wc("Nested arrays are not supported");
    return function __PRIVATE_parseArray(e2, t2) {
      const n = [];
      let r = 0;
      for (const i of e2) {
        let e3 = __PRIVATE_parseData(i, t2.yc(r));
        null == e3 && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (e3 = {
          nullValue: "NULL_VALUE"
        }), n.push(e3), r++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(e, t);
  }
  return function __PRIVATE_parseScalarValue(e2, t2) {
    if (null === (e2 = getModularInstance(e2))) return {
      nullValue: "NULL_VALUE"
    };
    if ("number" == typeof e2) return toNumber(t2.serializer, e2);
    if ("boolean" == typeof e2) return {
      booleanValue: e2
    };
    if ("string" == typeof e2) return {
      stringValue: e2
    };
    if (e2 instanceof Date) {
      const n = Timestamp.fromDate(e2);
      return {
        timestampValue: toTimestamp(t2.serializer, n)
      };
    }
    if (e2 instanceof Timestamp) {
      const n = new Timestamp(e2.seconds, 1e3 * Math.floor(e2.nanoseconds / 1e3));
      return {
        timestampValue: toTimestamp(t2.serializer, n)
      };
    }
    if (e2 instanceof GeoPoint) return {
      geoPointValue: {
        latitude: e2.latitude,
        longitude: e2.longitude
      }
    };
    if (e2 instanceof Bytes) return {
      bytesValue: __PRIVATE_toBytes(t2.serializer, e2._byteString)
    };
    if (e2 instanceof DocumentReference) {
      const n = t2.databaseId, r = e2.firestore._databaseId;
      if (!r.isEqual(n)) throw t2.wc(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: __PRIVATE_toResourceName(e2.firestore._databaseId || t2.databaseId, e2._key.path)
      };
    }
    if (e2 instanceof VectorValue)
      return function __PRIVATE_parseVectorValue(e3, t3) {
        const n = {
          fields: {
            [ct]: {
              stringValue: Pt
            },
            [Tt]: {
              arrayValue: {
                values: e3.toArray().map((e4) => {
                  if ("number" != typeof e4) throw t3.wc("VectorValues must only contain numeric values.");
                  return __PRIVATE_toDouble(t3.serializer, e4);
                })
              }
            }
          }
        };
        return {
          mapValue: n
        };
      }(e2, t2);
    throw t2.wc(`Unsupported field value: ${__PRIVATE_valueDescription(e2)}`);
  }(e, t);
}
function __PRIVATE_parseObject(e, t) {
  const n = {};
  return isEmpty(e) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    t.path && t.path.length > 0 && t.fieldMask.push(t.path)
  ) : forEach(e, (e2, r) => {
    const i = __PRIVATE_parseData(r, t.Vc(e2));
    null != i && (n[e2] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function __PRIVATE_looksLikeJsonObject(e) {
  return !("object" != typeof e || null === e || e instanceof Array || e instanceof Date || e instanceof Timestamp || e instanceof GeoPoint || e instanceof Bytes || e instanceof DocumentReference || e instanceof FieldValue || e instanceof VectorValue);
}
function __PRIVATE_validatePlainObject(e, t, n) {
  if (!__PRIVATE_looksLikeJsonObject(n) || !__PRIVATE_isPlainObject(n)) {
    const r = __PRIVATE_valueDescription(n);
    throw "an object" === r ? t.wc(e + " a custom object") : t.wc(e + " " + r);
  }
}
function __PRIVATE_fieldPathFromArgument$1(e, t, n) {
  if (
    // If required, replace the FieldPath Compat class with the firestore-exp
    // FieldPath.
    (t = getModularInstance(t)) instanceof FieldPath
  ) return t._internalPath;
  if ("string" == typeof t) return __PRIVATE_fieldPathFromDotSeparatedString(e, t);
  throw __PRIVATE_createError(
    "Field path arguments must be of type string or ",
    e,
    /* hasConverter= */
    false,
    /* path= */
    void 0,
    n
  );
}
const ln = new RegExp("[~\\*/\\[\\]]");
function __PRIVATE_fieldPathFromDotSeparatedString(e, t, n) {
  if (t.search(ln) >= 0) throw __PRIVATE_createError(
    `Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,
    e,
    /* hasConverter= */
    false,
    /* path= */
    void 0,
    n
  );
  try {
    return new FieldPath(...t.split("."))._internalPath;
  } catch (r) {
    throw __PRIVATE_createError(
      `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      e,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n
    );
  }
}
function __PRIVATE_createError(e, t, n, r, i) {
  const s = r && !r.isEmpty(), o = void 0 !== i;
  let _ = `Function ${t}() called with invalid data`;
  n && (_ += " (via `toFirestore()`)"), _ += ". ";
  let a = "";
  return (s || o) && (a += " (found", s && (a += ` in field ${r}`), o && (a += ` in document ${i}`), a += ")"), new FirestoreError(N.INVALID_ARGUMENT, _ + e + a);
}
function __PRIVATE_fieldMaskContains(e, t) {
  return e.some((e2) => e2.isEqual(t));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentSnapshot$1 {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(e, t, n, r, i) {
    this._firestore = e, this._userDataWriter = t, this._key = n, this._document = r, this._converter = i;
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new DocumentReference(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return null !== this._document;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new QueryDocumentSnapshot$1(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(e);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e) {
    if (this._document) {
      const t = this._document.data.field(__PRIVATE_fieldPathFromArgument("DocumentSnapshot.get", e));
      if (null !== t) return this._userDataWriter.convertValue(t);
    }
  }
}
class QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
}
function __PRIVATE_fieldPathFromArgument(e, t) {
  return "string" == typeof t ? __PRIVATE_fieldPathFromDotSeparatedString(e, t) : t instanceof FieldPath ? t._internalPath : t._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_validateHasExplicitOrderByForLimitToLast(e) {
  if ("L" === e.limitType && 0 === e.explicitOrderBy.length) throw new FirestoreError(N.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
class AppliableConstraint {
}
class QueryConstraint extends AppliableConstraint {
}
function query(e, t, ...n) {
  let r = [];
  t instanceof AppliableConstraint && r.push(t), r = r.concat(n), function __PRIVATE_validateQueryConstraintArray(e2) {
    const t2 = e2.filter((e3) => e3 instanceof QueryCompositeFilterConstraint).length, n2 = e2.filter((e3) => e3 instanceof QueryFieldFilterConstraint).length;
    if (t2 > 1 || t2 > 0 && n2 > 0) throw new FirestoreError(N.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }(r);
  for (const t2 of r) e = t2._apply(e);
  return e;
}
class QueryFieldFilterConstraint extends QueryConstraint {
  /**
   * @internal
   */
  constructor(e, t, n) {
    super(), this._field = e, this._op = t, this._value = n, /** The type of this query constraint */
    this.type = "where";
  }
  static _create(e, t, n) {
    return new QueryFieldFilterConstraint(e, t, n);
  }
  _apply(e) {
    const t = this._parse(e);
    return __PRIVATE_validateNewFieldFilter(e._query, t), new Query(e.firestore, e.converter, __PRIVATE_queryWithAddedFilter(e._query, t));
  }
  _parse(e) {
    const t = __PRIVATE_newUserDataReader(e.firestore), n = function __PRIVATE_newQueryFilter(e2, t2, n2, r, i, s, o) {
      let _;
      if (i.isKeyField()) {
        if ("array-contains" === s || "array-contains-any" === s) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid Query. You can't perform '${s}' queries on documentId().`);
        if ("in" === s || "not-in" === s) {
          __PRIVATE_validateDisjunctiveFilterElements(o, s);
          const t3 = [];
          for (const n3 of o) t3.push(__PRIVATE_parseDocumentIdValue(r, e2, n3));
          _ = {
            arrayValue: {
              values: t3
            }
          };
        } else _ = __PRIVATE_parseDocumentIdValue(r, e2, o);
      } else "in" !== s && "not-in" !== s && "array-contains-any" !== s || __PRIVATE_validateDisjunctiveFilterElements(o, s), _ = __PRIVATE_parseQueryValue(
        n2,
        t2,
        o,
        /* allowArrays= */
        "in" === s || "not-in" === s
      );
      const a = FieldFilter.create(i, s, _);
      return a;
    }(e._query, "where", t, e.firestore._databaseId, this._field, this._op, this._value);
    return n;
  }
}
function where(e, t, n) {
  const r = t, i = __PRIVATE_fieldPathFromArgument("where", e);
  return QueryFieldFilterConstraint._create(i, r, n);
}
class QueryCompositeFilterConstraint extends AppliableConstraint {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), this.type = e, this._queryConstraints = t;
  }
  static _create(e, t) {
    return new QueryCompositeFilterConstraint(e, t);
  }
  _parse(e) {
    const t = this._queryConstraints.map((t2) => t2._parse(e)).filter((e2) => e2.getFilters().length > 0);
    return 1 === t.length ? t[0] : CompositeFilter.create(t, this._getOperator());
  }
  _apply(e) {
    const t = this._parse(e);
    return 0 === t.getFilters().length ? e : (function __PRIVATE_validateNewFilter(e2, t2) {
      let n = e2;
      const r = t2.getFlattenedFilters();
      for (const e3 of r) __PRIVATE_validateNewFieldFilter(n, e3), n = __PRIVATE_queryWithAddedFilter(n, e3);
    }(e._query, t), new Query(e.firestore, e.converter, __PRIVATE_queryWithAddedFilter(e._query, t)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return "and" === this.type ? "and" : "or";
  }
}
class QueryOrderByConstraint extends QueryConstraint {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), this._field = e, this._direction = t, /** The type of this query constraint */
    this.type = "orderBy";
  }
  static _create(e, t) {
    return new QueryOrderByConstraint(e, t);
  }
  _apply(e) {
    const t = function __PRIVATE_newQueryOrderBy(e2, t2, n) {
      if (null !== e2.startAt) throw new FirestoreError(N.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (null !== e2.endAt) throw new FirestoreError(N.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const r = new OrderBy(t2, n);
      return r;
    }(e._query, this._field, this._direction);
    return new Query(e.firestore, e.converter, function __PRIVATE_queryWithAddedOrderBy(e2, t2) {
      const n = e2.explicitOrderBy.concat([t2]);
      return new __PRIVATE_QueryImpl(e2.path, e2.collectionGroup, n, e2.filters.slice(), e2.limit, e2.limitType, e2.startAt, e2.endAt);
    }(e._query, t));
  }
}
function orderBy(e, t = "asc") {
  const n = t, r = __PRIVATE_fieldPathFromArgument("orderBy", e);
  return QueryOrderByConstraint._create(r, n);
}
function __PRIVATE_parseDocumentIdValue(e, t, n) {
  if ("string" == typeof (n = getModularInstance(n))) {
    if ("" === n) throw new FirestoreError(N.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!__PRIVATE_isCollectionGroupQuery(t) && -1 !== n.indexOf("/")) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const r = t.path.child(ResourcePath.fromString(n));
    if (!DocumentKey.isDocumentKey(r)) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
    return __PRIVATE_refValue(e, new DocumentKey(r));
  }
  if (n instanceof DocumentReference) return __PRIVATE_refValue(e, n._key);
  throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${__PRIVATE_valueDescription(n)}.`);
}
function __PRIVATE_validateDisjunctiveFilterElements(e, t) {
  if (!Array.isArray(e) || 0 === e.length) throw new FirestoreError(N.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`);
}
function __PRIVATE_validateNewFieldFilter(e, t) {
  const n = function __PRIVATE_findOpInsideFilters(e2, t2) {
    for (const n2 of e2) for (const e3 of n2.getFlattenedFilters()) if (t2.indexOf(e3.op) >= 0) return e3.op;
    return null;
  }(e.filters, function __PRIVATE_conflictingOps(e2) {
    switch (e2) {
      case "!=":
        return [
          "!=",
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "array-contains-any":
      case "in":
        return [
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "not-in":
        return [
          "array-contains-any",
          "in",
          "not-in",
          "!="
          /* Operator.NOT_EQUAL */
        ];
      default:
        return [];
    }
  }(t.op));
  if (null !== n)
    throw n === t.op ? new FirestoreError(N.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${t.op.toString()}' filter.`) : new FirestoreError(N.INVALID_ARGUMENT, `Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`);
}
class AbstractUserDataWriter {
  convertValue(e, t = "none") {
    switch (__PRIVATE_typeOrder(e)) {
      case 0:
        return null;
      case 1:
        return e.booleanValue;
      case 2:
        return __PRIVATE_normalizeNumber(e.integerValue || e.doubleValue);
      case 3:
        return this.convertTimestamp(e.timestampValue);
      case 4:
        return this.convertServerTimestamp(e, t);
      case 5:
        return e.stringValue;
      case 6:
        return this.convertBytes(__PRIVATE_normalizeByteString(e.bytesValue));
      case 7:
        return this.convertReference(e.referenceValue);
      case 8:
        return this.convertGeoPoint(e.geoPointValue);
      case 9:
        return this.convertArray(e.arrayValue, t);
      case 11:
        return this.convertObject(e.mapValue, t);
      case 10:
        return this.convertVectorValue(e.mapValue);
      default:
        throw fail(62114, {
          value: e
        });
    }
  }
  convertObject(e, t) {
    return this.convertObjectMap(e.fields, t);
  }
  /**
   * @internal
   */
  convertObjectMap(e, t = "none") {
    const n = {};
    return forEach(e, (e2, r) => {
      n[e2] = this.convertValue(r, t);
    }), n;
  }
  /**
   * @internal
   */
  convertVectorValue(e) {
    var t, n, r;
    const i = null === (r = null === (n = null === (t = e.fields) || void 0 === t ? void 0 : t[Tt].arrayValue) || void 0 === n ? void 0 : n.values) || void 0 === r ? void 0 : r.map((e2) => __PRIVATE_normalizeNumber(e2.doubleValue));
    return new VectorValue(i);
  }
  convertGeoPoint(e) {
    return new GeoPoint(__PRIVATE_normalizeNumber(e.latitude), __PRIVATE_normalizeNumber(e.longitude));
  }
  convertArray(e, t) {
    return (e.values || []).map((e2) => this.convertValue(e2, t));
  }
  convertServerTimestamp(e, t) {
    switch (t) {
      case "previous":
        const n = __PRIVATE_getPreviousValue(e);
        return null == n ? null : this.convertValue(n, t);
      case "estimate":
        return this.convertTimestamp(__PRIVATE_getLocalWriteTime(e));
      default:
        return null;
    }
  }
  convertTimestamp(e) {
    const t = __PRIVATE_normalizeTimestamp(e);
    return new Timestamp(t.seconds, t.nanos);
  }
  convertDocumentKey(e, t) {
    const n = ResourcePath.fromString(e);
    __PRIVATE_hardAssert(__PRIVATE_isValidResourceName(n), 9688, {
      name: e
    });
    const r = new DatabaseId(n.get(1), n.get(3)), i = new DocumentKey(n.popFirst(5));
    return r.isEqual(t) || // TODO(b/64130202): Somehow support foreign references.
    __PRIVATE_logError(`Document ${i} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`), i;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __PRIVATE_applyFirestoreDataConverter(e, t, n) {
  let r;
  return r = e ? e.toFirestore(t) : t, r;
}
class SnapshotMetadata {
  /** @hideconstructor */
  constructor(e, t) {
    this.hasPendingWrites = e, this.fromCache = t;
  }
  /**
   * Returns true if this `SnapshotMetadata` is equal to the provided one.
   *
   * @param other - The `SnapshotMetadata` to compare against.
   * @returns true if this `SnapshotMetadata` is equal to the provided one.
   */
  isEqual(e) {
    return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache;
  }
}
class DocumentSnapshot extends DocumentSnapshot$1 {
  /** @hideconstructor protected */
  constructor(e, t, n, r, i, s) {
    super(e, t, n, r, s), this._firestore = e, this._firestoreImpl = e, this.metadata = i;
  }
  /**
   * Returns whether or not the data exists. True if the document exists.
   */
  exists() {
    return super.exists();
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * By default, `serverTimestamp()` values that have not yet been
   * set to their final value will be returned as `null`. You can override
   * this by passing an options object.
   *
   * @param options - An options object to configure how data is retrieved from
   * the snapshot (for example the desired behavior for server timestamps that
   * have not yet been set to their final value).
   * @returns An `Object` containing all fields in the document or `undefined` if
   * the document doesn't exist.
   */
  data(e = {}) {
    if (this._document) {
      if (this._converter) {
        const t = new QueryDocumentSnapshot(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          this.metadata,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(t, e);
      }
      return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * By default, a `serverTimestamp()` that has not yet been set to
   * its final value will be returned as `null`. You can override this by
   * passing an options object.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @param options - An options object to configure how the field is retrieved
   * from the snapshot (for example the desired behavior for server timestamps
   * that have not yet been set to their final value).
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e, t = {}) {
    if (this._document) {
      const n = this._document.data.field(__PRIVATE_fieldPathFromArgument("DocumentSnapshot.get", e));
      if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps);
    }
  }
  /**
   * Returns a JSON-serializable representation of this `DocumentSnapshot` instance.
   *
   * @returns a JSON representation of this object.  Throws a {@link FirestoreError} if this
   * `DocumentSnapshot` has pending writes.
   */
  toJSON() {
    if (this.metadata.hasPendingWrites) throw new FirestoreError(N.FAILED_PRECONDITION, "DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");
    const e = this._document, t = {};
    if (t.type = DocumentSnapshot._jsonSchemaVersion, t.bundle = "", t.bundleSource = "DocumentSnapshot", t.bundleName = this._key.toString(), !e || !e.isValidDocument() || !e.isFoundDocument()) return t;
    this._userDataWriter.convertObjectMap(e.data.value.mapValue.fields, "previous");
    return t.bundle = (this._firestore, this.ref.path, "NOT SUPPORTED"), t;
  }
}
DocumentSnapshot._jsonSchemaVersion = "firestore/documentSnapshot/1.0", DocumentSnapshot._jsonSchema = {
  type: property("string", DocumentSnapshot._jsonSchemaVersion),
  bundleSource: property("string", "DocumentSnapshot"),
  bundleName: property("string"),
  bundle: property("string")
};
class QueryDocumentSnapshot extends DocumentSnapshot {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * By default, `serverTimestamp()` values that have not yet been
   * set to their final value will be returned as `null`. You can override
   * this by passing an options object.
   *
   * @override
   * @param options - An options object to configure how data is retrieved from
   * the snapshot (for example the desired behavior for server timestamps that
   * have not yet been set to their final value).
   * @returns An `Object` containing all fields in the document.
   */
  data(e = {}) {
    return super.data(e);
  }
}
class QuerySnapshot {
  /** @hideconstructor */
  constructor(e, t, n, r) {
    this._firestore = e, this._userDataWriter = t, this._snapshot = r, this.metadata = new SnapshotMetadata(r.hasPendingWrites, r.fromCache), this.query = n;
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    const e = [];
    return this.forEach((t) => e.push(t)), e;
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this._snapshot.docs.size;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return 0 === this.size;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(e, t) {
    this._snapshot.docs.forEach((n) => {
      e.call(t, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, n.key, n, new SnapshotMetadata(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  /**
   * Returns an array of the documents changes since the last snapshot. If this
   * is the first snapshot, all documents will be in the list as 'added'
   * changes.
   *
   * @param options - `SnapshotListenOptions` that control whether metadata-only
   * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger
   * snapshot events.
   */
  docChanges(e = {}) {
    const t = !!e.includeMetadataChanges;
    if (t && this._snapshot.excludesMetadataChanges) throw new FirestoreError(N.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t || (this._cachedChanges = /** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */
    function __PRIVATE_changesFromSnapshot(e2, t2) {
      if (e2._snapshot.oldDocs.isEmpty()) {
        let t3 = 0;
        return e2._snapshot.docChanges.map((n) => {
          const r = new QueryDocumentSnapshot(e2._firestore, e2._userDataWriter, n.doc.key, n.doc, new SnapshotMetadata(e2._snapshot.mutatedKeys.has(n.doc.key), e2._snapshot.fromCache), e2.query.converter);
          return n.doc, {
            type: "added",
            doc: r,
            oldIndex: -1,
            newIndex: t3++
          };
        });
      }
      {
        let n = e2._snapshot.oldDocs;
        return e2._snapshot.docChanges.filter((e3) => t2 || 3 !== e3.type).map((t3) => {
          const r = new QueryDocumentSnapshot(e2._firestore, e2._userDataWriter, t3.doc.key, t3.doc, new SnapshotMetadata(e2._snapshot.mutatedKeys.has(t3.doc.key), e2._snapshot.fromCache), e2.query.converter);
          let i = -1, s = -1;
          return 0 !== t3.type && (i = n.indexOf(t3.doc.key), n = n.delete(t3.doc.key)), 1 !== t3.type && (n = n.add(t3.doc), s = n.indexOf(t3.doc.key)), {
            type: __PRIVATE_resultChangeType(t3.type),
            doc: r,
            oldIndex: i,
            newIndex: s
          };
        });
      }
    }(this, t), this._cachedChangesIncludeMetadataChanges = t), this._cachedChanges;
  }
  /**
   * Returns a JSON-serializable representation of this `QuerySnapshot` instance.
   *
   * @returns a JSON representation of this object. Throws a {@link FirestoreError} if this
   * `QuerySnapshot` has pending writes.
   */
  toJSON() {
    if (this.metadata.hasPendingWrites) throw new FirestoreError(N.FAILED_PRECONDITION, "QuerySnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");
    const e = {};
    e.type = QuerySnapshot._jsonSchemaVersion, e.bundleSource = "QuerySnapshot", e.bundleName = __PRIVATE_AutoId.newId(), this._firestore._databaseId.database, this._firestore._databaseId.projectId;
    const t = [], n = [], r = [];
    return this.docs.forEach((e2) => {
      null !== e2._document && (t.push(e2._document), n.push(this._userDataWriter.convertObjectMap(e2._document.data.value.mapValue.fields, "previous")), r.push(e2.ref.path));
    }), e.bundle = (this._firestore, this.query._query, e.bundleName, "NOT SUPPORTED"), e;
  }
}
function __PRIVATE_resultChangeType(e) {
  switch (e) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return fail(61501, {
        type: e
      });
  }
}
QuerySnapshot._jsonSchemaVersion = "firestore/querySnapshot/1.0", QuerySnapshot._jsonSchema = {
  type: property("string", QuerySnapshot._jsonSchemaVersion),
  bundleSource: property("string", "QuerySnapshot"),
  bundleName: property("string"),
  bundle: property("string")
};
class __PRIVATE_ExpUserDataWriter extends AbstractUserDataWriter {
  constructor(e) {
    super(), this.firestore = e;
  }
  convertBytes(e) {
    return new Bytes(e);
  }
  convertReference(e) {
    const t = this.convertDocumentKey(e, this.firestore._databaseId);
    return new DocumentReference(
      this.firestore,
      /* converter= */
      null,
      t
    );
  }
}
function updateDoc(e, t, n, ...r) {
  e = __PRIVATE_cast(e, DocumentReference);
  const i = __PRIVATE_cast(e.firestore, Firestore), s = __PRIVATE_newUserDataReader(i);
  let o;
  o = "string" == typeof // For Compat types, we have to "extract" the underlying types before
  // performing validation.
  (t = getModularInstance(t)) || t instanceof FieldPath ? __PRIVATE_parseUpdateVarargs(s, "updateDoc", e._key, t, n, r) : __PRIVATE_parseUpdateData(s, "updateDoc", e._key, t);
  return executeWrite(i, [o.toMutation(e._key, Precondition.exists(true))]);
}
function deleteDoc(e) {
  return executeWrite(__PRIVATE_cast(e.firestore, Firestore), [new __PRIVATE_DeleteMutation(e._key, Precondition.none())]);
}
function addDoc(e, t) {
  const n = __PRIVATE_cast(e.firestore, Firestore), r = doc(e), i = __PRIVATE_applyFirestoreDataConverter(e.converter, t);
  return executeWrite(n, [__PRIVATE_parseSetData(__PRIVATE_newUserDataReader(e.firestore), "addDoc", r._key, i, null !== e.converter, {}).toMutation(r._key, Precondition.exists(false))]).then(() => r);
}
function onSnapshot(e, ...t) {
  var n, r, i;
  e = getModularInstance(e);
  let s = {
    includeMetadataChanges: false,
    source: "default"
  }, o = 0;
  "object" != typeof t[o] || __PRIVATE_isPartialObserver(t[o]) || (s = t[o++]);
  const _ = {
    includeMetadataChanges: s.includeMetadataChanges,
    source: s.source
  };
  if (__PRIVATE_isPartialObserver(t[o])) {
    const e2 = t[o];
    t[o] = null === (n = e2.next) || void 0 === n ? void 0 : n.bind(e2), t[o + 1] = null === (r = e2.error) || void 0 === r ? void 0 : r.bind(e2), t[o + 2] = null === (i = e2.complete) || void 0 === i ? void 0 : i.bind(e2);
  }
  let a, u, c;
  if (e instanceof DocumentReference) u = __PRIVATE_cast(e.firestore, Firestore), c = __PRIVATE_newQueryForPath(e._key.path), a = {
    next: (n2) => {
      t[o] && t[o](__PRIVATE_convertToDocSnapshot(u, e, n2));
    },
    error: t[o + 1],
    complete: t[o + 2]
  };
  else {
    const n2 = __PRIVATE_cast(e, Query);
    u = __PRIVATE_cast(n2.firestore, Firestore), c = n2._query;
    const r2 = new __PRIVATE_ExpUserDataWriter(u);
    a = {
      next: (e2) => {
        t[o] && t[o](new QuerySnapshot(u, r2, n2, e2));
      },
      error: t[o + 1],
      complete: t[o + 2]
    }, __PRIVATE_validateHasExplicitOrderByForLimitToLast(e._query);
  }
  return function __PRIVATE_firestoreClientListen(e2, t2, n2, r2) {
    const i2 = new __PRIVATE_AsyncObserver(r2), s2 = new __PRIVATE_QueryListener(t2, i2, n2);
    return e2.asyncQueue.enqueueAndForget(async () => __PRIVATE_eventManagerListen(await __PRIVATE_getEventManager(e2), s2)), () => {
      i2.Ou(), e2.asyncQueue.enqueueAndForget(async () => __PRIVATE_eventManagerUnlisten(await __PRIVATE_getEventManager(e2), s2));
    };
  }(ensureFirestoreConfigured(u), c, _, a);
}
function executeWrite(e, t) {
  return function __PRIVATE_firestoreClientWrite(e2, t2) {
    const n = new __PRIVATE_Deferred();
    return e2.asyncQueue.enqueueAndForget(async () => __PRIVATE_syncEngineWrite(await __PRIVATE_getSyncEngine(e2), t2, n)), n.promise;
  }(ensureFirestoreConfigured(e), t);
}
function __PRIVATE_convertToDocSnapshot(e, t, n) {
  const r = n.docs.get(t._key), i = new __PRIVATE_ExpUserDataWriter(e);
  return new DocumentSnapshot(e, i, t._key, r, new SnapshotMetadata(n.hasPendingWrites, n.fromCache), t.converter);
}
!function __PRIVATE_registerFirestore(e, t = true) {
  !function __PRIVATE_setSDKVersion(e2) {
    x = e2;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (e2, { instanceIdentifier: n, options: r }) => {
    const i = e2.getProvider("app").getImmediate(), s = new Firestore(new __PRIVATE_FirebaseAuthCredentialsProvider(e2.getProvider("auth-internal")), new __PRIVATE_FirebaseAppCheckTokenProvider(i, e2.getProvider("app-check-internal")), function __PRIVATE_databaseIdFromApp(e3, t2) {
      if (!Object.prototype.hasOwnProperty.apply(e3.options, ["projectId"])) throw new FirestoreError(N.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new DatabaseId(e3.options.projectId, t2);
    }(i, n), i);
    return r = Object.assign({
      useFetchStreams: t
    }, r), s._setSettings(r), s;
  }, "PUBLIC").setMultipleInstances(true)), registerVersion(F, M, e), // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation
  registerVersion(F, M, "esm2017");
}();
var name = "firebase";
var version = "11.10.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(name, version, "app");
const firebaseConfig = {
  apiKey: "AIzaSyBZBzj1i49dITFoNCZVNhdGzg0_Hgy7B84",
  authDomain: "diary-deji.firebaseapp.com",
  projectId: "diary-deji",
  storageBucket: "diary-deji.firebasestorage.app",
  messagingSenderId: "192929296187",
  appId: "1:192929296187:web:3af2132df4a755936b911e"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
var _tmpl$$2 = /* @__PURE__ */ template(`<button style="background:none;border:none;color:rgba(255,255,255,0.6);cursor:pointer;font-size:11px;padding:4px 0;width:100%;text-align:center;">`), _tmpl$2$1 = /* @__PURE__ */ template(`<div style=margin-bottom:12px;>`), _tmpl$3$1 = /* @__PURE__ */ template(`<button style="background:rgba(255,255,255,0.1);color:rgba(255,255,255,0.8);border:1px solid rgba(255,255,255,0.2);padding:6px 16px;border-radius:4px;cursor:pointer;font-size:12px;width:100%;">💬 Add feedback`), _tmpl$4$1 = /* @__PURE__ */ template(`<div style=margin-top:16px;>`), _tmpl$5$1 = /* @__PURE__ */ template(`<div><textarea style="width:100%;padding:6px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:white;border-radius:4px;font-size:13px;resize:vertical;min-height:50px;"></textarea><div style=margin-top:6px;><button style="background:#0088cc;color:white;border:none;padding:4px 12px;border-radius:4px;cursor:pointer;font-size:11px;margin-right:6px;">Save</button><button style="background:rgba(255,255,255,0.1);color:white;border:1px solid rgba(255,255,255,0.2);padding:4px 12px;border-radius:4px;cursor:pointer;font-size:11px;">Cancel`), _tmpl$6$1 = /* @__PURE__ */ template(`<div style="background:rgba(0,0,0,0.2);padding:10px;border-radius:6px;margin-bottom:8px;border:1px solid rgba(255,255,255,0.1);">`), _tmpl$7$1 = /* @__PURE__ */ template(`<p style="margin:0 0 6px 0;color:rgba(255,255,255,0.9);font-size:13px;">`), _tmpl$8$1 = /* @__PURE__ */ template(`<div style=display:flex;justify-content:space-between;align-items:center;><span style=color:rgba(255,255,255,0.5);font-size:11px;> • </span><div><button style=background:none;border:none;color:#0088cc;cursor:pointer;font-size:11px;margin-right:8px;>Edit</button><button style=background:none;border:none;color:#ff4444;cursor:pointer;font-size:11px;>Delete`), _tmpl$9$1 = /* @__PURE__ */ template(`<div style=background:rgba(0,0,0,0.3);padding:8px;border-radius:4px;margin-bottom:8px;><div style=display:flex;gap:6px;><button>Leonard</button><button>Deji`), _tmpl$0$1 = /* @__PURE__ */ template(`<div style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;padding:12px;"><div style=margin-bottom:8px;display:flex;align-items:center;justify-content:space-between;><span style=color:rgba(255,255,255,0.7);font-size:11px;>Posting as: <strong></strong></span><button style="background:none;border:1px solid rgba(255,255,255,0.2);color:rgba(255,255,255,0.7);padding:2px 6px;border-radius:3px;cursor:pointer;font-size:10px;">Change</button></div><form><textarea placeholder="Add your feedback here..."style="width:100%;padding:6px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:white;border-radius:4px;font-size:13px;resize:vertical;min-height:50px;"autofocus></textarea><div style=display:flex;gap:6px;margin-top:6px;><button type=submit></button><button type=button style="background:rgba(255,255,255,0.1);color:white;border:1px solid rgba(255,255,255,0.2);padding:6px 16px;border-radius:4px;cursor:pointer;font-size:12px;">Cancel`);
function FeedbackSection({
  updateId,
  updateTitle
}) {
  const [feedbacks, setFeedbacks] = createSignal([]);
  const [newFeedback, setNewFeedback] = createSignal("");
  const [editingId, setEditingId] = createSignal(null);
  const [editText, setEditText] = createSignal("");
  const [isLoading, setIsLoading] = createSignal(false);
  const [currentAuthor, setCurrentAuthor] = createSignal(localStorage.getItem("feedbackAuthor") || "Deji");
  const [showAuthorSelect, setShowAuthorSelect] = createSignal(false);
  const [showAllFeedbacks, setShowAllFeedbacks] = createSignal(false);
  const [showForm, setShowForm] = createSignal(false);
  createEffect(() => {
    const q2 = query(collection(db, "feedbacks"), where("updateId", "==", updateId), orderBy("timestamp", "desc"));
    const unsubscribe = onSnapshot(q2, (snapshot) => {
      const feedbackList = [];
      snapshot.forEach((doc2) => {
        feedbackList.push({
          id: doc2.id,
          ...doc2.data()
        });
      });
      setFeedbacks(feedbackList);
    });
    return () => unsubscribe();
  });
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!newFeedback().trim()) return;
    setIsLoading(true);
    try {
      await addDoc(collection(db, "feedbacks"), {
        updateId,
        updateTitle,
        text: newFeedback(),
        author: currentAuthor(),
        timestamp: /* @__PURE__ */ new Date(),
        edited: false
      });
      setNewFeedback("");
      setShowForm(false);
    } catch (error) {
      console.error("Error adding feedback:", error);
    }
    setIsLoading(false);
  };
  const handleEdit = async (feedbackId) => {
    if (!editText().trim()) return;
    try {
      await updateDoc(doc(db, "feedbacks", feedbackId), {
        text: editText(),
        edited: true,
        editedAt: /* @__PURE__ */ new Date()
      });
      setEditingId(null);
      setEditText("");
    } catch (error) {
      console.error("Error editing feedback:", error);
    }
  };
  const handleDelete = async (feedbackId) => {
    if (confirm("Delete this feedback?")) {
      try {
        await deleteDoc(doc(db, "feedbacks", feedbackId));
      } catch (error) {
        console.error("Error deleting feedback:", error);
      }
    }
  };
  const formatDate = (timestamp) => {
    if (!timestamp) return "";
    const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
    const now = /* @__PURE__ */ new Date();
    const diff = now - date;
    const hours = Math.floor(diff / (1e3 * 60 * 60));
    if (hours < 1) return "Just now";
    if (hours < 24) return `${hours} hour${hours > 1 ? "s" : ""} ago`;
    if (hours < 48) return "Yesterday";
    return date.toLocaleDateString();
  };
  return (() => {
    var _el$ = _tmpl$4$1();
    insert(_el$, createComponent(Show, {
      get when() {
        return feedbacks().length > 0;
      },
      get children() {
        var _el$2 = _tmpl$2$1();
        insert(_el$2, createComponent(For, {
          get each() {
            return memo(() => !!showAllFeedbacks())() ? feedbacks() : feedbacks().slice(0, 2);
          },
          children: (feedback) => (() => {
            var _el$5 = _tmpl$6$1();
            insert(_el$5, createComponent(Show, {
              get when() {
                return editingId() === feedback.id;
              },
              get fallback() {
                return [(() => {
                  var _el$1 = _tmpl$7$1();
                  insert(_el$1, () => feedback.text);
                  return _el$1;
                })(), (() => {
                  var _el$10 = _tmpl$8$1(), _el$11 = _el$10.firstChild, _el$12 = _el$11.firstChild, _el$13 = _el$11.nextSibling, _el$14 = _el$13.firstChild, _el$15 = _el$14.nextSibling;
                  insert(_el$11, () => feedback.author, _el$12);
                  insert(_el$11, () => formatDate(feedback.timestamp), null);
                  insert(_el$11, () => feedback.edited && " (edited)", null);
                  _el$14.$$click = () => {
                    setEditingId(feedback.id);
                    setEditText(feedback.text);
                  };
                  _el$15.$$click = () => handleDelete(feedback.id);
                  return _el$10;
                })()];
              },
              get children() {
                var _el$6 = _tmpl$5$1(), _el$7 = _el$6.firstChild, _el$8 = _el$7.nextSibling, _el$9 = _el$8.firstChild, _el$0 = _el$9.nextSibling;
                _el$7.$$input = (e) => setEditText(e.target.value);
                _el$9.$$click = () => handleEdit(feedback.id);
                _el$0.$$click = () => {
                  setEditingId(null);
                  setEditText("");
                };
                createRenderEffect(() => _el$7.value = editText());
                return _el$6;
              }
            }));
            return _el$5;
          })()
        }), null);
        insert(_el$2, createComponent(Show, {
          get when() {
            return feedbacks().length > 2;
          },
          get children() {
            var _el$3 = _tmpl$$2();
            _el$3.$$click = () => setShowAllFeedbacks(!showAllFeedbacks());
            insert(_el$3, (() => {
              var _c$ = memo(() => !!showAllFeedbacks());
              return () => _c$() ? `− Hide ${feedbacks().length - 2} older feedback${feedbacks().length - 2 > 1 ? "s" : ""}` : `+ Show ${feedbacks().length - 2} more feedback${feedbacks().length - 2 > 1 ? "s" : ""}`;
            })());
            return _el$3;
          }
        }), null);
        return _el$2;
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return !showForm();
      },
      get fallback() {
        return (() => {
          var _el$16 = _tmpl$0$1(), _el$17 = _el$16.firstChild, _el$18 = _el$17.firstChild, _el$19 = _el$18.firstChild, _el$20 = _el$19.nextSibling, _el$21 = _el$18.nextSibling, _el$26 = _el$17.nextSibling, _el$27 = _el$26.firstChild, _el$28 = _el$27.nextSibling, _el$29 = _el$28.firstChild, _el$30 = _el$29.nextSibling;
          insert(_el$20, currentAuthor);
          _el$21.$$click = () => setShowAuthorSelect(!showAuthorSelect());
          insert(_el$16, createComponent(Show, {
            get when() {
              return showAuthorSelect();
            },
            get children() {
              var _el$22 = _tmpl$9$1(), _el$23 = _el$22.firstChild, _el$24 = _el$23.firstChild, _el$25 = _el$24.nextSibling;
              _el$24.$$click = () => {
                setCurrentAuthor("Leonard");
                localStorage.setItem("feedbackAuthor", "Leonard");
                setShowAuthorSelect(false);
              };
              _el$25.$$click = () => {
                setCurrentAuthor("Deji");
                localStorage.setItem("feedbackAuthor", "Deji");
                setShowAuthorSelect(false);
              };
              createRenderEffect((_p$) => {
                var _v$ = `background: ${currentAuthor() === "Leonard" ? "#0088cc" : "rgba(255,255,255,0.1)"}; color: white; border: none; padding: 4px 12px; border-radius: 3px; cursor: pointer; font-size: 11px;`, _v$2 = `background: ${currentAuthor() === "Deji" ? "#0088cc" : "rgba(255,255,255,0.1)"}; color: white; border: none; padding: 4px 12px; border-radius: 3px; cursor: pointer; font-size: 11px;`;
                _p$.e = style(_el$24, _v$, _p$.e);
                _p$.t = style(_el$25, _v$2, _p$.t);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$22;
            }
          }), _el$26);
          _el$26.addEventListener("submit", handleSubmit);
          _el$27.$$input = (e) => setNewFeedback(e.target.value);
          insert(_el$29, () => isLoading() ? "Posting..." : "Post");
          _el$30.$$click = () => {
            setShowForm(false);
            setNewFeedback("");
          };
          createRenderEffect((_p$) => {
            var _v$3 = isLoading(), _v$4 = isLoading() || !newFeedback().trim(), _v$5 = `background: ${isLoading() || !newFeedback().trim() ? "rgba(0,136,204,0.5)" : "#0088cc"}; color: white; border: none; padding: 6px 16px; border-radius: 4px; cursor: ${isLoading() || !newFeedback().trim() ? "not-allowed" : "pointer"}; font-size: 12px;`;
            _v$3 !== _p$.e && (_el$27.disabled = _p$.e = _v$3);
            _v$4 !== _p$.t && (_el$29.disabled = _p$.t = _v$4);
            _p$.a = style(_el$29, _v$5, _p$.a);
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          });
          createRenderEffect(() => _el$27.value = newFeedback());
          return _el$16;
        })();
      },
      get children() {
        var _el$4 = _tmpl$3$1();
        _el$4.$$click = () => setShowForm(true);
        return _el$4;
      }
    }), null);
    return _el$;
  })();
}
delegateEvents(["click", "input"]);
var _tmpl$$1 = /* @__PURE__ */ template(`<div><div> FPS</div><div> </div><div><div>AVG: <!> FPS</div><div>MIN: <!> FPS</div><div>MAX: <!> FPS</div></div><div>Target: 60 FPS (Desktop) | 40 FPS (Mobile)`);
function FPSMonitor() {
  const [fps, setFps] = createSignal(0);
  const [avgFps, setAvgFps] = createSignal(0);
  const [minFps, setMinFps] = createSignal(999);
  const [maxFps, setMaxFps] = createSignal(0);
  const [interactionType, setInteractionType] = createSignal("idle");
  const [isVisible, setIsVisible] = createSignal(false);
  onMount(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const fpsParam = urlParams.get("fps");
    const fpsStorage = localStorage.getItem("showFPS");
    if (fpsParam === "1" || fpsStorage === "true") {
      setIsVisible(true);
    }
    if (!isVisible()) return;
    let frameCount = 0;
    let lastTime = performance.now();
    let fpsHistory = [];
    const MAX_HISTORY = 60;
    const measureFPS = (timestamp) => {
      frameCount++;
      const delta = timestamp - lastTime;
      if (delta >= 1e3) {
        const currentFPS = Math.round(frameCount * 1e3 / delta);
        setFps(currentFPS);
        fpsHistory.push(currentFPS);
        if (fpsHistory.length > MAX_HISTORY) {
          fpsHistory.shift();
        }
        const avg = Math.round(fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length);
        const min = Math.min(...fpsHistory);
        const max = Math.max(...fpsHistory);
        setAvgFps(avg);
        setMinFps(min);
        setMaxFps(max);
        frameCount = 0;
        lastTime = timestamp;
      }
      requestAnimationFrame(measureFPS);
    };
    const rafId = requestAnimationFrame(measureFPS);
    let isAnimating = false;
    let isPanning = false;
    const viewer = window.viewer;
    if (viewer) {
      viewer.addHandler("animation-start", () => {
        isAnimating = true;
        setInteractionType("zooming");
      });
      viewer.addHandler("animation-finish", () => {
        isAnimating = false;
        if (!isPanning) {
          setInteractionType("idle");
        }
      });
      viewer.addHandler("pan", () => {
        isPanning = true;
        setInteractionType("panning");
      });
      let panTimeout;
      viewer.addHandler("pan", () => {
        clearTimeout(panTimeout);
        panTimeout = setTimeout(() => {
          isPanning = false;
          if (!isAnimating) {
            setInteractionType("idle");
          }
        }, 500);
      });
    }
    const handleHotspotReveal = () => {
      setInteractionType("hotspot-reveal");
      setTimeout(() => {
        if (!isAnimating && !isPanning) {
          setInteractionType("idle");
        }
      }, 2e3);
    };
    document.addEventListener("hotspot-reveal", handleHotspotReveal);
    onCleanup(() => {
      cancelAnimationFrame(rafId);
      document.removeEventListener("hotspot-reveal", handleHotspotReveal);
    });
  });
  if (!isVisible()) return null;
  const getFpsColor = () => {
    const currentFps = fps();
    if (currentFps >= 55) return "#00ff00";
    if (currentFps >= 40) return "#ffff00";
    if (currentFps >= 25) return "#ff9900";
    return "#ff0000";
  };
  const getInteractionIcon = () => {
    switch (interactionType()) {
      case "zooming":
        return "🔍";
      case "panning":
        return "👆";
      case "hotspot-reveal":
        return "✨";
      default:
        return "💤";
    }
  };
  return (() => {
    var _el$ = _tmpl$$1(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$2.nextSibling, _el$5 = _el$4.firstChild, _el$6 = _el$4.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.firstChild, _el$0 = _el$8.nextSibling;
    _el$0.nextSibling;
    var _el$1 = _el$7.nextSibling, _el$10 = _el$1.firstChild, _el$12 = _el$10.nextSibling;
    _el$12.nextSibling;
    var _el$13 = _el$1.nextSibling, _el$14 = _el$13.firstChild, _el$16 = _el$14.nextSibling;
    _el$16.nextSibling;
    var _el$17 = _el$6.nextSibling;
    _el$.style.setProperty("position", "fixed");
    _el$.style.setProperty("top", "10px");
    _el$.style.setProperty("right", "10px");
    _el$.style.setProperty("background-color", "rgba(0, 0, 0, 0.8)");
    _el$.style.setProperty("padding", "12px 16px");
    _el$.style.setProperty("border-radius", "8px");
    _el$.style.setProperty("font-family", "monospace");
    _el$.style.setProperty("font-size", "14px");
    _el$.style.setProperty("z-index", "999999");
    _el$.style.setProperty("pointer-events", "none");
    _el$.style.setProperty("user-select", "none");
    _el$.style.setProperty("box-shadow", "0 4px 12px rgba(0,0,0,0.5)");
    _el$.style.setProperty("min-width", "180px");
    _el$2.style.setProperty("font-size", "32px");
    _el$2.style.setProperty("font-weight", "bold");
    _el$2.style.setProperty("text-align", "center");
    _el$2.style.setProperty("margin-bottom", "8px");
    _el$2.style.setProperty("text-shadow", "0 0 10px currentColor");
    insert(_el$2, fps, _el$3);
    _el$4.style.setProperty("text-align", "center");
    _el$4.style.setProperty("font-size", "12px");
    _el$4.style.setProperty("color", "#cccccc");
    _el$4.style.setProperty("margin-bottom", "8px");
    insert(_el$4, getInteractionIcon, _el$5);
    insert(_el$4, () => interactionType().toUpperCase(), null);
    _el$6.style.setProperty("font-size", "11px");
    _el$6.style.setProperty("color", "#999999");
    _el$6.style.setProperty("border-top", "1px solid #444");
    _el$6.style.setProperty("padding-top", "8px");
    insert(_el$7, avgFps, _el$0);
    insert(_el$1, minFps, _el$12);
    insert(_el$13, maxFps, _el$16);
    _el$17.style.setProperty("margin-top", "8px");
    _el$17.style.setProperty("padding-top", "8px");
    _el$17.style.setProperty("border-top", "1px solid #444");
    _el$17.style.setProperty("font-size", "10px");
    _el$17.style.setProperty("color", "#666");
    _el$17.style.setProperty("text-align", "center");
    createRenderEffect((_p$) => {
      var _v$ = getFpsColor(), _v$2 = `2px solid ${getFpsColor()}`;
      _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$.style.setProperty("color", _v$) : _el$.style.removeProperty("color"));
      _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$.style.setProperty("border", _v$2) : _el$.style.removeProperty("border"));
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })();
}
const tableauHaptic = "/assets/tableau-haptic-B_9CTT5E.png";
function initializePassiveEventOptimization() {
  let supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassive = true;
        return true;
      }
    });
    window.addEventListener("test", null, opts);
    window.removeEventListener("test", null, opts);
  } catch (e) {
  }
  if (supportsPassive) {
    console.log("[PassiveEventOptimizer] Passive event listeners supported");
    const originalAddEventListener = EventTarget.prototype.addEventListener;
    EventTarget.prototype.addEventListener = function(type, listener, options) {
      if (typeof options === "boolean") {
        options = { capture: options };
      } else if (!options) {
        options = {};
      }
      if (options.passive === void 0) {
        if (["touchstart", "touchmove", "wheel", "mousewheel"].includes(type)) {
          options.passive = true;
        }
      }
      return originalAddEventListener.call(this, type, listener, options);
    };
    console.log("[PassiveEventOptimizer] Touch and wheel events will default to passive");
  } else {
    console.log("[PassiveEventOptimizer] Passive event listeners not supported");
  }
  return supportsPassive;
}
var _tmpl$ = /* @__PURE__ */ template(`<p>Fixed some <span>subtle but important interaction issues</span> across all devices. On desktop, hotspot borders were sometimes getting stuck after hovering or clicking - they now disappear cleanly as intended.`), _tmpl$2 = /* @__PURE__ */ template(`<p>For mobile users, the <span>two-tap reveal system</span> is working correctly now. The first tap reveals the hidden hotspot boundary, the second tap zooms in - exactly as designed. This was accidentally sometimes bypassing straight to zoom on both Android and iOS.`), _tmpl$3 = /* @__PURE__ */ template(`<p><em>These are quality-of-life fixes that make the experience feel more polished and predictable.`), _tmpl$4 = /* @__PURE__ */ template(`<p>Zooming and panning should be <span>significantly smoother</span> on mobile. Fixed how the gallery processes hotspots - it was redrawing hundreds of them individually during each zoom, now they're batched together in a single pass`), _tmpl$5 = /* @__PURE__ */ template(`<p><em>The changes should be noticeable during navigation and zooming.`), _tmpl$6 = /* @__PURE__ */ template(`<p>The artwork now responds <span>noticeably faster to your touch</span> on mobile, with smoother zooming that better preserves the flow of the piece details. I improved how the gallery handles the interactive hotspots - it now processes them quicker while using less battery.`), _tmpl$7 = /* @__PURE__ */ template(`<p>The occasional <span>black tiles</span> are still showing up sometimes on iPad, though it should be much less frequent now. I've been chasing this one for a while - it's related to how Safari manages memory during fast panning.`), _tmpl$8 = /* @__PURE__ */ template(`<p><em>Things should feel <span>more responsive</span> on your iPhone and iPad now. Step by step, it should be improving overall quite well.`), _tmpl$9 = /* @__PURE__ */ template(`<p>The <span>black tile flashing</span> issue should be much better now. Found that OpenSeadragon's fade animations were clashing with mobile browsers - disabling them seems to help the overall smoothness quite a bit.`), _tmpl$0 = /* @__PURE__ */ template(`<p>For iPhone and iPad users, I removed some transparency processing that wasn't needed for the monochrome art. This should give you <span>noticeably better performance</span>.`), _tmpl$1 = /* @__PURE__ */ template(`<p><em>You should progressively feel the difference as these optimizations accumulate. `), _tmpl$10 = /* @__PURE__ */ template(`<p>The artwork loads <span>40-60% faster</span> on Android (improvements should be felt on iPhone/iPad too). Simplified code - switched from doing multiple drawing steps to just one clean pass. The details of the artwork should stay crisp.`), _tmpl$11 = /* @__PURE__ */ template(`<p>Touch feels more responsive than before on my Android test device. Can't verify <span>iOS improvements</span> yet since I don't have an iPhone, but the changes should help there too. Black tiles still flash occasionally when panning quickly - that's next on my list.`), _tmpl$12 = /* @__PURE__ */ template(`<p><em>The mobile experience keeps <span>improving bit by bit</span>. Not where I want it to be, but getting closer.`), _tmpl$13 = /* @__PURE__ */ template(`<p>The artwork now responds <span>instantly to touch</span> on Android devices, with smoother panning that better matches the flow of Deji's intricate linework. Deleted 2,000+ lines of code that were trying too hard - sometimes less really is more!`), _tmpl$14 = /* @__PURE__ */ template(`<p>This simplification means <span>less memory usage</span> and more predictable behavior across all browsers. Without iOS devices to test on, I'm curious to hear if iPhone users feel the difference too.`), _tmpl$15 = /* @__PURE__ */ template(`<p><em>Each day brings incremental gains as we approach that <span>fluid gallery experience</span> where the technology disappears and only the art remains. Getting closer!`), _tmpl$16 = /* @__PURE__ */ template(`<p><strong>The fix:</strong> Resolved the issue where the entire artwork would disappear on iOS devices after panning or zooming.`), _tmpl$17 = /* @__PURE__ */ template(`<p><strong>What was happening:</strong> iOS canvas memory limitations were causing the entire display to fail and show a blank screen after interactions.`), _tmpl$18 = /* @__PURE__ */ template(`<p><strong>Still working on:</strong> Some tiles may appear black temporarily during fast panning or zooming. This is the next issue to address on iOS devices.`), _tmpl$19 = /* @__PURE__ */ template(`<p>Made some under-the-hood optimizations that should improve performance on mobile devices. The app should feel a bit smoother when zooming and panning.`), _tmpl$20 = /* @__PURE__ */ template(`<h4>What's improved`), _tmpl$21 = /* @__PURE__ */ template(`<p>Rewrote parts of the rendering system to be more efficient. You should notice slightly better frame rates and more responsive touch interactions on iPhone and iPad. These are incremental improvements while I work on bigger optimizations.`), _tmpl$22 = /* @__PURE__ */ template(`<p><em>This is ongoing work - more performance improvements are coming as I continue refining the mobile experience.`), _tmpl$23 = /* @__PURE__ */ template(`<p><strong>Good news:</strong> Haptic feedback now works on a wider range of devices when you tap to reveal hotspots. The vibration provides tactile confirmation that your interaction was registered.`), _tmpl$24 = /* @__PURE__ */ template(`<h4>Device Support Status`), _tmpl$25 = /* @__PURE__ */ template(`<div><img alt="Haptic Support Table">`), _tmpl$26 = /* @__PURE__ */ template(`<p><strong>Technical limitation:</strong> Apple deliberately blocks web-based vibration access on older iOS versions and all iPads for security reasons. Only iOS 17.4+ allows limited haptic feedback through a workaround. Android has always supported the standard Vibration API.`), _tmpl$27 = /* @__PURE__ */ template(`<p><strong>Note on iOS vibrations:</strong> The ios-haptics library uses the checkbox switch trick which produces a fixed, non-configurable feedback. I cannot test this myself on iOS 17.4+ devices, so the actual feel may differ from Android.`), _tmpl$28 = /* @__PURE__ */ template(`<p><em>The app automatically detects device capabilities and enables vibration where possible. No configuration needed. Also removed tap sounds on mobile to reduce sensory overload.`), _tmpl$29 = /* @__PURE__ */ template(`<h4>Next priority`), _tmpl$30 = /* @__PURE__ */ template(`<p>Rather than spending more time on iOS vibration alternatives (like pseudo-haptic effects for older devices), I'm shifting focus to <strong>mobile performance improvements</strong>. Getting the app running smoothly on all devices takes precedence over vibration fallbacks.`), _tmpl$31 = /* @__PURE__ */ template(`<p>Fixed a bug that was breaking the tap-to-reveal feature on mobile after a few uses. The app was essentially forgetting to clean up after itself, causing it to stop working entirely.`), _tmpl$32 = /* @__PURE__ */ template(`<h4>What was happening`), _tmpl$33 = /* @__PURE__ */ template(`<p><strong>The problem:</strong> After tapping 3-4 times to reveal hotspots, nothing would appear anymore. You had to reload the page to get it working again.<br><strong>Why it happened:</strong> The app was creating invisible timers that never got cleared, like setting multiple alarms but forgetting which ones you set. These orphaned timers would interfere with new reveals.`), _tmpl$34 = /* @__PURE__ */ template(`<h4>The fix`), _tmpl$35 = /* @__PURE__ */ template(`<p>Now the app properly tracks and cleans up all timers. You can tap and reveal hotspots indefinitely without any degradation. Mobile exploration is finally stable for extended sessions.`), _tmpl$36 = /* @__PURE__ */ template(`<p>Added an experimental "Ripple" exploration mode for mobile that reveals hotspots in an expanding pattern from where you tap. Just a weekend side project I wanted to try out.`), _tmpl$37 = /* @__PURE__ */ template(`<h4>What's new`), _tmpl$38 = /* @__PURE__ */ template(`<p>Tap anywhere and hotspots appear in a ripple effect around your touch point - like sonar discovering what's hidden nearby. You can switch between "Focus" (one hotspot) and "Ripple" exploration modes using the debug button (bottom left corner).`), _tmpl$39 = /* @__PURE__ */ template(`<h4>Known issues`), _tmpl$40 = /* @__PURE__ */ template(`<p>This is very experimental. Currently reveals way too many hotspots (sometimes 30+) and the visual effect is chaotic rather than elegant. The animations need refinement.`), _tmpl$41 = /* @__PURE__ */ template(`<h4>Why test this`), _tmpl$42 = /* @__PURE__ */ template(`<p>Testing if can we show 3-5 hotspots per tap in an elegant way without overwhelming users. Experimenting with finding the balance between helpful context and visual clarity for those tiny hotspots that single-tap might miss.`), _tmpl$43 = /* @__PURE__ */ template(`<h4>Four critical improvements today`), _tmpl$44 = /* @__PURE__ */ template(`<p><strong>1. Mobile fade finally works:</strong> Fixed the spotlight darkening that was stuck on mobile devices. The black overlay around hotspots now fades progressively when you pinch to zoom out on iPad, iPhone, and Android. I discovered that mobile browsers handle touch gestures differently than desktop, so I rewrote the entire fade system to work with how mobile devices actually track your finger movements.`), _tmpl$45 = /* @__PURE__ */ template(`<p><strong>2. Instant fade response:</strong> The fade now begins immediately when you start zooming out. Previously, you had to pinch excessively before seeing any change - this delay is now completely eliminated.`), _tmpl$46 = /* @__PURE__ */ template(`<p><strong>3. Clean transitions:</strong> Fixed the lingering white borders that would sometimes remain visible after the spotlight effect ended. All visual elements now synchronize properly for seamless transitions.`), _tmpl$47 = /* @__PURE__ */ template(`<p><strong>4. iPad clarity restored:</strong> Resolved the severe pixelation that was occurring during zoom and pan on iPad. The artwork now maintains crisp quality during all interactions while preserving smooth 30+ FPS performance.`), _tmpl$48 = /* @__PURE__ */ template(`<p><em>These fixes resolve all known mobile spotlight issues. The experience is now consistent and polished across every device.`), _tmpl$49 = /* @__PURE__ */ template(`<h4>1. Fixed a stability issue`), _tmpl$50 = /* @__PURE__ */ template(`<p>Discovered and fixed a bug where hotspot animations could stop working after multiple page refreshes. The issue was that old animation code was accumulating in the browser's memory. The app now properly cleans itself up between page loads, preventing any animation glitches.`), _tmpl$51 = /* @__PURE__ */ template(`<h4>2. Google Sheets pipeline is ready`), _tmpl$52 = /* @__PURE__ */ template(`<p>I've completed the pipeline to sync your Excel data. All 5 sheets (hotspots, journeys, gallery, overrides, settings) are mapped correctly with the 93 fields you defined. The app currently uses about 15% of these fields, but the pipeline preserves all of them for future features. Once you send me the Google Sheets credentials, you'll be able to update content directly in your spreadsheet, and I'll handle syncing the changes to the app when needed.`), _tmpl$53 = /* @__PURE__ */ template(`<p><em>The app is running smoothly and ready for the next phase with Google Sheets integration.`), _tmpl$54 = /* @__PURE__ */ template(`<p>Added a new "single" reveal mode for mobile that shows only the closest hotspot when tapping, addressing feedback about multiple hotspots being confusing.`), _tmpl$55 = /* @__PURE__ */ template(`<p><strong>Single mode (default on mobile)</strong><br>When you tap the screen, only the single closest hotspot is revealed instead of multiple hotspots in a radius. This makes the experience less overwhelming and more focused.`), _tmpl$56 = /* @__PURE__ */ template(`<p><strong>Multiple mode (optional)</strong><br>The original behavior of revealing multiple hotspots is still available for users who prefer seeing more context at once.`), _tmpl$57 = /* @__PURE__ */ template(`<p><strong>Debug panel toggle</strong><br>Added a new "Reveal" section to the mobile debug panel where users can switch between different reveal modes. The preference is saved and persists between sessions.`), _tmpl$58 = /* @__PURE__ */ template(`<p><em>Note: The visual styling hasn't been refined yet - this is a functional implementation to test the concept. The animations and visual feedback will be polished based on user feedback.`), _tmpl$59 = /* @__PURE__ */ template(`<p><strong>iPhone black line:</strong> Fixed! The horizontal black line at the bottom is gone. Issue was with canvas sizing calculations on iOS.`), _tmpl$60 = /* @__PURE__ */ template(`<p><strong>iPad performance:</strong> Improved significantly. Now auto-detects iPad model and adjusts performance settings accordingly. Resolution catches up faster when zooming.`), _tmpl$61 = /* @__PURE__ */ template(`<p><strong>Known issue:</strong> Tiles sometimes flicker on iPad (reload too often). Working on this next.`), _tmpl$62 = /* @__PURE__ */ template(`<p>Focused on making the viewer faster and more responsive, especially on phones. You should notice smoother panning and zooming now.`), _tmpl$63 = /* @__PURE__ */ template(`<h4>What's better`), _tmpl$64 = /* @__PURE__ */ template(`<p><strong>Mobile performance:</strong> Significantly improved how the viewer handles touch navigation.<br><strong>Smooth transitions:</strong> Added subtle fade effects that make exploring feel more fluid.<br><strong>Safari fixes:</strong> Resolved the visual issues that were happening on Apple devices.`), _tmpl$65 = /* @__PURE__ */ template(`<p><em>A week of under-the-hood improvements. Nothing flashy, but everything should feel more solid.`), _tmpl$66 = /* @__PURE__ */ template(`<p>Made significant progress on mobile performance, particularly for panning and zooming. The viewer now feels noticeably more responsive when navigating the artwork on phones and tablets.`), _tmpl$67 = /* @__PURE__ */ template(`<p><strong>Smoother panning:</strong> Dragging to explore the artwork now maintains better frame rates and feels more fluid.<br><strong>Responsive zoom:</strong> Pinch-to-zoom and double-tap zoom are more responsive with less lag.<br><strong>Smarter tile loading:</strong> The viewer now loads the right image tiles at the right time, reducing stuttering during navigation.<br><strong>Network adaptation:</strong> On slower connections, the viewer automatically adjusts quality to maintain smooth performance.`), _tmpl$68 = /* @__PURE__ */ template(`<h4>Technical improvements`), _tmpl$69 = /* @__PURE__ */ template(`<p>We've implemented several optimizations including spatial indexing for faster hotspot detection, intelligent caching for better memory usage, and GPU-accelerated rendering for smoother animations. These changes lay the groundwork for future improvements.`), _tmpl$70 = /* @__PURE__ */ template(`<h4>Work in progress`), _tmpl$71 = /* @__PURE__ */ template(`<p>While navigation is much improved, there's still work to be done. The cinematic zoom animations need refinement, and overall performance can be pushed further. We're continuing to optimize for that perfect, buttery-smooth experience across all devices.`), _tmpl$72 = /* @__PURE__ */ template(`<p><em>Performance optimization is an ongoing journey. Each improvement gets us closer to the ideal experience, and your feedback helps identify what to prioritize next.`), _tmpl$73 = /* @__PURE__ */ template(`<p>Added a ripple effect when tapping on mobile devices. Now when you tap anywhere on the screen, you'll see a subtle expanding circle that helps confirm your touch was registered.`), _tmpl$74 = /* @__PURE__ */ template(`<p><strong>Visual feedback:</strong> A gentle white ripple emanates from your tap location, making the interface feel more responsive.<br><strong>Hotspot revealing:</strong> The ripple helps you discover hidden hotspots - up to 10 nearby hotspots briefly appear with a staggered animation.<br><strong>Touch confirmation:</strong> Especially helpful on dense areas of the artwork where you might wonder if your tap registered.`), _tmpl$75 = /* @__PURE__ */ template(`<h4>Technical details`), _tmpl$76 = /* @__PURE__ */ template(`<p>The ripple expands to 200 pixels and reveals hotspots within that radius. Each hotspot appears with a 30ms delay, creating a smooth cascade effect. The entire sequence lasts 2 seconds before fading away.`), _tmpl$77 = /* @__PURE__ */ template(`<p><em>This makes exploring the artwork on phones and tablets feel more intuitive and satisfying.`), _tmpl$78 = /* @__PURE__ */ template(`<p>Enhanced the hotspot stroke animation with authentic pigment liner characteristics inspired by your original artwork. The hover effects now better match the organic, hand-drawn quality of your pen work.`), _tmpl$79 = /* @__PURE__ */ template(`<p><strong>Authentic pigment colors:</strong> Three color variants (neutral, warm, cool) that mirror real BlackPigment liner pens used in traditional ink work.<br><strong>Organic texture effects:</strong> Subtle micro-blur and grain that recreate the natural imperfections of physical ink on paper.<br><strong>Enhanced visibility:</strong> Improved contrast and brightness while maintaining the authentic look of hand-drawn lines.`), _tmpl$80 = /* @__PURE__ */ template(`<p><strong>Adaptive animation system:</strong> Three-speed animation levels that respond to zoom depth that brings the strokes to life.`), _tmpl$81 = /* @__PURE__ */ template(`<p>The stroke animation now starts from a different point each time you hover over a hotspot. Small detail, but it adds to the organic feel we've been building.`), _tmpl$82 = /* @__PURE__ */ template(`<h4>What changed`), _tmpl$83 = /* @__PURE__ */ template(`<p><strong>Random starting points:</strong> Each hover animation begins from a different position on the shape's outline.<br><strong>Safari compatibility:</strong> Fixed the implementation to work properly on Safari and iOS devices.`), _tmpl$84 = /* @__PURE__ */ template(`<p>Together with yesterday's timing variations, each hotspot interaction now feels more natural and less repetitive.`), _tmpl$85 = /* @__PURE__ */ template(`<p>Added subtle variations to animations to make them feel more organic and hand-drawn. Each hotspot now reveals with its own unique character, preventing the repetitive feel of identical animations.`), _tmpl$86 = /* @__PURE__ */ template(`<p><strong>Timing variations:</strong> Each animation has a slightly different speed (±10% variation), making the reveals feel more natural.<br><strong>Curve adjustments:</strong> The animation curves are subtly varied for each hotspot, creating unique motion personalities.<br><strong>Organic feel:</strong> As you explore and hover over different hotspots, each one feels hand-drawn and unique rather than computer-generated.`), _tmpl$87 = /* @__PURE__ */ template(`<h4>Why it matters`), _tmpl$88 = /* @__PURE__ */ template(`<p>When you hover over different hotspots throughout your exploration, each one now feels unique rather than repetitive. Every animation has its own rhythm and flow, creating a more artistic and engaging experience. It's a small detail that makes a big difference in how alive the artwork feels.`), _tmpl$89 = /* @__PURE__ */ template(`<p>These micro-variations are subtle enough to feel natural but significant enough to eliminate the "robot" feeling from animations.`), _tmpl$90 = /* @__PURE__ */ template(`<p>Refined the button controls and zoom behavior based on user feedback. The viewing experience is now more intuitive and responsive across all devices.`), _tmpl$91 = /* @__PURE__ */ template(`<h4>Button improvements`), _tmpl$92 = /* @__PURE__ */ template(`<p><strong>Better positioning:</strong> Buttons are now optimally placed on both landscape and portrait orientations.<br><strong>Visual refinements:</strong> Updated button styles for better visibility and a more modern look.<br><strong>Touch targets:</strong> Improved button sizes and spacing for easier interaction on mobile devices.`), _tmpl$93 = /* @__PURE__ */ template(`<h4>Zoom enhancements`), _tmpl$94 = /* @__PURE__ */ template(`<p><strong>Cinematic zoom:</strong> Smoother, more natural zoom animations when clicking on hotspots.<br><strong>Mouse wheel support:</strong> You can now zoom in and out using your mouse wheel or trackpad for precise control.<br><strong>Improved performance:</strong> Zoom operations are now more fluid, especially on mobile devices.`), _tmpl$95 = /* @__PURE__ */ template(`<p>These improvements make navigation feel more natural and give you better control over your viewing experience. The combination of refined buttons and enhanced zoom creates a more professional and polished interface.`), _tmpl$96 = /* @__PURE__ */ template(`<p>Completed a significant restructuring of the hotspot rendering system. The code is now much more organized and maintainable, which means faster improvements and easier bug fixes going forward.`), _tmpl$97 = /* @__PURE__ */ template(`<h4>What changed under the hood`), _tmpl$98 = /* @__PURE__ */ template(`<p>Split the renderer file into smaller, focused modules. Each piece now handles one specific job - animations, Safari compatibility, performance optimization, etc. It's like organizing a cluttered workshop where every tool now has its proper place.`), _tmpl$99 = /* @__PURE__ */ template(`<h4>What this means for you`), _tmpl$100 = /* @__PURE__ */ template(`<p><strong>More reliable performance:</strong> The rendering system is now more efficient and predictable.<br><strong>Easier updates:</strong> Adding new features or fixing issues is now much simpler.<br><strong>Better stability:</strong> Less chance of one change breaking something else.`), _tmpl$101 = /* @__PURE__ */ template(`<p>Everything should work exactly as before - this was purely about making the code cleaner and more professional. If you notice any differences in behavior, please let me know!`), _tmpl$102 = /* @__PURE__ */ template(`<p>Fixed the annoying flickering issue that occurred at the end of cinematic zoom animations. The zoom transitions are now smooth and stable across all platforms.`), _tmpl$103 = /* @__PURE__ */ template(`<p>When zooming to a hotspot or expanding to full view, the animation would flicker between two zoom levels during the final moments. This was caused by conflicting optimization systems fighting for control.`), _tmpl$104 = /* @__PURE__ */ template(`<h4>The complete solution`), _tmpl$105 = /* @__PURE__ */ template(`<p>The flickering issue is now mostly resolved, but a complete fix still requires switching renderers once. This is a known initialization issue that we're investigating.`), _tmpl$106 = /* @__PURE__ */ template(`<p><strong>Temporary workaround:</strong> If you still see flickering, press 'C' to open debug menu, click "Soft Glow" then "Sharp Outline" to fully eliminate the issue.`), _tmpl$107 = /* @__PURE__ */ template(`<p><strong>Alternative:</strong> Type <code>fixFlickering()</code> in the browser console.`), _tmpl$108 = /* @__PURE__ */ template(`<ol><li><strong>Applied TileCascadeFix at startup</strong> - Prevents tile cascade issues</li><li><strong>Implemented CinematicZoomManager</strong> - Coordinates all zoom animations with proper damping</li><li><strong>Added forceRedraw() calls</strong> - Ensures the viewer refreshes properly after animations</li><li><strong>State reset after initialization</strong> - Attempts to clean up any initialization issues`), _tmpl$109 = /* @__PURE__ */ template(`<p><strong>Desktop:</strong> 1.0s animation with 6.5 spring stiffness<br><strong>Mobile:</strong> 1.2s animation with 8.0 spring stiffness<br><strong>Cinematic mode:</strong> Temporarily disables tile optimizations during zoom`), _tmpl$110 = /* @__PURE__ */ template(`<p><em>The difference is immediately noticeable - zoom animations now feel professional and polished, matching the quality of the rest of the viewer.`), _tmpl$111 = /* @__PURE__ */ template(`<p>Removed the complex "Zoom Performance" section from the debug menu to simplify the interface.`), _tmpl$112 = /* @__PURE__ */ template(`<p>The debug menu now focuses on essential controls for visual customization, interaction behavior, and hotspot discovery. Advanced zoom tuning parameters have been removed as they were rarely used and added unnecessary complexity.`), _tmpl$113 = /* @__PURE__ */ template(`<p><em>The artwork already performs at 60 FPS with the default settings, making manual tuning unnecessary for most users.`), _tmpl$114 = /* @__PURE__ */ template(`<p>Fixed the issue where Playwright manual tests weren't opening a visible browser window. The tests were running in headless mode by default.`), _tmpl$115 = /* @__PURE__ */ template(`<p>Added the <code>--headed</code> option to all manual test scripts. Now when you run tests for Safari or mobile debugging, an actual browser window will open for visual inspection.`), _tmpl$116 = /* @__PURE__ */ template(`<h4>Available test commands`), _tmpl$117 = /* @__PURE__ */ template(`<p><strong>Safari Desktop Manual Test:</strong><br><code>npm run test:safari-desktop</code><br>Opens webkit browser for desktop Safari testing with debug overlays.`), _tmpl$118 = /* @__PURE__ */ template(`<p><strong>iOS Safari Manual Test:</strong><br><code>npm run test:ios-safari</code><br>Opens webkit browser for mobile Safari testing.`), _tmpl$119 = /* @__PURE__ */ template(`<p><strong>Direct command with options:</strong><br><code>npx playwright test tests/safari-desktop-manual-test.spec.js --project=webkit --headed`), _tmpl$120 = /* @__PURE__ */ template(`<p><em>The test window stays open for 10 minutes to allow thorough manual testing. Press Ctrl+C to stop the test when done.`), _tmpl$121 = /* @__PURE__ */ template(`<p>Fixed a visual issue where the artwork was displaying grainy artifacts. The monochrome drawings now render cleanly at all zoom levels.`), _tmpl$122 = /* @__PURE__ */ template(`<p>The image had a noisy, pixelated appearance that was distracting. Adjusted the rendering settings to better handle black and white artwork - the difference is quite striking.`), _tmpl$123 = /* @__PURE__ */ template(`<p>Fixed several mobile-specific issues that were affecting the zoom experience and made the debug controls more reliable across all devices.`), _tmpl$124 = /* @__PURE__ */ template(`<h4>Mobile zoom improvements`), _tmpl$125 = /* @__PURE__ */ template(`<p><strong>Smoother zooming</strong><br>The cinematic zoom when tapping hotspots now performs better on phones and tablets. Reduced stuttering during the animation and improved frame rates on lower-end devices.`), _tmpl$126 = /* @__PURE__ */ template(`<p><strong>Touch responsiveness</strong><br>Fixed an issue where hotspots would sometimes become unresponsive after zooming. Touch interactions now reset properly after each zoom animation completes.`), _tmpl$127 = /* @__PURE__ */ template(`<h4>Debug panel refinements`), _tmpl$128 = /* @__PURE__ */ template(`<p>Made the mobile debug controls more stable - the slide-up panel now opens and closes more reliably, and the FPS counter updates consistently. Also improved the visual spacing on smaller screens.`), _tmpl$129 = /* @__PURE__ */ template(`<p><em>Small but important fixes that should make the mobile experience feel more polished and responsive.`), _tmpl$130 = /* @__PURE__ */ template(`<p>The debug controls (press 'C' to open) now work on phones and tablets.`), _tmpl$131 = /* @__PURE__ */ template(`<p><strong>Mobile devices</strong><br>A compact bar at the bottom shows FPS and a settings icon. Tap it to reveal controls that slide up. Swipe down or tap outside to dismiss.`), _tmpl$132 = /* @__PURE__ */ template(`<p><strong>Desktop</strong><br>The panel can now be minimized to a small floating button instead of closing completely.`), _tmpl$133 = /* @__PURE__ */ template(`<p><em>Small quality-of-life improvement, but it makes testing on different devices much more pleasant!`), _tmpl$134 = /* @__PURE__ */ template(`<p>The experimental touch-hold system I mentioned yesterday is now more reliable. After testing, I found and fixed an issue where hotspots would sometimes stop responding after being activated once.`), _tmpl$135 = /* @__PURE__ */ template(`<p>If you enable "Temporal" mode in the debug menu (press 'C'), the hold-to-interact system now works consistently. Hotspots stay visible while you hold them, and each interaction resets cleanly for the next one.`), _tmpl$136 = /* @__PURE__ */ template(`<h4>Also tweaked`), _tmpl$137 = /* @__PURE__ */ template(`<p>Added white color options to the border palette since you're working with black ink artwork. More importantly, <strong>temporal mode is now the default on mobile devices</strong> - meaning visitors will use the hold-to-interact system instead of direct taps. You can always switch back to standard tap-to-zoom in the debug menu if needed.`), _tmpl$138 = /* @__PURE__ */ template(`<p>With ~600 interactive zones hidden throughout your artwork, I've added a way to briefly reveal what's clickable without disrupting the visual experience.`), _tmpl$139 = /* @__PURE__ */ template(`<h4>How it works`), _tmpl$140 = /* @__PURE__ */ template(`<p>Press 'H' (desktop) or triple-tap anywhere (mobile) to make all nearby hotspots gently pulse for 6 seconds. The effect uses contrast inversion to ensure visibility on your black ink artwork while staying subtle enough not to break immersion.`), _tmpl$141 = /* @__PURE__ */ template(`<h4>Also included: Alternative touch controls`), _tmpl$142 = /* @__PURE__ */ template(`<p>For mobile users, I've prepared an experimental hold-to-interact system that's currently tucked away in the debug menu. If you're curious, press 'C' to open debug options and switch from "Direct" to "Temporal" interaction. This changes how taps work - but the standard tap-to-zoom remains the default for now.`), _tmpl$143 = /* @__PURE__ */ template(`<p>The reveal helper should make exploration feel less like guesswork and more like discovery. Let me know if the visibility needs adjusting - it's easy to make it bolder or more subtle based on your preference.`), _tmpl$144 = /* @__PURE__ */ template(`<p><strong>Safari animations:</strong> Now working! Chrome/Firefox/Edge still have the edge visually, but Safari's functional. Requires Safari 13.1+ (2020 or newer).`), _tmpl$145 = /* @__PURE__ */ template(`<p><strong>Smart zoom behavior:</strong> Following Google Arts & Culture's approach, animations now adapt to zoom level. Below 8x zoom = full animations. Above 8x = quick 150ms transitions only. When you're examining details up close, decorative animations would just distract.`), _tmpl$146 = /* @__PURE__ */ template(`<p><strong>Next:</strong> Making the cinematic zoom buttery smooth when clicking hotspots. Also thinking the stroke animation makes sense for desktop, but mobile needs something snappier.`), _tmpl$147 = /* @__PURE__ */ template(`<p><em>Personal note: Getting really excited - it's starting to take shape! :D`), _tmpl$148 = /* @__PURE__ */ template(`<p><strong>Current status:</strong> While the hover animations now work on Safari, the visual effect isn't as pronounced as on Chrome/Firefox. I'm quite proud of the result on chrome at the moment. I think it's quite satisfying.`), _tmpl$149 = /* @__PURE__ */ template(`<p><strong>Recommendation:</strong> Use Chrome for now to see the intended visual impact. The difference is noticeable - Chrome displays richer glows and better depth.`), _tmpl$150 = /* @__PURE__ */ template(`<p><strong>What's next:</strong> Working on Safari-specific optimizations to improve the visual quality without compromising performance.`), _tmpl$151 = /* @__PURE__ */ template(`<p><strong>Following up on July 7th:</strong> The Safari issue is fixed! The stroke reveal animation now works properly on Safari desktop where you can actually hover.`), _tmpl$152 = /* @__PURE__ */ template(`<p><strong>Next up</strong>: Making the animation more visible and impactful for desktop users, plus exploring touch-friendly animations for mobile devices.`), _tmpl$153 = /* @__PURE__ */ template(`<p><strong>Responding to your feedback:</strong> You mentioned the hover effect felt static with just the white border appearing. I've implemented a first animation to bring more life to the interactions.`), _tmpl$154 = /* @__PURE__ */ template(`<p><strong>What's new:</strong> A stroke reveal animation that progressively traces the hotspot outline when you hover. Instead of the border just "popping" into view, it now draws itself smoothly around the shape - like watching someone trace the contour with a pen.`), _tmpl$155 = /* @__PURE__ */ template(`<p><strong>Current settings:</strong><br>• White stroke with subtle shadow for visibility<br>• 1.2 second drawing animation<br>• Works on Chrome, Firefox, and Edge`), _tmpl$156 = /* @__PURE__ */ template(`<p><strong>Needs refinement:</strong> The animation is quite subtle right now - you might have to look closely to see the progressive drawing effect. I'll be adjusting the timing and visibility to make it more noticeable and satisfying.`), _tmpl$157 = /* @__PURE__ */ template(`<p><strong>Safari issue discovered:</strong> Just noticed the animation isn't working properly on Safari (There's always something with Safari 🙃). Will fix this tomorrow along with the other refinements.`), _tmpl$158 = /* @__PURE__ */ template(`<p><strong>Note:</strong> This is one hover effect I wanted to try first. I'm planning to experiment with additional animations to find what feels best for your artwork. Let me know your thoughts!`), _tmpl$159 = /* @__PURE__ */ template(`<p><strong>What's improved:</strong> The circular spotlight effect in Apple Mode (Safari/iOS) now adapts much better to different hotspot shapes.`), _tmpl$160 = /* @__PURE__ */ template(`<p><strong>What changed:</strong><br>• Spotlights are now tighter and more focused around each hotspot (both mobile and desktop)<br>• Better detection of when to use circles vs ellipses based on hotspot shape`), _tmpl$161 = /* @__PURE__ */ template(`<p><strong>The result:</strong> Whether a hotspot is round, tall, wide, or irregular, the spotlight should now feel more natural and better frame the content the user is exploring.`), _tmpl$162 = /* @__PURE__ */ template(`<p>Try clicking on different shaped hotspots - the spotlight should feel more consistent and purposeful now!`), _tmpl$163 = /* @__PURE__ */ template(`<p><strong>The issue:</strong> Some complex hotspots still extend outside the spotlight area after yesterday's improvements.`), _tmpl$164 = /* @__PURE__ */ template(`<p><strong>Today's attempt:</strong> Since a single circular spotlight can't perfectly cover irregular shapes, I tried combining multiple circles at different positions to fill in the gaps. Unfortunately, Safari doesn't support this technique - it only displays one spotlight instead of blending them together like other browsers do.`), _tmpl$165 = /* @__PURE__ */ template(`<p><strong>Next:</strong> Fine-tuning the spotlight sizing parameters to better fit each hotspot's unique shape.`), _tmpl$166 = /* @__PURE__ */ template(`<p><strong>What's improved:</strong> The spotlight effect on Safari and iOS devices now much better matches the actual hotspot shapes, especially on desktop Safari!`), _tmpl$167 = /* @__PURE__ */ template(`<p><strong>Key changes:</strong><br>• Spotlights now use elliptical shapes for elongated hotspots<br>• Tighter, more precise spotlight coverage that follows the hotspot boundaries closely<br>• Better visual consistency between the outline of the hotspot and the darkened area<br>• Desktop Safari shows the most dramatic improvements, mobile iOS continues to be refined`), _tmpl$168 = /* @__PURE__ */ template(`<p><strong>Still fine-tuning:</strong> Some complex hotspots have small areas that peek slightly outside the spotlight. Mobile Safari needs additional optimization for the same precision as desktop.`), _tmpl$169 = /* @__PURE__ */ template(`<p><strong>What's new:</strong> You can now leave feedback directly on each update! No need to switch to Telegram for quick comments.`), _tmpl$170 = /* @__PURE__ */ template(`<p><strong>How it works:</strong><br>• Type your feedback in the text box below any update<br>• Click "Post Feedback" to send<br>• Edit or delete your comments anytime<br>• Everything syncs in real-time between us`), _tmpl$171 = /* @__PURE__ */ template(`<p><strong>Quick tip:</strong> The system remembers who you are. If it shows the wrong name, just click "Change" above the feedback box to switch between Deji and Leonard.`), _tmpl$172 = /* @__PURE__ */ template(`<p>Feel free to test it out below! This makes it much easier to discuss specific features without jumping between apps.`), _tmpl$173 = /* @__PURE__ */ template(`<p><strong>The Problem:</strong> In Apple Mode, the circular gradient spotlight doesn't show the exact boundaries of the clickable area. Users might not know where the hotspot actually ends.`), _tmpl$174 = /* @__PURE__ */ template(`<p><strong>Context:</strong> Since Apple/Safari doesn't support the precise polygon cutouts we have in Standard Mode (that's their technical limitation), we need to work within these constraints.`), _tmpl$175 = /* @__PURE__ */ template(`<p><strong>Today's Experiment:</strong> Added a subtle outline that follows the exact hotspot shape. The gradient spotlight stays circular, but now the actual boundaries are visible.`), _tmpl$176 = /* @__PURE__ */ template(`<p><strong>Note:</strong> This is very much a work in progress. The current implementation might be too distracting, not visible enough, or just not the right approach entirely.`), _tmpl$177 = /* @__PURE__ */ template(`<p><strong>Try it yourself:</strong> In debug mode (press 'C'), there's now a button to cycle through different border styles - from subtle to bold. Your feedback will help determine if we should refine this solution or try something completely different.`), _tmpl$178 = /* @__PURE__ */ template(`<p><strong>Following up on July 1st:</strong> The Safari compatibility issue has been resolved with a custom implementation.`), _tmpl$179 = /* @__PURE__ */ template(`<p><strong>The Solution:</strong> Created a Safari-specific spotlight system that works within WebKit's limitations:<br>• Uses radial gradient masks instead of polygon cutouts<br>• Provides a circular/elliptical spotlight effect around hotspots<br>• Maintains smooth 60 FPS performance on all iOS devices`), _tmpl$180 = /* @__PURE__ */ template(`<p><strong>What's Different:</strong><br>• <strong>Chrome/Firefox:</strong> Precise polygon cutout matching exact hotspot shape<br>• <strong>Safari/iOS:</strong> Smooth gradient spotlight that adapts to hotspot size`), _tmpl$181 = /* @__PURE__ */ template(`<p><strong>Added Intelligence:</strong> While implementing the Safari solution, the system now analyzes each hotspot's complexity to determine optimal spotlight sizing. Complex shapes get more breathing room, simple shapes stay tight and focused.`), _tmpl$182 = /* @__PURE__ */ template(`<p><strong>Current Status:</strong> The spotlight effect now works on ALL devices and browsers, with each platform getting an optimized implementation.`), _tmpl$183 = /* @__PURE__ */ template(`<p><strong>Good news:</strong> The spotlight effect works great on the vast majority of devices and browsers. It works on Mac computers except when using Safari.`), _tmpl$184 = /* @__PURE__ */ template(`<p><strong>The only exception:</strong> Apple devices with Safari/WebKit. This includes:<br>• iPhone (Safari & Chrome)<br>• iPad (Safari & Chrome)<br>• Mac (Safari only - Chrome works fine!)`), _tmpl$185 = /* @__PURE__ */ template(`<p><strong>Why it can't work on these devices:</strong> Safari has a long-standing bug with creating transparent cutouts in overlays. On iOS, Apple forces all browsers (including Chrome) to use Safari's engine internally, so they inherit the same limitation.`), _tmpl$186 = /* @__PURE__ */ template(`<p><strong>What happens instead:</strong> The darkening works, but the hotspot shape doesn't get cut out - so everything stays dark instead of creating a spotlight effect.`), _tmpl$187 = /* @__PURE__ */ template(`<p><strong>To see the full effect:</strong> Use any non-Apple device, or use Chrome/Firefox on your Mac. The effect is smooth, precise, and quite satisfying to interact with!`), _tmpl$188 = /* @__PURE__ */ template(`<p><strong>Next steps:</strong> Creating a fallback specifically for Safari/iOS that will still provide visual focus, just using a different method.`), _tmpl$189 = /* @__PURE__ */ template(`<p><strong>New Feature - Zoom Speed Slider:</strong> Added a debug panel slider (desktop only) so you can test different cinematic zoom speeds when clicking hotspots. Press 'C' to toggle the debug panel and adjust the speed from 0.5x to 2.5x. Once you find your preferred speed, let me know and I'll make it permanent.`), _tmpl$190 = /* @__PURE__ */ template(`<p><strong>Zoom Behavior:</strong> The current zoom animation is really basic right now and will be improved.`), _tmpl$191 = /* @__PURE__ */ template(`<p><strong>Known Issues:</strong> There are some bugs with the zoom system - sometimes hotspots don't respond properly to clicks, and the zoom can behave unpredictably. These will be fixed along with the performance improvements. Oh and the "Full View" button does not appear on mobile right now 🤷 `), _tmpl$192 = /* @__PURE__ */ template(`<p><strong>Performance Status:</strong> While the spotlight effect is now perfect at 60 FPS, I'm still working on zoom performance. Currently experiencing significant lag on mobile when zooming to distant hotspots, and occasional frame drops on desktop during the zoom animation. This is my top priority to fix.`), _tmpl$193 = /* @__PURE__ */ template(`<p><strong>Flawless Synchronization:</strong> Fixed the "elastic lag" where spotlight would trail behind during zoom/pan (was using DOM positioning, now uses OpenSeadragon's native overlay system for perfect sync). Added intelligent progressive fade: as you pan/zoom away, the darkening smoothly fades before releasing focus. Creates a natural, cinematic experience that guides viewer attention. <em>(Fade transitions still being refined)`), _tmpl$194 = /* @__PURE__ */ template(`<p><strong>Focus Mode (Darkening Overlay):</strong> Implemented the spotlight effect you requested! When clicking a hotspot, surrounding areas darken to help viewers focus. This first version is basic but functional - ready for your feedback and refinement.`), _tmpl$195 = /* @__PURE__ */ template(`<p>Hey Deji! 👋`), _tmpl$196 = /* @__PURE__ */ template(`<p>I've been visiting friends and family in my hometown for the past 3 days, so I haven't been able to work as intensively on the project during that time.`), _tmpl$197 = /* @__PURE__ */ template(`<p>I totally relate to your potato mode confession 😅 We all have those moments where we just need to disconnect and recharge. Though honestly, your project is so motivating that it's been the perfect antidote to my own potato tendencies - I find myself constantly drawn back to it.`), _tmpl$198 = /* @__PURE__ */ template(`<p>I'm back home today and excited to dedicate my full attention to the project again. Your feedback was incredibly valuable – I'll be implementing all the adjustments you mentioned progressively. Right now, I'm focusing hard on eliminating FPS drops on mobile as I now understand how critical the mobile experience is.`), _tmpl$199 = /* @__PURE__ */ template(`<p><strong>P.S.</strong> I've temporarily been locked out of Upwork (they flagged some "unusual activity" on my account). They said it should be resolved by Monday, but if you need to reach me before then, I'm available on Telegram: <a href=https://t.me/LeonardCote target=_blank>@LeonardCote`), _tmpl$200 = /* @__PURE__ */ template(`<p>Looking forward to showing you the improvements!<br>- Leonard`), _tmpl$201 = /* @__PURE__ */ template(`<div class=message-content><h3 style="margin-top:30px;margin-bottom:20px;font-size:18px;color:rgba(255, 255, 255, 0.95);">Previous Updates`), _tmpl$202 = /* @__PURE__ */ template(`<div class=developer-message><div class=message-header><h3>Project Updates</h3><button class=close-btn aria-label="Close updates"role=button tabindex=0>×</button></div><style>
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-4px); }
        to { opacity: 1; transform: translateY(0); }
    }
</style><div class=message-toggle><button class=toggle-btn>`), _tmpl$203 = /* @__PURE__ */ template(`<div class=update-section><h4> (<!>)`), _tmpl$204 = /* @__PURE__ */ template(`<div class=app-container>`), _tmpl$205 = /* @__PURE__ */ template(`<div class=loading-screen><p>Loading Interactive Art Diary...`);
function DeveloperMessage({
  onClose
}) {
  const [showFullMessage, setShowFullMessage] = createSignal(false);
  createSignal(false);
  const allUpdates = [{
    id: "interaction-fixes-oct0607",
    date: "October 6-7",
    title: "🎯 Interaction Refinements",
    content: [(() => {
      var _el$ = _tmpl$(), _el$2 = _el$.firstChild, _el$4 = _el$2.nextSibling;
      _el$4.style.setProperty("color", "#FFD700");
      _el$4.style.setProperty("fontWeight", "600");
      return _el$;
    })(), (() => {
      var _el$5 = _tmpl$2(), _el$6 = _el$5.firstChild, _el$8 = _el$6.nextSibling;
      _el$8.style.setProperty("color", "#FFD700");
      _el$8.style.setProperty("fontWeight", "600");
      return _el$5;
    })(), _tmpl$3()]
  }, {
    id: "mobile-performance-oct01",
    date: "October 1",
    title: "📱 Mobile Performance Improvements",
    content: [(() => {
      var _el$0 = _tmpl$4(), _el$1 = _el$0.firstChild, _el$11 = _el$1.nextSibling;
      _el$11.style.setProperty("color", "#FFD700");
      _el$11.style.setProperty("fontWeight", "600");
      return _el$0;
    })(), _tmpl$5()]
  }, {
    id: "mobile-breakthrough-sep30",
    date: "September 30",
    title: "📱 Mobile Getting Better",
    content: [(() => {
      var _el$13 = _tmpl$6(), _el$14 = _el$13.firstChild, _el$16 = _el$14.nextSibling;
      _el$16.style.setProperty("color", "#FFD700");
      _el$16.style.setProperty("fontWeight", "600");
      return _el$13;
    })(), (() => {
      var _el$17 = _tmpl$7(), _el$18 = _el$17.firstChild, _el$20 = _el$18.nextSibling;
      _el$20.style.setProperty("color", "#FFD700");
      _el$20.style.setProperty("fontWeight", "600");
      return _el$17;
    })(), (() => {
      var _el$21 = _tmpl$8(), _el$22 = _el$21.firstChild, _el$23 = _el$22.firstChild, _el$25 = _el$23.nextSibling;
      _el$25.style.setProperty("color", "#FFD700");
      _el$25.style.setProperty("fontWeight", "600");
      return _el$21;
    })()]
  }, {
    id: "incremental-progress-sep27",
    date: "September 27",
    title: "🎨 Steady Performance Improvements",
    content: [(() => {
      var _el$26 = _tmpl$9(), _el$27 = _el$26.firstChild, _el$29 = _el$27.nextSibling;
      _el$29.style.setProperty("color", "#FFD700");
      _el$29.style.setProperty("fontWeight", "600");
      return _el$26;
    })(), (() => {
      var _el$30 = _tmpl$0(), _el$31 = _el$30.firstChild, _el$33 = _el$31.nextSibling;
      _el$33.style.setProperty("color", "#FFD700");
      _el$33.style.setProperty("fontWeight", "600");
      return _el$30;
    })(), _tmpl$1()]
  }, {
    id: "mobile-progress-sep26",
    date: "September 26",
    title: "📱 Mobile Performance Progress",
    content: [(() => {
      var _el$35 = _tmpl$10(), _el$36 = _el$35.firstChild, _el$38 = _el$36.nextSibling;
      _el$38.style.setProperty("color", "#FFD700");
      _el$38.style.setProperty("fontWeight", "600");
      return _el$35;
    })(), (() => {
      var _el$39 = _tmpl$11(), _el$40 = _el$39.firstChild, _el$42 = _el$40.nextSibling;
      _el$42.style.setProperty("color", "#FFD700");
      _el$42.style.setProperty("fontWeight", "600");
      return _el$39;
    })(), (() => {
      var _el$43 = _tmpl$12(), _el$44 = _el$43.firstChild, _el$45 = _el$44.firstChild, _el$47 = _el$45.nextSibling;
      _el$47.style.setProperty("color", "#FFD700");
      _el$47.style.setProperty("fontWeight", "600");
      return _el$43;
    })()]
  }, {
    id: "performance-progress-sep25",
    date: "September 25",
    title: "⚡ Rendering Engine Streamlined",
    content: [(() => {
      var _el$48 = _tmpl$13(), _el$49 = _el$48.firstChild, _el$51 = _el$49.nextSibling;
      _el$51.style.setProperty("color", "#FFD700");
      _el$51.style.setProperty("fontWeight", "600");
      return _el$48;
    })(), (() => {
      var _el$52 = _tmpl$14(), _el$53 = _el$52.firstChild, _el$55 = _el$53.nextSibling;
      _el$55.style.setProperty("color", "#FFD700");
      _el$55.style.setProperty("fontWeight", "600");
      return _el$52;
    })(), (() => {
      var _el$56 = _tmpl$15(), _el$57 = _el$56.firstChild, _el$58 = _el$57.firstChild, _el$60 = _el$58.nextSibling;
      _el$60.style.setProperty("color", "#FFD700");
      _el$60.style.setProperty("fontWeight", "600");
      return _el$56;
    })()]
  }, {
    id: "ios-canvas-fix-sep22",
    date: "September 22",
    title: "🔧 iOS Canvas Disappearing Fixed",
    content: [_tmpl$16(), _tmpl$17(), _tmpl$18()]
  }, {
    id: "mobile-performance-september21",
    date: "September 21",
    title: "📱 Mobile Performance Improvements",
    content: [_tmpl$19(), _tmpl$20(), _tmpl$21(), _tmpl$22()]
  }, {
    id: "haptic-support-september19",
    date: "September 19",
    title: "📳 Haptic Vibration Support",
    content: [_tmpl$23(), _tmpl$24(), (() => {
      var _el$70 = _tmpl$25(), _el$71 = _el$70.firstChild;
      _el$70.style.setProperty("marginTop", "12px");
      _el$70.style.setProperty("marginBottom", "16px");
      _el$70.style.setProperty("display", "flex");
      _el$70.style.setProperty("justifyContent", "center");
      _el$70.style.setProperty("alignItems", "center");
      _el$70.style.setProperty("overflow", "auto");
      setAttribute(_el$71, "src", tableauHaptic);
      _el$71.style.setProperty("display", "block");
      _el$71.style.setProperty("width", "100%");
      _el$71.style.setProperty("maxWidth", "400px");
      _el$71.style.setProperty("height", "auto");
      _el$71.style.setProperty("borderRadius", "8px");
      _el$71.style.setProperty("objectFit", "contain");
      return _el$70;
    })(), _tmpl$26(), _tmpl$27(), _tmpl$28(), _tmpl$29(), _tmpl$30()]
  }, {
    id: "memory-leak-fix-september10",
    date: "September 10",
    title: "📳 Critical Mobile Fix",
    content: [_tmpl$31(), _tmpl$32(), _tmpl$33(), _tmpl$34(), _tmpl$35()]
  }, {
    id: "ripple-mode-september07",
    date: "September 7",
    title: "🌊 Experimental Ripple Mode for Mobile",
    content: [_tmpl$36(), _tmpl$37(), _tmpl$38(), _tmpl$39(), _tmpl$40(), _tmpl$41(), _tmpl$42()]
  }, {
    id: "performance-fix-september03",
    date: "September 3",
    title: "✨ Major iPad Performance & Mobile Fade Fix",
    content: [_tmpl$43(), _tmpl$44(), _tmpl$45(), _tmpl$46(), _tmpl$47(), _tmpl$48()]
  }, {
    id: "cache-fix-september01",
    date: "September 1",
    title: "🔧 Animation Fix & Google Sheets Ready",
    content: [_tmpl$49(), _tmpl$50(), _tmpl$51(), _tmpl$52(), _tmpl$53()]
  }, {
    id: "single-reveal-august29",
    date: "August 29",
    title: "👆 Single Hotspot Reveal Mode",
    content: [_tmpl$54(), _tmpl$37(), _tmpl$55(), _tmpl$56(), _tmpl$57(), _tmpl$58()]
  }, {
    id: "ios-fixes-august28",
    date: "August 28",
    title: "🎯 iOS Bug Fixes",
    content: [_tmpl$59(), _tmpl$60(), _tmpl$61()]
  }, {
    id: "week-achievements-august14",
    date: "August 14",
    title: "🛠️ Performance Week",
    content: [_tmpl$62(), _tmpl$63(), _tmpl$64(), _tmpl$65()]
  }, {
    id: "mobile-performance-august9",
    date: "August 7",
    title: "📱 Mobile Performance Improvements",
    content: [_tmpl$66(), _tmpl$63(), _tmpl$67(), _tmpl$68(), _tmpl$69(), _tmpl$70(), _tmpl$71(), _tmpl$72()]
  }, {
    id: "mobile-ripple-august1",
    date: "August 1",
    title: "💫 Mobile Touch Feedback",
    content: [_tmpl$73(), _tmpl$37(), _tmpl$74(), _tmpl$75(), _tmpl$76(), _tmpl$77()]
  }, {
    id: "pigment-liner-improvements-july28",
    date: "July 28",
    title: "🎨 Authentic Pigment Liner Effects",
    content: [_tmpl$78(), _tmpl$37(), _tmpl$79(), _tmpl$80()]
  }, {
    id: "random-trace-points-july27",
    date: "July 27",
    title: "✨ Random Drawing Points",
    content: [_tmpl$81(), _tmpl$82(), _tmpl$83(), _tmpl$84()]
  }, {
    id: "organic-animations-july26",
    date: "July 26",
    title: "🌿 Natural Animation Variations",
    content: [_tmpl$85(), _tmpl$37(), _tmpl$86(), _tmpl$87(), _tmpl$88(), _tmpl$89()]
  }, {
    id: "button-zoom-improvements-july25",
    date: "July 25",
    title: "🎮 Button Controls & Zoom Improvements",
    content: [_tmpl$90(), _tmpl$91(), _tmpl$92(), _tmpl$93(), _tmpl$94(), _tmpl$95()]
  }, {
    id: "architecture-refactor-july24",
    date: "July 24",
    title: "🏗️ Major Architecture Improvements",
    content: [_tmpl$96(), _tmpl$97(), _tmpl$98(), _tmpl$99(), _tmpl$100(), _tmpl$101()]
  }, {
    id: "cinematic-zoom-fix-july16",
    date: "July 16",
    title: "🎯 Cinematic Zoom Fixed - No More Flickering",
    content: [_tmpl$102(), _tmpl$32(), _tmpl$103(), _tmpl$104(), _tmpl$105(), _tmpl$106(), _tmpl$107(), _tmpl$108(), _tmpl$68(), _tmpl$109(), _tmpl$110()]
  }, {
    id: "debug-menu-cleanup-july15",
    date: "July 15",
    title: "🧹 Debug Menu Simplified",
    content: [_tmpl$111(), _tmpl$82(), _tmpl$112(), _tmpl$113()]
  }, {
    id: "playwright-manual-tests-july15",
    date: "July 15",
    title: "🧪 Manual Test Window Fix for Playwright",
    content: [_tmpl$114(), _tmpl$82(), _tmpl$115(), _tmpl$116(), _tmpl$117(), _tmpl$118(), _tmpl$119(), _tmpl$120()]
  }, {
    id: "visual-artifacts-july15",
    date: "July 15",
    title: "🎨 Visual Quality Fix - No More Grain",
    content: [_tmpl$121(), _tmpl$82(), _tmpl$122()]
  }, {
    id: "mobile-zoom-july14",
    date: "July 14",
    title: "📱 Mobile Zoom Performance & Debug Improvements",
    content: [_tmpl$123(), _tmpl$124(), _tmpl$125(), _tmpl$126(), _tmpl$127(), _tmpl$128(), _tmpl$129()]
  }, {
    id: "debug-panel-july13",
    date: "July 13",
    title: "🎛️ Control Panel Goes Mobile-Friendly",
    content: [_tmpl$130(), _tmpl$37(), _tmpl$131(), _tmpl$132(), _tmpl$133()]
  }, {
    id: "temporal-polish-july12",
    date: "July 12",
    title: "📱 Mobile Touch Controls Refined",
    content: [_tmpl$134(), _tmpl$20(), _tmpl$135(), _tmpl$136(), _tmpl$137()]
  }, {
    id: "reveal-mode-july11",
    date: "July 11",
    title: "🔍 Easier Mobile Exploration",
    content: [_tmpl$138(), _tmpl$139(), _tmpl$140(), _tmpl$141(), _tmpl$142(), _tmpl$143()]
  }, {
    id: "safari-compatibility-july10",
    date: "July 10",
    title: "🍎 Safari Compatibility & Smart Zoom Update",
    content: [_tmpl$144(), _tmpl$145(), _tmpl$146(), _tmpl$147()]
  }, {
    id: "safari-visual-july9",
    date: "July 9",
    title: "Visual Effects - Browser Differences",
    content: [_tmpl$148(), _tmpl$149(), _tmpl$150()]
  }, {
    id: "safari-fix-july8",
    date: "July 8",
    title: "✅ Safari Issue Resolved",
    content: [_tmpl$151(), _tmpl$152()]
  }, {
    id: "hover-animations-july7",
    date: "July 7 - night",
    title: "✨ Hover Animation Update",
    content: [_tmpl$153(), _tmpl$154(), _tmpl$155(), _tmpl$156(), _tmpl$157(), _tmpl$158()]
  }, {
    id: "spotlight-refinements-july7",
    date: "July 7",
    title: "🍎 Apple Mode Spotlight Improvements",
    content: [_tmpl$159(), _tmpl$160(), _tmpl$161(), _tmpl$162()]
  }, {
    id: "spotlight-coverage-july5",
    date: "July 5",
    title: "🔍 Working on Complete Hotspot Coverage for Safari/iOS",
    content: [_tmpl$163(), _tmpl$164(), _tmpl$165()]
  }, {
    id: "spotlight-improvements-july4",
    date: "July 4",
    title: "🎯 Spotlight Effect Improvements for Safari/iOS",
    content: [_tmpl$166(), _tmpl$167(), _tmpl$168()]
  }, {
    id: "feedback-system-july3",
    date: "July 3 - night",
    title: "💬 New: Direct Feedback System",
    content: [_tmpl$169(), _tmpl$170(), _tmpl$171(), _tmpl$172()]
  }, {
    id: "border-experiment-july3",
    date: "July 3",
    title: "🔧 Border Experiment for Apple Mode",
    content: [_tmpl$173(), _tmpl$174(), _tmpl$175(), _tmpl$176(), _tmpl$177()]
  }, {
    id: "safari-solution-july2",
    date: "July 2",
    title: "✅ Safari/iOS Spotlight Solution Implemented",
    content: [_tmpl$178(), _tmpl$179(), _tmpl$180(), _tmpl$181(), _tmpl$182()]
  }, {
    id: "browser-compat-july1-night",
    date: "July 1 - night",
    title: "🔧 Spotlight Effect - Browser Compatibility",
    content: [_tmpl$183(), _tmpl$184(), _tmpl$185(), _tmpl$186(), _tmpl$187(), _tmpl$188()]
  }, {
    id: "zoom-speed-july1",
    date: "July 1",
    title: "🎬 Zoom Speed Control & Performance Update",
    content: [_tmpl$189(), _tmpl$190(), _tmpl$191(), _tmpl$192()]
  }, {
    id: "performance-june30",
    date: "June 30",
    title: "🎯 Performance Breakthrough",
    content: _tmpl$193()
  }, {
    id: "focus-mode-june29",
    date: "June 29",
    title: "🔧 New Feature",
    content: _tmpl$194()
  }, {
    id: "personal-june28",
    date: "June 28",
    title: "💬 Personal Message",
    content: [_tmpl$195(), _tmpl$196(), _tmpl$197(), _tmpl$198(), _tmpl$199(), _tmpl$200()]
  }];
  const recentUpdates = allUpdates.slice(0, 2);
  const olderUpdates = allUpdates.slice(2);
  return (() => {
    var _el$259 = _tmpl$202(), _el$260 = _el$259.firstChild, _el$261 = _el$260.firstChild, _el$262 = _el$261.nextSibling, _el$263 = _el$260.nextSibling, _el$264 = _el$263.nextSibling, _el$265 = _el$264.firstChild;
    _el$262.$$touchend = (e) => {
      e.preventDefault();
      e.stopPropagation();
      onClose();
    };
    addEventListener(_el$262, "click", onClose);
    insert(_el$259, () => recentUpdates.map((update) => (() => {
      var _el$268 = _tmpl$203(), _el$269 = _el$268.firstChild, _el$270 = _el$269.firstChild, _el$272 = _el$270.nextSibling;
      _el$272.nextSibling;
      insert(_el$269, () => update.title, _el$270);
      insert(_el$269, () => update.date, _el$272);
      insert(_el$268, () => update.content, null);
      insert(_el$268, createComponent(FeedbackSection, {
        get updateId() {
          return update.id;
        },
        get updateTitle() {
          return update.title;
        }
      }), null);
      return _el$268;
    })()), _el$264);
    _el$265.$$click = () => setShowFullMessage(!showFullMessage());
    insert(_el$265, () => showFullMessage() ? "− Hide previous updates" : "+ Show previous updates");
    insert(_el$259, createComponent(Show, {
      get when() {
        return showFullMessage();
      },
      get children() {
        var _el$266 = _tmpl$201();
        _el$266.firstChild;
        insert(_el$266, () => olderUpdates.map((update) => (() => {
          var _el$273 = _tmpl$203(), _el$274 = _el$273.firstChild, _el$275 = _el$274.firstChild, _el$277 = _el$275.nextSibling;
          _el$277.nextSibling;
          insert(_el$274, () => update.title, _el$275);
          insert(_el$274, () => update.date, _el$277);
          insert(_el$273, () => update.content, null);
          insert(_el$273, createComponent(FeedbackSection, {
            get updateId() {
              return update.id;
            },
            get updateTitle() {
              return update.title;
            }
          }), null);
          return _el$273;
        })()), null);
        return _el$266;
      }
    }), null);
    return _el$259;
  })();
}
function App() {
  const [loaded, setLoaded] = createSignal(false);
  const [currentArtwork] = createSignal("zebra");
  const isAutomatedTest = typeof navigator !== "undefined" && navigator.webdriver === true;
  const [showMessage, setShowMessage] = createSignal(!isAutomatedTest);
  const handleCloseMessage = () => {
    console.log("Closing developer message panel");
    setShowMessage(false);
    console.log("Loaded status:", loaded());
    const isIPhone2 = /iPhone/.test(navigator.userAgent) && !/iPad/.test(navigator.userAgent);
    if (isIPhone2) {
      console.log("iPhone detected - viewer will initialize after panel closes");
    }
  };
  onMount(() => {
    console.log("Interactive Art Diary loaded");
    const passiveSupported = initializePassiveEventOptimization();
    console.log("[App] Passive events optimization:", passiveSupported ? "enabled" : "not supported");
    setLoaded(true);
  });
  return (() => {
    var _el$278 = _tmpl$204();
    insert(_el$278, createComponent(FPSMonitor, {}), null);
    insert(_el$278, (() => {
      var _c$ = memo(() => !!showMessage());
      return () => _c$() && createComponent(DeveloperMessage, {
        onClose: handleCloseMessage
      });
    })(), null);
    insert(_el$278, (() => {
      var _c$2 = memo(() => !!(!showMessage() && loaded()));
      return () => _c$2() ? createComponent(ArtworkViewer, {
        get artworkId() {
          return currentArtwork();
        }
      }) : memo(() => !!!showMessage())() ? _tmpl$205() : null;
    })(), null);
    return _el$278;
  })();
}
delegateEvents(["click", "touchend"]);
const root = document.getElementById("root");
render(() => createComponent(App, {}), root);
export {
  OpenSeadragon as O,
  __vitePreload as _,
  applyTileCascadeFix as a,
  getTuningState as b,
  OverlayManagerFactory as c,
  applyTuningToViewer as d,
  createLogger as e,
  getDefaultExportFromCjs as f,
  getBrowserOptimalDrawer as g,
  commonjsGlobal$2 as h,
  isMobile as i,
  removeTileCascadeFix as r
};
