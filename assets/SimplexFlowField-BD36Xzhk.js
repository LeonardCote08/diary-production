const A=Math.sqrt(3),O=.5*(A-1),w=(3-A)/6,$=p=>Math.floor(p)|0,j=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);function q(p=Math.random){const t=G(p),s=new Float64Array(t).map(i=>j[i%12*2]),e=new Float64Array(t).map(i=>j[i%12*2+1]);return function(n,c){let l=0,r=0,a=0;const h=(n+c)*O,o=$(n+h),u=$(c+h),P=(o+u)*w,v=o-P,D=u-P,y=n-v,d=c-D;let I,S;y>d?(I=1,S=0):(I=0,S=1);const b=y-I+w,z=d-S+w,C=y-1+2*w,X=d-1+2*w,Y=o&255,U=u&255;let x=.5-y*y-d*d;if(x>=0){const f=Y+t[U],F=s[f],g=e[f];x*=x,l=x*x*(F*y+g*d)}let m=.5-b*b-z*z;if(m>=0){const f=Y+I+t[U+S],F=s[f],g=e[f];m*=m,r=m*m*(F*b+g*z)}let M=.5-C*C-X*X;if(M>=0){const f=Y+1+t[U+1],F=s[f],g=e[f];M*=M,a=M*M*(F*C+g*X)}return 70*(l+r+a)}}function G(p){const s=new Uint8Array(512);for(let e=0;e<512/2;e++)s[e]=e;for(let e=0;e<512/2-1;e++){const i=e+~~(p()*(256-e)),n=s[e];s[e]=s[i],s[i]=n}for(let e=256;e<512;e++)s[e]=s[e-256];return s}class K{constructor(t){this.resolution=t.resolution||20,this.viewer=t.viewer,this.noise2D=q(),this.scale=.007,this.timeOffset=0,this.timeIncrement=.015,this.fieldCache=new Map,this.lastFieldUpdate=0,this.fieldUpdateInterval=100,this.preCalculatedFields=[],this.currentFieldIndex=0,this.resolution>=40&&this.generatePreCalculatedFields()}generatePreCalculatedFields(){for(let s=0;s<10;s++){const e={vectors:new Map,seed:s*1e3},i=Math.ceil(1/this.resolution);for(let n=0;n<=i;n++)for(let c=0;c<=i;c++){const l=n*this.resolution,r=c*this.resolution,a=this.noise2D(l*this.scale+e.seed,r*this.scale)*Math.PI*2,h={x:Math.cos(a),y:Math.sin(a),magnitude:.5+this.noise2D(l*this.scale*2+e.seed,r*this.scale*2)*.5};e.vectors.set(`${n},${c}`,h)}this.preCalculatedFields.push(e)}}calculatePath(t,s){const e=t.getCenter(),i=s.getCenter();return this.resolution>=40&&this.preCalculatedFields.length>0?this.calculatePreCalculatedPath(e,i):this.calculateDynamicPath(e,i)}calculatePreCalculatedPath(t,s){const e=Math.abs(t.x+t.y+s.x+s.y),i=Math.floor(e*10)%this.preCalculatedFields.length,n=this.preCalculatedFields[i];return{getInfluence:c=>{const l=t.x+(s.x-t.x)*c,r=t.y+(s.y-t.y)*c,a=Math.floor(l/this.resolution),h=Math.floor(r/this.resolution),o=n.vectors.get(`${a},${h}`);if(o){const u=1-c;return{x:o.x*o.magnitude*u*.02,y:o.y*o.magnitude*u*.02}}return{x:0,y:0}}}}calculateDynamicPath(t,s){const e=Math.sqrt(Math.pow(s.x-t.x,2)+Math.pow(s.y-t.y,2)),i=performance.now();return i-this.lastFieldUpdate>this.fieldUpdateInterval&&(this.timeOffset+=this.timeIncrement,this.lastFieldUpdate=i),{pathLength:e,getInfluence:n=>{const c=t.x+(s.x-t.x)*n,l=t.y+(s.y-t.y)*n,r=this.sampleFlowField(c,l),a=s.x-t.x,h=s.y-t.y,o=Math.sqrt(a*a+h*h);if(o>0){const u=-h/o,P=a/o,v=Math.sin(n*Math.PI),D=Math.sin(n*Math.PI*2+r.x*.5),d=.2*Math.min(e*.5,.3);return{x:u*D*v*d,y:P*D*v*d}}return{x:0,y:0}}}}sampleFlowField(t,s){const e=`${Math.round(t*1e3)},${Math.round(s*1e3)}`;if(this.fieldCache.has(e))return this.fieldCache.get(e);const i=this.noise2D(t*this.scale*.5+this.timeOffset,s*this.scale*.5)*Math.PI,n=.3+this.noise2D(t*this.scale+this.timeOffset,s*this.scale)*.2,c={x:Math.cos(i)*n,y:Math.sin(i)*n};if(this.fieldCache.set(e,c),this.fieldCache.size>1e3){const l=this.fieldCache.keys().next().value;this.fieldCache.delete(l)}return c}setResolution(t){this.resolution=t,this.fieldCache.clear(),t>=40&&this.generatePreCalculatedFields()}setScale(t){this.scale=t,this.fieldCache.clear()}destroy(){this.fieldCache.clear(),this.preCalculatedFields=[]}}export{K as default};
